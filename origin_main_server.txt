# -*- coding: utf-8 -*-
import sys, os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Windows multiprocessing 鏀寔锛氱‘淇濆瓙杩涚▼涓嶄細閲嶅鎵ц妯″潡绾у垵濮嬪寲
from multiprocessing import freeze_support
freeze_support()

# 妫€鏌ユ槸鍚﹂渶瑕佹墽琛屽垵濮嬪寲锛堢敤浜庨槻姝?Windows spawn 鏂瑰紡鍒涘缓鐨勫瓙杩涚▼閲嶅鍒濆鍖栵級
# 鏂规锛氶娆″鍏ユ椂璁剧疆鐜鍙橀噺鏍囪锛屽瓙杩涚▼浼氱户鎵胯繖涓爣璁颁粠鑰岃烦杩囧垵濮嬪寲
_INIT_MARKER = '_NEKO_MAIN_SERVER_INITIALIZED'
_IS_MAIN_PROCESS = _INIT_MARKER not in os.environ

if _IS_MAIN_PROCESS:
    # 绔嬪嵆璁剧疆鏍囪锛岃繖鏍蜂换浣曚粠姝よ繘绋?spawn 鐨勫瓙杩涚▼閮戒細缁ф壙姝ゆ爣璁?    os.environ[_INIT_MARKER] = '1'

# 鑾峰彇搴旂敤绋嬪簭鏍圭洰褰曪紙涓?config_manager 淇濇寔涓€鑷达級
def _get_app_root():
    if getattr(sys, 'frozen', False):
        if hasattr(sys, '_MEIPASS'):
            return sys._MEIPASS
        else:
            return os.path.dirname(sys.executable)
    else:
        return os.getcwd()

# Only adjust DLL search path on Windows
if sys.platform == "win32" and hasattr(os, "add_dll_directory"):
    os.add_dll_directory(_get_app_root())
    
import mimetypes
mimetypes.add_type("application/javascript", ".js")
import asyncio
import json
import uuid
import logging
from datetime import datetime
import webbrowser
import io
import threading
import time
from typing import Optional
from urllib.parse import quote, unquote
from steamworks.exceptions import SteamNotLoadedException
from steamworks.enums import EWorkshopFileType, EItemUpdateStatus
import base64
import tempfile
from utils.screenshot_utils import analyze_screenshot_from_data_url


from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, File, UploadFile, Form, Body
from fastapi.staticfiles import StaticFiles
from main_helper import core as core, cross_server as cross_server
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, JSONResponse, Response
from urllib.parse import unquote
from utils.preferences import load_user_preferences, update_model_preferences, validate_model_preferences, move_model_to_top
from utils.frontend_utils import find_models, find_model_config_file, find_model_directory, find_model_by_workshop_item_id, find_workshop_item_by_id
from threading import Thread, Event as ThreadEvent
from queue import Queue
import atexit
import dashscope
from dashscope.audio.tts_v2 import VoiceEnrollmentService
import httpx
import pathlib, wave
from openai import AsyncOpenAI, APIConnectionError, InternalServerError, RateLimitError
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage
from config import MAIN_SERVER_PORT, MONITOR_SERVER_PORT, MEMORY_SERVER_PORT, MODELS_WITH_EXTRA_BODY, TOOL_SERVER_PORT, USER_PLUGIN_SERVER_PORT
from config.prompts_sys import emotion_analysis_prompt, proactive_chat_prompt, proactive_chat_prompt_screenshot
import glob
from utils.config_manager import get_config_manager
# 瀵煎叆鍒涙剰宸ュ潑宸ュ叿妯″潡
from utils.workshop_utils import (
    load_workshop_config,
    save_workshop_config,
    ensure_workshop_folder_exists,
    get_workshop_root,
    get_workshop_path,
    extract_workshop_root_from_items
)



# 纭畾 templates 鐩綍浣嶇疆锛堜娇鐢?_get_app_root锛?template_dir = _get_app_root()

templates = Jinja2Templates(directory=template_dir)

def initialize_steamworks():
    try:
        # 鏄庣‘璇诲彇steam_appid.txt鏂囦欢浠ヨ幏鍙栧簲鐢↖D
        app_id = None
        app_id_file = os.path.join(_get_app_root(), 'steam_appid.txt')
        if os.path.exists(app_id_file):
            with open(app_id_file, 'r') as f:
                app_id = f.read().strip()
            print(f"浠巗team_appid.txt璇诲彇鍒板簲鐢↖D: {app_id}")
        
        # 鍒涘缓骞跺垵濮嬪寲Steamworks瀹炰緥
        from steamworks import STEAMWORKS
        from steamworks.exceptions import SteamNotLoadedException
        steamworks = STEAMWORKS()
        # 鏄剧ずSteamworks鍒濆鍖栬繃绋嬬殑璇︾粏鏃ュ織
        print("姝ｅ湪鍒濆鍖朣teamworks...")
        steamworks.initialize()
        steamworks.UserStats.RequestCurrentStats()
        # 鍒濆鍖栧悗鍐嶆鑾峰彇搴旂敤ID浠ョ‘璁?        actual_app_id = steamworks.app_id
        print(f"Steamworks鍒濆鍖栧畬鎴愶紝瀹為檯浣跨敤鐨勫簲鐢↖D: {actual_app_id}")
        
        # 妫€鏌ュ叏灞€logger鏄惁宸插垵濮嬪寲锛屽鏋滃凡鍒濆鍖栧垯璁板綍鎴愬姛淇℃伅
        if 'logger' in globals():
            logger.info(f"Steamworks鍒濆鍖栨垚鍔燂紝搴旂敤ID: {actual_app_id}")
            logger.info(f"Steam瀹㈡埛绔繍琛岀姸鎬? {steamworks.IsSteamRunning()}")
            logger.info(f"Steam瑕嗙洊灞傚惎鐢ㄧ姸鎬? {steamworks.IsOverlayEnabled()}")
        
        return steamworks
    except Exception as e:
        # 妫€鏌ュ叏灞€logger鏄惁宸插垵濮嬪寲锛屽鏋滃凡鍒濆鍖栧垯璁板綍閿欒锛屽惁鍒欎娇鐢╬rint
        error_msg = f"鍒濆鍖朣teamworks澶辫触: {e}"
        if 'logger' in globals():
            logger.error(error_msg)
        else:
            print(error_msg)
        return None

def get_default_steam_info():
    global steamworks
    # 妫€鏌teamworks鏄惁鍒濆鍖栨垚鍔?    if steamworks is None:
        print("Steamworks not initialized. Skipping Steam functionality.")
        if 'logger' in globals():
            logger.info("Steamworks not initialized. Skipping Steam functionality.")
        return
    
    try:
        my_steam64 = steamworks.Users.GetSteamID()
        my_steam_level = steamworks.Users.GetPlayerSteamLevel()
        subscribed_apps = steamworks.Workshop.GetNumSubscribedItems()
        print(f'Subscribed apps: {subscribed_apps}')

        print(f'Logged on as {my_steam64}, level: {my_steam_level}')
        print('Is subscribed to current app?', steamworks.Apps.IsSubscribed())
    except Exception as e:
        print(f"Error accessing Steamworks API: {e}")
        if 'logger' in globals():
            logger.error(f"Error accessing Steamworks API: {e}")

# 鍒濆鍖朣teamworks锛屼絾鍗充娇澶辫触涔熺户缁惎鍔ㄦ湇鍔?# 鍙湪涓昏繘绋嬩腑鍒濆鍖栵紝闃叉瀛愯繘绋嬮噸澶嶅垵濮嬪寲
if _IS_MAIN_PROCESS:
    steamworks = initialize_steamworks()
    # 灏濊瘯鑾峰彇Steam淇℃伅锛屽鏋滃け璐ヤ篃涓嶄細闃绘鏈嶅姟鍚姩
    get_default_steam_info()
else:
    steamworks = None


# 浣跨敤鐪熷疄鐨勬埅鍥惧簱锛屽嚱鏁板凡浠巙tils.screenshot_utils瀵煎叆


# Configure logging (瀛愯繘绋嬮潤榛樺垵濮嬪寲锛岄伩鍏嶉噸澶嶆墦鍗板垵濮嬪寲娑堟伅)
from utils.logger_config import setup_logging

logger, log_config = setup_logging(service_name="Main", log_level=logging.INFO, silent=not _IS_MAIN_PROCESS)

_config_manager = get_config_manager()

def cleanup():
    logger.info("Starting cleanup process")
    for k in sync_message_queue:
        # 娓呯┖闃熷垪锛坬ueue.Queue 娌℃湁 close/join_thread 鏂规硶锛?        try:
            while sync_message_queue[k] and not sync_message_queue[k].empty():
                sync_message_queue[k].get_nowait()
        except:
            pass
    logger.info("Cleanup completed")

# 鍙湪涓昏繘绋嬩腑娉ㄥ唽 cleanup 鍑芥暟锛岄槻姝㈠瓙杩涚▼閫€鍑烘椂鎵ц娓呯悊
if _IS_MAIN_PROCESS:
    atexit.register(cleanup)

sync_message_queue = {}
sync_shutdown_event = {}
session_manager = {}
session_id = {}
sync_process = {}
# 姣忎釜瑙掕壊鐨剋ebsocket鎿嶄綔閿侊紝鐢ㄤ簬闃叉preserve/restore涓巆leanup()涔嬮棿鐨勭珵浜?websocket_locks = {}
# Global variables for character data (will be updated on reload)
master_name = None
her_name = None
master_basic_config = None
lanlan_basic_config = None
name_mapping = None
lanlan_prompt = None
semantic_store = None
time_store = None
setting_store = None
recent_log = None
catgirl_names = []

async def initialize_character_data():
    """鍒濆鍖栨垨閲嶆柊鍔犺浇瑙掕壊閰嶇疆鏁版嵁"""
    global master_name, her_name, master_basic_config, lanlan_basic_config
    global name_mapping, lanlan_prompt, semantic_store, time_store, setting_store, recent_log
    global catgirl_names, sync_message_queue, sync_shutdown_event, session_manager, session_id, sync_process, websocket_locks
    
    logger.info("姝ｅ湪鍔犺浇瑙掕壊閰嶇疆...")
    
    # 娓呯悊鏃犳晥鐨剉oice_id寮曠敤
    _config_manager.cleanup_invalid_voice_ids()
    
    # 鍔犺浇鏈€鏂扮殑瑙掕壊鏁版嵁
    master_name, her_name, master_basic_config, lanlan_basic_config, name_mapping, lanlan_prompt, semantic_store, time_store, setting_store, recent_log = _config_manager.get_character_data()
    catgirl_names = list(lanlan_prompt.keys())
    
    # 涓烘柊澧炵殑瑙掕壊鍒濆鍖栬祫婧?    for k in catgirl_names:
        is_new_character = False
        if k not in sync_message_queue:
            sync_message_queue[k] = Queue()
            sync_shutdown_event[k] = ThreadEvent()
            session_id[k] = None
            sync_process[k] = None
            logger.info(f"涓鸿鑹?{k} 鍒濆鍖栨柊璧勬簮")
            is_new_character = True
        
        # 纭繚璇ヨ鑹叉湁websocket閿?        if k not in websocket_locks:
            websocket_locks[k] = asyncio.Lock()
        
        # 鏇存柊鎴栧垱寤簊ession manager锛堜娇鐢ㄦ渶鏂扮殑prompt锛?        # 浣跨敤閿佷繚鎶ebsocket鐨刾reserve/restore鎿嶄綔锛岄槻姝笌cleanup()绔炰簤
        async with websocket_locks[k]:
            # 濡傛灉宸插瓨鍦ㄤ笖宸叉湁websocket杩炴帴锛屼繚鐣檞ebsocket寮曠敤
            old_websocket = None
            if k in session_manager and session_manager[k].websocket:
                old_websocket = session_manager[k].websocket
                logger.info(f"淇濈暀 {k} 鐨勭幇鏈塛ebSocket杩炴帴")
            
            # 娉ㄦ剰锛氫笉鍦ㄨ繖閲屾竻鐞嗘棫session锛屽洜涓猴細
            # 1. 鍒囨崲褰撳墠瑙掕壊闊宠壊鏃讹紝宸插湪API灞傞潰鍏抽棴浜唖ession
            # 2. 鍒囨崲鍏朵粬瑙掕壊闊宠壊鏃讹紝宸茶烦杩囬噸鏂板姞杞?            # 3. 鍏朵粬鍦烘櫙涓嶅簲璇ュ奖鍝嶆鍦ㄤ娇鐢ㄧ殑session
            # 濡傛灉鏃ession_manager鏈夋椿璺僺ession锛屼繚鐣欏畠锛屽彧鏇存柊閰嶇疆鐩稿叧鐨勫瓧娈?            
            # 鍏堟鏌ヤ細璇濈姸鎬侊紙鍦ㄩ攣鍐呮鏌ラ伩鍏嶇珵鎬佹潯浠讹級
            has_active_session = k in session_manager and session_manager[k].is_active
            
            if has_active_session:
                # 鏈夋椿璺僺ession锛屼笉閲嶆柊鍒涘缓session_manager锛屽彧鏇存柊閰嶇疆
                # 杩欐槸涓轰簡闃叉閲嶆柊鍒涘缓session_manager鏃剁牬鍧忔鍦ㄨ繍琛岀殑session
                try:
                    old_mgr = session_manager[k]
                    # 鏇存柊prompt
                    old_mgr.lanlan_prompt = lanlan_prompt[k].replace('{LANLAN_NAME}', k).replace('{MASTER_NAME}', master_name)
                    # 閲嶆柊璇诲彇瑙掕壊閰嶇疆浠ユ洿鏂皏oice_id绛夊瓧娈?                    (
                        _,
                        _,
                        _,
                        lanlan_basic_config_updated,
                        _,
                        _,
                        _,
                        _,
                        _,
                        _
                    ) = _config_manager.get_character_data()
                    # 鏇存柊voice_id锛堣繖鏄垏鎹㈤煶鑹叉椂闇€瑕佺殑锛?                    old_mgr.voice_id = lanlan_basic_config_updated[k].get('voice_id', '')
                    logger.info(f"{k} 鏈夋椿璺僺ession锛屽彧鏇存柊閰嶇疆锛屼笉閲嶆柊鍒涘缓session_manager")
                except Exception as e:
                    logger.error(f"鏇存柊 {k} 鐨勬椿璺僺ession閰嶇疆澶辫触: {e}", exc_info=True)
                    # 閰嶇疆鏇存柊澶辫触锛屼絾涓轰簡涓嶅奖鍝嶆鍦ㄨ繍琛岀殑session锛岀户缁娇鐢ㄦ棫閰嶇疆
                    # 濡傛灉纭疄闇€瑕佹洿鏂伴厤缃紝鍙互鑰冭檻鍦ㄤ笅娆ession閲嶅惎鏃跺啀搴旂敤
            else:
                # 娌℃湁娲昏穬session锛屽彲浠ュ畨鍏ㄥ湴閲嶆柊鍒涘缓session_manager
                session_manager[k] = core.LLMSessionManager(
                    sync_message_queue[k],
                    k,
                    lanlan_prompt[k].replace('{LANLAN_NAME}', k).replace('{MASTER_NAME}', master_name)
                )
                
                # 灏唚ebsocket閿佸瓨鍌ㄥ埌session manager涓紝渚沜leanup()浣跨敤
                session_manager[k].websocket_lock = websocket_locks[k]
                
                # 鎭㈠websocket寮曠敤锛堝鏋滃瓨鍦級
                if old_websocket:
                    session_manager[k].websocket = old_websocket
                    logger.info(f"宸叉仮澶?{k} 鐨刉ebSocket杩炴帴")
        
        # 妫€鏌ュ苟鍚姩鍚屾杩炴帴鍣ㄧ嚎绋?        # 濡傛灉鏄柊瑙掕壊锛屾垨鑰呯嚎绋嬩笉瀛樺湪/宸插仠姝紝闇€瑕佸惎鍔ㄧ嚎绋?        if k not in sync_process:
            sync_process[k] = None
        
        need_start_thread = False
        if is_new_character:
            # 鏂拌鑹诧紝闇€瑕佸惎鍔ㄧ嚎绋?            need_start_thread = True
        elif sync_process[k] is None:
            # 绾跨▼涓篘one锛岄渶瑕佸惎鍔?            need_start_thread = True
        elif hasattr(sync_process[k], 'is_alive') and not sync_process[k].is_alive():
            # 绾跨▼宸插仠姝紝闇€瑕侀噸鍚?            need_start_thread = True
            try:
                sync_process[k].join(timeout=0.1)
            except:
                pass
        
        if need_start_thread:
            try:
                sync_process[k] = Thread(
                    target=cross_server.sync_connector_process,
                    args=(sync_message_queue[k], sync_shutdown_event[k], k, f"ws://localhost:{MONITOR_SERVER_PORT}", {'bullet': False, 'monitor': True}),
                    daemon=True,
                    name=f"SyncConnector-{k}"
                )
                sync_process[k].start()
                logger.info(f"鉁?宸蹭负瑙掕壊 {k} 鍚姩鍚屾杩炴帴鍣ㄧ嚎绋?({sync_process[k].name})")
                await asyncio.sleep(0.1)  # 绾跨▼鍚姩鏇村揩锛屽噺灏戠瓑寰呮椂闂?                if not sync_process[k].is_alive():
                    logger.error(f"鉂?鍚屾杩炴帴鍣ㄧ嚎绋?{k} ({sync_process[k].name}) 鍚姩鍚庣珛鍗抽€€鍑猴紒")
                else:
                    logger.info(f"鉁?鍚屾杩炴帴鍣ㄧ嚎绋?{k} ({sync_process[k].name}) 姝ｅ湪杩愯")
            except Exception as e:
                logger.error(f"鉂?鍚姩瑙掕壊 {k} 鐨勫悓姝ヨ繛鎺ュ櫒绾跨▼澶辫触: {e}", exc_info=True)
    
    # 娓呯悊宸插垹闄よ鑹茬殑璧勬簮
    removed_names = [k for k in session_manager.keys() if k not in catgirl_names]
    for k in removed_names:
        logger.info(f"娓呯悊宸插垹闄よ鑹?{k} 鐨勮祫婧?)
        
        # 鍏堝仠姝㈠悓姝ヨ繛鎺ュ櫒绾跨▼锛堢嚎绋嬪彧鑳藉崗浣滃紡缁堟锛屼笉鑳藉己鍒秌ill锛?        if k in sync_process and sync_process[k] is not None:
            try:
                logger.info(f"姝ｅ湪鍋滄宸插垹闄よ鑹?{k} 鐨勫悓姝ヨ繛鎺ュ櫒绾跨▼...")
                if k in sync_shutdown_event:
                    sync_shutdown_event[k].set()
                sync_process[k].join(timeout=3)  # 绛夊緟绾跨▼姝ｅ父缁撴潫
                if sync_process[k].is_alive():
                    logger.warning(f"鈿狅笍 鍚屾杩炴帴鍣ㄧ嚎绋?{k} 鏈兘鍦ㄨ秴鏃跺唴鍋滄锛屽皢浣滀负daemon绾跨▼鑷姩娓呯悊")
                else:
                    logger.info(f"鉁?宸插仠姝㈣鑹?{k} 鐨勫悓姝ヨ繛鎺ュ櫒绾跨▼")
            except Exception as e:
                logger.warning(f"鍋滄瑙掕壊 {k} 鐨勫悓姝ヨ繛鎺ュ櫒绾跨▼鏃跺嚭閿? {e}")
        
        # 娓呯悊闃熷垪锛坬ueue.Queue 娌℃湁 close/join_thread 鏂规硶锛?        if k in sync_message_queue:
            try:
                while not sync_message_queue[k].empty():
                    sync_message_queue[k].get_nowait()
            except:
                pass
            del sync_message_queue[k]
        
        # 娓呯悊鍏朵粬璧勬簮
        if k in sync_shutdown_event:
            del sync_shutdown_event[k]
        if k in session_manager:
            del session_manager[k]
        if k in session_id:
            del session_id[k]
        if k in sync_process:
            del sync_process[k]
    
    logger.info(f"瑙掕壊閰嶇疆鍔犺浇瀹屾垚锛屽綋鍓嶈鑹? {catgirl_names}锛屼富浜? {master_name}")

# 鍒濆鍖栬鑹叉暟鎹紙浣跨敤asyncio.run鍦ㄦā鍧楃骇鍒墽琛宎sync鍑芥暟锛?# 鍙湪涓昏繘绋嬩腑鎵ц锛岄槻姝?Windows 涓婂瓙杩涚▼閲嶅瀵煎叆鏃跺啀娆″惎鍔ㄥ瓙杩涚▼
if _IS_MAIN_PROCESS:
    import asyncio as _init_asyncio
    try:
        _init_asyncio.get_event_loop()
    except RuntimeError:
        _init_asyncio.set_event_loop(_init_asyncio.new_event_loop())
    _init_asyncio.get_event_loop().run_until_complete(initialize_character_data())
lock = asyncio.Lock()

# --- FastAPI App Setup ---
app = FastAPI()

class CustomStaticFiles(StaticFiles):
    async def get_response(self, path, scope):
        response = await super().get_response(path, scope)
        if path.endswith('.js'):
            response.headers['Content-Type'] = 'application/javascript'
        return response

# 纭畾 static 鐩綍浣嶇疆锛堜娇鐢?_get_app_root锛?static_dir = os.path.join(_get_app_root(), 'static')

app.mount("/static", CustomStaticFiles(directory=static_dir), name="static")

# 鎸傝浇鐢ㄦ埛鏂囨。涓嬬殑live2d鐩綍锛堝彧鍦ㄤ富杩涚▼涓墽琛岋紝瀛愯繘绋嬩笉鎻愪緵HTTP鏈嶅姟锛?if _IS_MAIN_PROCESS:
    _config_manager.ensure_live2d_directory()
    user_live2d_path = str(_config_manager.live2d_dir)
    if os.path.exists(user_live2d_path):
        app.mount("/user_live2d", CustomStaticFiles(directory=user_live2d_path), name="user_live2d")
        logger.info(f"宸叉寕杞界敤鎴稬ive2D鐩綍: {user_live2d_path}")

    # 鎸傝浇鐢ㄦ埛mod璺緞
    user_mod_path = _config_manager.get_workshop_path()
    if os.path.exists(user_mod_path) and os.path.isdir(user_mod_path):
        app.mount("/user_mods", CustomStaticFiles(directory=user_mod_path), name="user_mods")
        logger.info(f"宸叉寕杞界敤鎴穖od璺緞: {user_mod_path}")

# 浣跨敤 FastAPI 鐨?app.state 鏉ョ鐞嗗惎鍔ㄩ厤缃?def get_start_config():
    """浠?app.state 鑾峰彇鍚姩閰嶇疆"""
    if hasattr(app.state, 'start_config'):
        return app.state.start_config
    return {
        "browser_mode_enabled": False,
        "browser_page": "chara_manager",
        'server': None
    }

def set_start_config(config):
    """璁剧疆鍚姩閰嶇疆鍒?app.state"""
    app.state.start_config = config

@app.get("/", response_class=HTMLResponse)
async def get_default_index(request: Request):
    return templates.TemplateResponse("templates/index.html", {
        "request": request
    })


@app.get("/api/preferences")
async def get_preferences():
    """鑾峰彇鐢ㄦ埛鍋忓ソ璁剧疆"""
    preferences = load_user_preferences()
    return preferences

@app.post("/api/preferences")
async def save_preferences(request: Request):
    """淇濆瓨鐢ㄦ埛鍋忓ソ璁剧疆"""
    try:
        data = await request.json()
        if not data:
            return {"success": False, "error": "鏃犳晥鐨勬暟鎹?}
        
        # 楠岃瘉鍋忓ソ鏁版嵁
        if not validate_model_preferences(data):
            return {"success": False, "error": "鍋忓ソ鏁版嵁鏍煎紡鏃犳晥"}
        
        # 鑾峰彇鍙傛暟锛堝彲閫夛級
        parameters = data.get('parameters')
        
        # 鏇存柊鍋忓ソ
        if update_model_preferences(data['model_path'], data['position'], data['scale'], parameters):
            return {"success": True, "message": "鍋忓ソ璁剧疆宸蹭繚瀛?}
        else:
            return {"success": False, "error": "淇濆瓨澶辫触"}
            
    except Exception as e:
        return {"success": False, "error": str(e)}


@app.get("/api/steam_language")
async def get_steam_language():
    """鑾峰彇 Steam 瀹㈡埛绔殑璇█璁剧疆锛岀敤浜庡墠绔?i18n 鍒濆鍖?""
    global steamworks
    
    # Steam 璇█浠ｇ爜鍒?i18n 璇█浠ｇ爜鐨勬槧灏?    # 鍙傝€? https://partner.steamgames.com/doc/store/localization/languages
    STEAM_TO_I18N_MAP = {
        'schinese': 'zh-CN',      # 绠€浣撲腑鏂?        'tchinese': 'zh-CN',      # 绻佷綋涓枃锛堟槧灏勫埌绠€浣撲腑鏂囷紝鍥犱负鐩墠鍙敮鎸?zh-CN锛?        'english': 'en',          # 鑻辨枃
        # 鍏朵粬璇█榛樿鏄犲皠鍒拌嫳鏂?    }
    
    try:
        if steamworks is None:
            return {
                "success": False,
                "error": "Steamworks 鏈垵濮嬪寲",
                "steam_language": None,
                "i18n_language": None
            }
        
        # 鑾峰彇 Steam 褰撳墠娓告垙璇█
        steam_language = steamworks.Apps.GetCurrentGameLanguage()
        # Steam API 鍙兘杩斿洖 bytes锛岄渶瑕佽В鐮佷负瀛楃涓?        if isinstance(steam_language, bytes):
            steam_language = steam_language.decode('utf-8')
        
        # 鏄犲皠鍒?i18n 璇█浠ｇ爜
        i18n_language = STEAM_TO_I18N_MAP.get(steam_language, 'en')  # 榛樿鑻辨枃
        logger.info(f"[i18n] Steam 璇█鏄犲皠: '{steam_language}' -> '{i18n_language}'")
        
        return {
            "success": True,
            "steam_language": steam_language,
            "i18n_language": i18n_language
        }
        
    except Exception as e:
        logger.error(f"鑾峰彇 Steam 璇█璁剧疆澶辫触: {e}")
        return {
            "success": False,
            "error": str(e),
            "steam_language": None,
            "i18n_language": None
        }


@app.get("/api/live2d/models")
async def get_live2d_models(simple: bool = False):
    """
    鑾峰彇Live2D妯″瀷鍒楄〃
    Args:
        simple: 濡傛灉涓篢rue锛屽彧杩斿洖妯″瀷鍚嶇О鍒楄〃锛涘鏋滀负False锛岃繑鍥炲畬鏁寸殑妯″瀷淇℃伅
    """
    try:
        # 鍏堣幏鍙栨湰鍦版ā鍨?        models = find_models()
        
        # 鍐嶈幏鍙朣team鍒涙剰宸ュ潑妯″瀷
        try:
            workshop_items_result = await get_subscribed_workshop_items()
            
            # 澶勭悊鍝嶅簲缁撴灉
            if isinstance(workshop_items_result, dict) and workshop_items_result.get('success', False):
                items = workshop_items_result.get('items', [])
                logger.info(f"鑾峰彇鍒皗len(items)}涓闃呯殑鍒涙剰宸ュ潑鐗╁搧")
                
                # 閬嶅巻鎵€鏈夌墿鍝侊紝鎻愬彇宸插畨瑁呯殑妯″瀷
                for item in items:
                    # 鐩存帴浣跨敤get_subscribed_workshop_items杩斿洖鐨刬nstalledFolder
                    installed_folder = item.get('installedFolder')
                    # 浠巔ublishedFileId瀛楁鑾峰彇鐗╁搧ID锛岃€屼笉鏄痠tem_id
                    item_id = item.get('publishedFileId')
                    
                    if installed_folder and os.path.exists(installed_folder) and os.path.isdir(installed_folder) and item_id:
                        # 妫€鏌ュ畨瑁呯洰褰曚笅鏄惁鏈?model3.json鏂囦欢
                        for filename in os.listdir(installed_folder):
                            if filename.endswith('.model3.json'):
                                model_name = os.path.splitext(os.path.splitext(filename)[0])[0]
                                
                                # 閬垮厤閲嶅娣诲姞
                                if model_name not in [m['name'] for m in models]:
                                    # 鏋勫缓姝ｇ‘鐨?workshop URL璺緞锛岀‘淇濇病鏈夊浣欑殑寮曞彿
                                    path_value = f'/workshop/{item_id}/{filename}'
                                    logger.debug(f"娣诲姞妯″瀷璺緞: {path_value!r}, item_id绫诲瀷: {type(item_id)}, filename绫诲瀷: {type(filename)}")
                                    # 绉婚櫎鍙兘鐨勯澶栧紩鍙?                                    path_value = path_value.strip('"')
                                    models.append({
                                        'name': model_name,
                                        'path': path_value,
                                        'source': 'steam_workshop',
                                        'item_id': item_id
                                    })
                            
                        # 妫€鏌ュ畨瑁呯洰褰曚笅鐨勫瓙鐩綍
                        for subdir in os.listdir(installed_folder):
                            subdir_path = os.path.join(installed_folder, subdir)
                            if os.path.isdir(subdir_path):
                                model_name = subdir
                                json_file = os.path.join(subdir_path, f'{model_name}.model3.json')
                                if os.path.exists(json_file):
                                    # 閬垮厤閲嶅娣诲姞
                                    if model_name not in [m['name'] for m in models]:
                                        # 鏋勫缓姝ｇ‘鐨?workshop URL璺緞锛岀‘淇濇病鏈夊浣欑殑寮曞彿
                                        path_value = f'/workshop/{item_id}/{model_name}/{model_name}.model3.json'
                                        logger.debug(f"娣诲姞瀛愮洰褰曟ā鍨嬭矾寰? {path_value!r}, item_id绫诲瀷: {type(item_id)}, model_name绫诲瀷: {type(model_name)}")
                                        # 绉婚櫎鍙兘鐨勯澶栧紩鍙?                                        path_value = path_value.strip('"')
                                        models.append({
                                            'name': model_name,
                                            'path': path_value,
                                            'source': 'steam_workshop',
                                            'item_id': item_id
                                        })
        except Exception as e:
            logger.error(f"鑾峰彇鍒涙剰宸ュ潑妯″瀷鏃跺嚭閿? {e}")
        
        if simple:
            # 鍙繑鍥炴ā鍨嬪悕绉板垪琛?            model_names = [model["name"] for model in models]
            return {"success": True, "models": model_names}
        else:
            # 杩斿洖瀹屾暣鐨勬ā鍨嬩俊鎭紙淇濇寔鍚戝悗鍏煎锛?            return models
    except Exception as e:
        logger.error(f"鑾峰彇Live2D妯″瀷鍒楄〃澶辫触: {e}")
        if simple:
            return {"success": False, "error": str(e)}
        else:
            return []


@app.get("/api/models")
async def get_models_legacy():
    """
    鍚戝悗鍏煎鐨凙PI绔偣锛岄噸瀹氬悜鍒版柊鐨?/api/live2d/models
    """
    return await get_live2d_models(simple=False)

@app.post("/api/preferences/set-preferred")
async def set_preferred_model(request: Request):
    """璁剧疆棣栭€夋ā鍨?""
    try:
        data = await request.json()
        if not data or 'model_path' not in data:
            return {"success": False, "error": "鏃犳晥鐨勬暟鎹?}
        
        if move_model_to_top(data['model_path']):
            return {"success": True, "message": "棣栭€夋ā鍨嬪凡鏇存柊"}
        else:
            return {"success": False, "error": "妯″瀷涓嶅瓨鍦ㄦ垨鏇存柊澶辫触"}
            
    except Exception as e:
        return {"success": False, "error": str(e)}

@app.get("/api/config/page_config")
async def get_page_config(lanlan_name: str = ""):
    """鑾峰彇椤甸潰閰嶇疆锛坙anlan_name 鍜?model_path锛?""
    try:
        # 鑾峰彇瑙掕壊鏁版嵁
        _, her_name, _, lanlan_basic_config, _, _, _, _, _, _ = _config_manager.get_character_data()
        
        # 濡傛灉鎻愪緵浜?lanlan_name 鍙傛暟锛屼娇鐢ㄥ畠锛涘惁鍒欎娇鐢ㄥ綋鍓嶈鑹?        target_name = lanlan_name if lanlan_name else her_name
        
        # 鑾峰彇 live2d 鍜?live2d_item_id 瀛楁
        live2d = lanlan_basic_config.get(target_name, {}).get('live2d', 'mao_pro')
        live2d_item_id = lanlan_basic_config.get(target_name, {}).get('live2d_item_id', '')
        
        logger.debug(f"鑾峰彇椤甸潰閰嶇疆 - 瑙掕壊: {target_name}, 妯″瀷: {live2d}, item_id: {live2d_item_id}")
        
        # 浣跨敤 get_current_live2d_model 鍑芥暟鑾峰彇姝ｇ‘鐨勬ā鍨嬩俊鎭?        # 绗竴涓弬鏁版槸瑙掕壊鍚嶇О锛岀浜屼釜鍙傛暟鏄痠tem_id
        model_response = await get_current_live2d_model(target_name, live2d_item_id)
        # 鎻愬彇JSONResponse涓殑鍐呭
        model_data = model_response.body.decode('utf-8')
        import json
        model_json = json.loads(model_data)
        model_info = model_json.get('model_info', {})
        model_path = model_info.get('path', '')
        
        return {
            "success": True,
            "lanlan_name": target_name,
            "model_path": model_path
        }
    except Exception as e:
        logger.error(f"鑾峰彇椤甸潰閰嶇疆澶辫触: {str(e)}")
        return {
            "success": False,
            "error": str(e),
            "lanlan_name": "",
            "model_path": ""
        }

@app.get("/api/config/core_api")
async def get_core_config_api():
    """鑾峰彇鏍稿績閰嶇疆锛圓PI Key锛?""
    try:
        # 灏濊瘯浠巆ore_config.json璇诲彇
        try:
            from utils.config_manager import get_config_manager
            config_manager = get_config_manager()
            core_config_path = str(config_manager.get_config_path('core_config.json'))
            with open(core_config_path, 'r', encoding='utf-8') as f:
                core_cfg = json.load(f)
                api_key = core_cfg.get('coreApiKey', '')
        except FileNotFoundError:
            # 濡傛灉鏂囦欢涓嶅瓨鍦紝杩斿洖褰撳墠閰嶇疆涓殑CORE_API_KEY
            core_config = _config_manager.get_core_config()
            api_key = core_config.get('CORE_API_KEY','')
            # 鍒涘缓绌虹殑閰嶇疆瀵硅薄鐢ㄤ簬杩斿洖榛樿鍊?            core_cfg = {}
        
        return {
            "api_key": api_key,
            "coreApi": core_cfg.get('coreApi', 'qwen'),
            "assistApi": core_cfg.get('assistApi', 'qwen'),
            "assistApiKeyQwen": core_cfg.get('assistApiKeyQwen', ''),
            "assistApiKeyOpenai": core_cfg.get('assistApiKeyOpenai', ''),
            "assistApiKeyGlm": core_cfg.get('assistApiKeyGlm', ''),
            "assistApiKeyStep": core_cfg.get('assistApiKeyStep', ''),
            "assistApiKeySilicon": core_cfg.get('assistApiKeySilicon', ''),
            "mcpToken": core_cfg.get('mcpToken', ''),  # 娣诲姞mcpToken瀛楁
            "enableCustomApi": core_cfg.get('enableCustomApi', False),  # 娣诲姞enableCustomApi瀛楁
            # 鑷畾涔堿PI鐩稿叧瀛楁
            "summaryModelProvider": core_cfg.get('summaryModelProvider', ''),
            "summaryModelUrl": core_cfg.get('summaryModelUrl', ''),
            "summaryModelId": core_cfg.get('summaryModelId', ''),
            "summaryModelApiKey": core_cfg.get('summaryModelApiKey', ''),
            "correctionModelProvider": core_cfg.get('correctionModelProvider', ''),
            "correctionModelUrl": core_cfg.get('correctionModelUrl', ''),
            "correctionModelId": core_cfg.get('correctionModelId', ''),
            "correctionModelApiKey": core_cfg.get('correctionModelApiKey', ''),
            "emotionModelProvider": core_cfg.get('emotionModelProvider', ''),
            "emotionModelUrl": core_cfg.get('emotionModelUrl', ''),
            "emotionModelId": core_cfg.get('emotionModelId', ''),
            "emotionModelApiKey": core_cfg.get('emotionModelApiKey', ''),
            "visionModelProvider": core_cfg.get('visionModelProvider', ''),
            "visionModelUrl": core_cfg.get('visionModelUrl', ''),
            "visionModelId": core_cfg.get('visionModelId', ''),
            "visionModelApiKey": core_cfg.get('visionModelApiKey', ''),
            "omniModelProvider": core_cfg.get('omniModelProvider', ''),
            "omniModelUrl": core_cfg.get('omniModelUrl', ''),
            "omniModelId": core_cfg.get('omniModelId', ''),
            "omniModelApiKey": core_cfg.get('omniModelApiKey', ''),
            "ttsModelProvider": core_cfg.get('ttsModelProvider', ''),
            "ttsModelUrl": core_cfg.get('ttsModelUrl', ''),
            "ttsModelId": core_cfg.get('ttsModelId', ''),
            "ttsModelApiKey": core_cfg.get('ttsModelApiKey', ''),
            "success": True
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }


@app.get("/api/config/api_providers")
async def get_api_providers_config():
    """鑾峰彇API鏈嶅姟鍟嗛厤缃紙渚涘墠绔娇鐢級"""
    try:
        from utils.api_config_loader import (
            get_core_api_providers_for_frontend,
            get_assist_api_providers_for_frontend,
        )
        
        # 浣跨敤缂撳瓨鍔犺浇閰嶇疆锛堟€ц兘鏇村ソ锛岄厤缃洿鏂板悗闇€瑕侀噸鍚湇鍔★級
        core_providers = get_core_api_providers_for_frontend()
        assist_providers = get_assist_api_providers_for_frontend()
        
        return {
            "success": True,
            "core_api_providers": core_providers,
            "assist_api_providers": assist_providers,
        }
    except Exception as e:
        logger.error(f"鑾峰彇API鏈嶅姟鍟嗛厤缃け璐? {e}")
        return {
            "success": False,
            "error": str(e),
            "core_api_providers": [],
            "assist_api_providers": [],
        }


@app.post("/api/config/core_api")
async def update_core_config(request: Request):
    """鏇存柊鏍稿績閰嶇疆锛圓PI Key锛?""
    try:
        data = await request.json()
        if not data:
            return {"success": False, "error": "鏃犳晥鐨勬暟鎹?}
        
        # 妫€鏌ユ槸鍚﹀惎鐢ㄤ簡鑷畾涔堿PI
        enable_custom_api = data.get('enableCustomApi', False)
        
        # 濡傛灉鍚敤浜嗚嚜瀹氫箟API锛屼笉闇€瑕佸己鍒舵鏌ユ牳蹇傾PI key
        if not enable_custom_api:
            # 妫€鏌ユ槸鍚︿负鍏嶈垂鐗堥厤缃?            is_free_version = data.get('coreApi') == 'free' or data.get('assistApi') == 'free'
            
            if 'coreApiKey' not in data:
                return {"success": False, "error": "缂哄皯coreApiKey瀛楁"}
            
            api_key = data['coreApiKey']
            if api_key is None:
                return {"success": False, "error": "API Key涓嶈兘涓簄ull"}
            
            if not isinstance(api_key, str):
                return {"success": False, "error": "API Key蹇呴』鏄瓧绗︿覆绫诲瀷"}
            
            api_key = api_key.strip()
            
            # 鍏嶈垂鐗堝厑璁镐娇鐢?'free-access' 浣滀负API key锛屼笉杩涜绌哄€兼鏌?            if not is_free_version and not api_key:
                return {"success": False, "error": "API Key涓嶈兘涓虹┖"}
        
        # 淇濆瓨鍒癱ore_config.json
        from pathlib import Path
        from utils.config_manager import get_config_manager
        config_manager = get_config_manager()
        core_config_path = str(config_manager.get_config_path('core_config.json'))
        # 纭繚閰嶇疆鐩綍瀛樺湪
        Path(core_config_path).parent.mkdir(parents=True, exist_ok=True)
        
        # 鏋勫缓閰嶇疆瀵硅薄
        core_cfg = {}
        
        # 鍙湁鍦ㄥ惎鐢ㄨ嚜瀹氫箟API鏃讹紝鎵嶅厑璁镐笉璁剧疆coreApiKey
        if enable_custom_api:
            # 鍚敤鑷畾涔堿PI鏃讹紝coreApiKey鏄彲閫夌殑
            if 'coreApiKey' in data:
                api_key = data['coreApiKey']
                if api_key is not None and isinstance(api_key, str):
                    core_cfg['coreApiKey'] = api_key.strip()
        else:
            # 鏈惎鐢ㄨ嚜瀹氫箟API鏃讹紝蹇呴』璁剧疆coreApiKey
            api_key = data.get('coreApiKey', '')
            if api_key is not None and isinstance(api_key, str):
                core_cfg['coreApiKey'] = api_key.strip()
        if 'coreApi' in data:
            core_cfg['coreApi'] = data['coreApi']
        if 'assistApi' in data:
            core_cfg['assistApi'] = data['assistApi']
        if 'assistApiKeyQwen' in data:
            core_cfg['assistApiKeyQwen'] = data['assistApiKeyQwen']
        if 'assistApiKeyOpenai' in data:
            core_cfg['assistApiKeyOpenai'] = data['assistApiKeyOpenai']
        if 'assistApiKeyGlm' in data:
            core_cfg['assistApiKeyGlm'] = data['assistApiKeyGlm']
        if 'assistApiKeyStep' in data:
            core_cfg['assistApiKeyStep'] = data['assistApiKeyStep']
        if 'assistApiKeySilicon' in data:
            core_cfg['assistApiKeySilicon'] = data['assistApiKeySilicon']
        if 'mcpToken' in data:
            core_cfg['mcpToken'] = data['mcpToken']
        if 'enableCustomApi' in data:
            core_cfg['enableCustomApi'] = data['enableCustomApi']
        
        # 娣诲姞鐢ㄦ埛鑷畾涔堿PI閰嶇疆
        if 'summaryModelProvider' in data:
            core_cfg['summaryModelProvider'] = data['summaryModelProvider']
        if 'summaryModelUrl' in data:
            core_cfg['summaryModelUrl'] = data['summaryModelUrl']
        if 'summaryModelId' in data:
            core_cfg['summaryModelId'] = data['summaryModelId']
        if 'summaryModelApiKey' in data:
            core_cfg['summaryModelApiKey'] = data['summaryModelApiKey']
        if 'correctionModelProvider' in data:
            core_cfg['correctionModelProvider'] = data['correctionModelProvider']
        if 'correctionModelUrl' in data:
            core_cfg['correctionModelUrl'] = data['correctionModelUrl']
        if 'correctionModelId' in data:
            core_cfg['correctionModelId'] = data['correctionModelId']
        if 'correctionModelApiKey' in data:
            core_cfg['correctionModelApiKey'] = data['correctionModelApiKey']
        if 'emotionModelProvider' in data:
            core_cfg['emotionModelProvider'] = data['emotionModelProvider']
        if 'emotionModelUrl' in data:
            core_cfg['emotionModelUrl'] = data['emotionModelUrl']
        if 'emotionModelId' in data:
            core_cfg['emotionModelId'] = data['emotionModelId']
        if 'emotionModelApiKey' in data:
            core_cfg['emotionModelApiKey'] = data['emotionModelApiKey']
        if 'visionModelProvider' in data:
            core_cfg['visionModelProvider'] = data['visionModelProvider']
        if 'visionModelUrl' in data:
            core_cfg['visionModelUrl'] = data['visionModelUrl']
        if 'visionModelId' in data:
            core_cfg['visionModelId'] = data['visionModelId']
        if 'visionModelApiKey' in data:
            core_cfg['visionModelApiKey'] = data['visionModelApiKey']
        if 'omniModelProvider' in data:
            core_cfg['omniModelProvider'] = data['omniModelProvider']
        if 'omniModelUrl' in data:
            core_cfg['omniModelUrl'] = data['omniModelUrl']
        if 'omniModelId' in data:
            core_cfg['omniModelId'] = data['omniModelId']
        if 'omniModelApiKey' in data:
            core_cfg['omniModelApiKey'] = data['omniModelApiKey']
        if 'ttsModelProvider' in data:
            core_cfg['ttsModelProvider'] = data['ttsModelProvider']
        if 'ttsModelUrl' in data:
            core_cfg['ttsModelUrl'] = data['ttsModelUrl']
        if 'ttsModelId' in data:
            core_cfg['ttsModelId'] = data['ttsModelId']
        if 'ttsModelApiKey' in data:
            core_cfg['ttsModelApiKey'] = data['ttsModelApiKey']
        
        with open(core_config_path, 'w', encoding='utf-8') as f:
            json.dump(core_cfg, f, indent=2, ensure_ascii=False)
        
        # API閰嶇疆鏇存柊鍚庯紝闇€瑕佸厛閫氱煡鎵€鏈夊鎴风锛屽啀鍏抽棴session锛屾渶鍚庨噸鏂板姞杞介厤缃?        logger.info("API閰嶇疆宸叉洿鏂帮紝鍑嗗閫氱煡瀹㈡埛绔苟閲嶇疆鎵€鏈塻ession...")
        
        # 1. 鍏堥€氱煡鎵€鏈夎繛鎺ョ殑瀹㈡埛绔嵆灏嗗埛鏂帮紙WebSocket杩樿繛鐫€锛?        notification_count = 0
        for lanlan_name, mgr in session_manager.items():
            if mgr.is_active and mgr.websocket:
                try:
                    await mgr.websocket.send_text(json.dumps({
                        "type": "reload_page",
                        "message": "API閰嶇疆宸叉洿鏂帮紝椤甸潰鍗冲皢鍒锋柊"
                    }))
                    notification_count += 1
                    logger.info(f"宸查€氱煡 {lanlan_name} 鐨勫墠绔埛鏂伴〉闈?)
                except Exception as e:
                    logger.warning(f"閫氱煡 {lanlan_name} 鐨刉ebSocket澶辫触: {e}")
        
        logger.info(f"宸查€氱煡 {notification_count} 涓鎴风")
        
        # 2. 绔嬪埢鍏抽棴鎵€鏈夋椿璺冪殑session锛堣繖浼氭柇寮€鎵€鏈塛ebSocket锛?        sessions_ended = []
        for lanlan_name, mgr in session_manager.items():
            if mgr.is_active:
                try:
                    await mgr.end_session(by_server=True)
                    sessions_ended.append(lanlan_name)
                    logger.info(f"{lanlan_name} 鐨剆ession宸茬粨鏉?)
                except Exception as e:
                    logger.error(f"缁撴潫 {lanlan_name} 鐨剆ession鏃跺嚭閿? {e}")
        
        # 3. 閲嶆柊鍔犺浇閰嶇疆骞堕噸寤簊ession manager
        logger.info("姝ｅ湪閲嶆柊鍔犺浇閰嶇疆...")
        try:
            await initialize_character_data()
            logger.info("閰嶇疆閲嶆柊鍔犺浇瀹屾垚锛屾柊鐨凙PI閰嶇疆宸茬敓鏁?)
        except Exception as reload_error:
            logger.error(f"閲嶆柊鍔犺浇閰嶇疆澶辫触: {reload_error}")
            return {"success": False, "error": f"閰嶇疆宸蹭繚瀛樹絾閲嶆柊鍔犺浇澶辫触: {str(reload_error)}"}
        
        logger.info(f"宸查€氱煡 {notification_count} 涓繛鎺ョ殑瀹㈡埛绔疉PI閰嶇疆宸叉洿鏂?)
        return {"success": True, "message": "API Key宸蹭繚瀛樺苟閲嶆柊鍔犺浇閰嶇疆", "sessions_ended": len(sessions_ended)}
    except Exception as e:
        return {"success": False, "error": str(e)}


@app.on_event("startup")
async def startup_event():
    global sync_process
    logger.info("Starting main server...")
    
    # ========== 鍒濆鍖栧垱鎰忓伐鍧婄洰褰?==========
    # 渚濊禆鏂瑰悜: main_server 鈫?utils 鈫?config (鍗曞悜)
    # main 灞傚彧璐熻矗璋冪敤 utils锛屼笉缁存姢浠讳綍 workshop 鐘舵€?    # 璺緞鐢?utils 灞傜鐞嗗苟鎸佷箙鍖栧埌 config 灞?    await _init_and_mount_workshop()
    
    # ========== 鍚姩鍚屾杩炴帴鍣ㄧ嚎绋?==========
    logger.info("Starting sync connector threads")
    # 鍚姩鍚屾杩炴帴鍣ㄧ嚎绋嬶紙纭繚鎵€鏈夎鑹查兘鏈夌嚎绋嬶級
    for k in list(sync_message_queue.keys()):
        if k not in sync_process or sync_process[k] is None or (hasattr(sync_process.get(k), 'is_alive') and not sync_process[k].is_alive()):
            if k in sync_process and sync_process[k] is not None:
                # 娓呯悊宸插仠姝㈢殑绾跨▼
                try:
                    sync_process[k].join(timeout=0.1)
                except:
                    pass
            try:
                sync_process[k] = Thread(
                    target=cross_server.sync_connector_process,
                    args=(sync_message_queue[k], sync_shutdown_event[k], k, f"ws://localhost:{MONITOR_SERVER_PORT}", {'bullet': False, 'monitor': True}),
                    daemon=True,
                    name=f"SyncConnector-{k}"
                )
                sync_process[k].start()
                logger.info(f"鉁?鍚屾杩炴帴鍣ㄧ嚎绋嬪凡鍚姩 ({sync_process[k].name}) for {k}")
                # 妫€鏌ョ嚎绋嬫槸鍚︽垚鍔熷惎鍔?                await asyncio.sleep(0.1)  # 绾跨▼鍚姩鏇村揩
                if not sync_process[k].is_alive():
                    logger.error(f"鉂?鍚屾杩炴帴鍣ㄧ嚎绋?{k} ({sync_process[k].name}) 鍚姩鍚庣珛鍗抽€€鍑猴紒")
                else:
                    logger.info(f"鉁?鍚屾杩炴帴鍣ㄧ嚎绋?{k} ({sync_process[k].name}) 姝ｅ湪杩愯")
            except Exception as e:
                logger.error(f"鉂?鍚姩瑙掕壊 {k} 鐨勫悓姝ヨ繛鎺ュ櫒绾跨▼澶辫触: {e}", exc_info=True)
    
    # 濡傛灉鍚敤浜嗘祻瑙堝櫒妯″紡锛屽湪鏈嶅姟鍣ㄥ惎鍔ㄥ畬鎴愬悗鎵撳紑娴忚鍣?    current_config = get_start_config()
    print(f"鍚姩閰嶇疆: {current_config}")
    if current_config['browser_mode_enabled']:
        import threading
        
        def launch_browser_delayed():
            # 绛夊緟涓€灏忔鏃堕棿纭繚鏈嶅姟鍣ㄥ畬鍏ㄥ惎鍔?            import time
            time.sleep(1)
            # 浠?app.state 鑾峰彇閰嶇疆
            config = get_start_config()
            url = f"http://127.0.0.1:{MAIN_SERVER_PORT}/{config['browser_page']}"
            try:
                webbrowser.open(url)
                logger.info(f"鏈嶅姟鍣ㄥ惎鍔ㄥ畬鎴愶紝宸叉墦寮€娴忚鍣ㄨ闂? {url}")
            except Exception as e:
                logger.error(f"鎵撳紑娴忚鍣ㄥけ璐? {e}")
        
        # 鍦ㄧ嫭绔嬬嚎绋嬩腑鍚姩娴忚鍣?        t = threading.Thread(target=launch_browser_delayed, daemon=True)
        t.start()


@app.on_event("shutdown")
async def shutdown_event():
    """搴旂敤鍏抽棴鏃舵墽琛?""
    logger.info("Shutting down sync connector threads")
    # 鍏抽棴鍚屾鏈嶅姟鍣ㄨ繛鎺ワ紙绾跨▼鍙兘鍗忎綔寮忕粓姝級
    for k in sync_process:
        if sync_process[k] is not None:
            sync_shutdown_event[k].set()
            sync_process[k].join(timeout=3)  # 绛夊緟绾跨▼姝ｅ父缁撴潫
            if sync_process[k].is_alive():
                logger.warning(f"鈿狅笍 鍚屾杩炴帴鍣ㄧ嚎绋?{k} 鏈兘鍦ㄨ秴鏃跺唴鍋滄锛屽皢浣滀负daemon绾跨▼闅忎富杩涚▼閫€鍑?)
    logger.info("鍚屾杩炴帴鍣ㄧ嚎绋嬪凡鍋滄")
    
    # 鍚憁emory_server鍙戦€佸叧闂俊鍙?    try:
        from config import MEMORY_SERVER_PORT
        shutdown_url = f"http://localhost:{MEMORY_SERVER_PORT}/shutdown"
        async with httpx.AsyncClient(timeout=2) as client:
            response = await client.post(shutdown_url)
            if response.status_code == 200:
                logger.info("宸插悜memory_server鍙戦€佸叧闂俊鍙?)
            else:
                logger.warning(f"鍚憁emory_server鍙戦€佸叧闂俊鍙峰け璐ワ紝鐘舵€佺爜: {response.status_code}")
    except Exception as e:
        logger.warning(f"鍚憁emory_server鍙戦€佸叧闂俊鍙锋椂鍑洪敊: {e}")


@app.websocket("/ws/{lanlan_name}")
async def websocket_endpoint(websocket: WebSocket, lanlan_name: str):
    await websocket.accept()
    
    # 妫€鏌ヨ鑹叉槸鍚﹀瓨鍦紝濡傛灉涓嶅瓨鍦ㄥ垯閫氱煡鍓嶇骞跺叧闂繛鎺?    if lanlan_name not in session_manager:
        logger.warning(f"鉂?瑙掕壊 {lanlan_name} 涓嶅瓨鍦紝褰撳墠鍙敤瑙掕壊: {list(session_manager.keys())}")
        # 鑾峰彇褰撳墠姝ｇ‘鐨勮鑹插悕
        current_catgirl = None
        if session_manager:
            current_catgirl = list(session_manager.keys())[0]
        # 閫氱煡鍓嶇鍒囨崲鍒版纭殑瑙掕壊
        if current_catgirl:
            try:
                await websocket.send_text(json.dumps({
                    "type": "catgirl_switched",
                    "new_catgirl": current_catgirl,
                    "old_catgirl": lanlan_name
                }))
                logger.info(f"宸查€氱煡鍓嶇鍒囨崲鍒版纭殑瑙掕壊: {current_catgirl}")
                # 绛夊緟涓€涓嬭瀹㈡埛绔湁鏃堕棿澶勭悊娑堟伅锛岄伩鍏?onclose 鍦?onmessage 涔嬪墠瑙﹀彂
                await asyncio.sleep(0.5)
            except Exception as e:
                logger.warning(f"閫氱煡鍓嶇澶辫触: {e}")
        await websocket.close()
        return
    
    this_session_id = uuid.uuid4()
    async with lock:
        global session_id
        session_id[lanlan_name] = this_session_id
    logger.info(f"猸恮ebsocketWebSocket accepted: {websocket.client}, new session id: {session_id[lanlan_name]}, lanlan_name: {lanlan_name}")
    
    # 绔嬪嵆璁剧疆websocket鍒皊ession manager锛屼互鏀寔涓诲姩鎼瘽
    # 娉ㄦ剰锛氳繖閲岃缃悗锛屽嵆浣縞leanup()琚皟鐢紝websocket涔熶細鍦╯tart_session鏃堕噸鏂拌缃?    session_manager[lanlan_name].websocket = websocket
    logger.info(f"鉁?宸茶缃?{lanlan_name} 鐨刉ebSocket杩炴帴")

    try:
        while True:
            data = await websocket.receive_text()
            # 瀹夊叏妫€鏌ワ細濡傛灉瑙掕壊宸茶閲嶅懡鍚嶆垨鍒犻櫎锛宭anlan_name 鍙兘涓嶅啀瀛樺湪
            if lanlan_name not in session_id or lanlan_name not in session_manager:
                logger.info(f"瑙掕壊 {lanlan_name} 宸茶閲嶅懡鍚嶆垨鍒犻櫎锛屽叧闂棫杩炴帴")
                await websocket.close()
                break
            if session_id[lanlan_name] != this_session_id:
                await session_manager[lanlan_name].send_status(f"鍒囨崲鑷冲彟涓€涓粓绔?..")
                await websocket.close()
                break
            message = json.loads(data)
            action = message.get("action")
            # logger.debug(f"WebSocket received action: {action}") # Optional debug log

            if action == "start_session":
                session_manager[lanlan_name].active_session_is_idle = False
                input_type = message.get("input_type", "audio")
                if input_type in ['audio', 'screen', 'camera', 'text']:
                    # 浼犻€抜nput_mode鍙傛暟锛屽憡鐭ession manager浣跨敤浣曠妯″紡
                    mode = 'text' if input_type == 'text' else 'audio'
                    asyncio.create_task(session_manager[lanlan_name].start_session(websocket, message.get("new_session", False), mode))
                else:
                    await session_manager[lanlan_name].send_status(f"Invalid input type: {input_type}")

            elif action == "stream_data":
                asyncio.create_task(session_manager[lanlan_name].stream_data(message))

            elif action == "end_session":
                session_manager[lanlan_name].active_session_is_idle = False
                asyncio.create_task(session_manager[lanlan_name].end_session())

            elif action == "pause_session":
                session_manager[lanlan_name].active_session_is_idle = True
                asyncio.create_task(session_manager[lanlan_name].end_session())

            elif action == "ping":
                # 蹇冭烦淇濇椿娑堟伅锛屽洖澶峱ong
                await websocket.send_text(json.dumps({"type": "pong"}))
                # logger.debug(f"鏀跺埌蹇冭烦ping锛屽凡鍥炲pong")

            else:
                logger.warning(f"Unknown action received: {action}")
                await session_manager[lanlan_name].send_status(f"Unknown action: {action}")

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected: {websocket.client}")
    except Exception as e:
        error_message = f"WebSocket handler error: {e}"
        logger.error(f"馃挜 {error_message}")
        try:
            if lanlan_name in session_manager:
                await session_manager[lanlan_name].send_status(f"Server error: {e}")
        except:
            pass
    finally:
        logger.info(f"Cleaning up WebSocket resources: {websocket.client}")
        # 瀹夊叏妫€鏌ワ細濡傛灉瑙掕壊宸茶閲嶅懡鍚嶆垨鍒犻櫎锛宭anlan_name 鍙兘涓嶅啀瀛樺湪
        if lanlan_name in session_manager:
            await session_manager[lanlan_name].cleanup()
            # 娉ㄦ剰锛歝leanup() 浼氭竻绌?websocket锛屼絾鍙湪杩炴帴鐪熸鏂紑鏃惰皟鐢?            # 濡傛灉杩炴帴杩樺湪锛寃ebsocket搴旇淇濇寔璁剧疆
            if session_manager[lanlan_name].websocket == websocket:
                session_manager[lanlan_name].websocket = None

@app.post('/api/notify_task_result')
async def notify_task_result(request: Request):
    """渚涘伐鍏?浠诲姟鏈嶅姟鍥炶皟锛氬湪涓嬩竴娆℃甯稿洖澶嶄箣鍚庯紝鎻掑叆涓€鏉′换鍔″畬鎴愭彁绀恒€?""
    try:
        data = await request.json()
        # 濡傛灉鏈樉寮忔彁渚涳紝鍒欎娇鐢ㄥ綋鍓嶉粯璁よ鑹?        _, her_name_current, _, _, _, _, _, _, _, _ = _config_manager.get_character_data()
        lanlan = data.get('lanlan_name') or her_name_current
        text = (data.get('text') or '').strip()
        if not text:
            return JSONResponse({"success": False, "error": "text required"}, status_code=400)
        mgr = session_manager.get(lanlan)
        if not mgr:
            return JSONResponse({"success": False, "error": "lanlan not found"}, status_code=404)
        # 灏嗘彁绀哄姞鍏ュ緟鎻掑叆闃熷垪
        mgr.pending_extra_replies.append(text)
        return {"success": True}
    except Exception as e:
        return JSONResponse({"success": False, "error": str(e)}, status_code=500)

@app.post('/api/proactive_chat')
async def proactive_chat(request: Request):
    """涓诲姩鎼瘽锛氭牴鎹鐜囬€夋嫨浣跨敤鍥剧墖鎴栫儹闂ㄥ唴瀹癸紝璁〢I鍐冲畾鏄惁涓诲姩鍙戣捣瀵硅瘽"""
    try:
        from utils.web_scraper import fetch_trending_content, format_trending_content
        
        # 鑾峰彇褰撳墠瑙掕壊鏁版嵁
        master_name_current, her_name_current, _, _, _, _, _, _, _, _ = _config_manager.get_character_data()
        
        data = await request.json()
        lanlan_name = data.get('lanlan_name') or her_name_current
        
        # 鑾峰彇session manager
        mgr = session_manager.get(lanlan_name)
        if not mgr:
            return JSONResponse({"success": False, "error": f"瑙掕壊 {lanlan_name} 涓嶅瓨鍦?}, status_code=404)
        
        # 妫€鏌ユ槸鍚︽鍦ㄥ搷搴斾腑锛堝鏋滄鍦ㄨ璇濓紝涓嶆墦鏂級
        if mgr.is_active and hasattr(mgr.session, '_is_responding') and mgr.session._is_responding:
            return JSONResponse({
                "success": False, 
                "error": "AI姝ｅ湪鍝嶅簲涓紝鏃犳硶涓诲姩鎼瘽",
                "message": "璇风瓑寰呭綋鍓嶅搷搴斿畬鎴?
            }, status_code=409)
        
        logger.info(f"[{lanlan_name}] 寮€濮嬩富鍔ㄦ惌璇濇祦绋?..")
        
        # 1. 妫€鏌ュ墠绔槸鍚﹀彂閫佷簡鎴浘鏁版嵁
        screenshot_data = data.get('screenshot_data')
        # 闃插尽鎬ф鏌ワ細纭繚screenshot_data鏄瓧绗︿覆绫诲瀷
        has_screenshot = bool(screenshot_data) and isinstance(screenshot_data, str)
        
        # 鍓嶇宸茬粡鏍规嵁涓夌妯″紡鍐冲畾鏄惁浣跨敤鎴浘
        use_screenshot = has_screenshot
        
        if use_screenshot:
            logger.info(f"[{lanlan_name}] 鍓嶇閫夋嫨浣跨敤鎴浘杩涜涓诲姩鎼瘽")
            
            # 澶勭悊鍓嶇鍙戦€佺殑鎴浘鏁版嵁
            try:
                # 灏咲ataURL杞崲涓篵ase64鏁版嵁骞跺垎鏋?                screenshot_content = await analyze_screenshot_from_data_url(screenshot_data)
                if not screenshot_content:
                    logger.warning(f"[{lanlan_name}] 鎴浘鍒嗘瀽澶辫触锛岃烦杩囨湰娆℃惌璇?)
                    return JSONResponse({
                        "success": False,
                        "error": "鎴浘鍒嗘瀽澶辫触锛岃妫€鏌ユ埅鍥炬牸寮忔槸鍚︽纭?,
                        "action": "pass"
                    }, status_code=500)
                else:
                    logger.info(f"[{lanlan_name}] 鎴愬姛鍒嗘瀽鎴浘鍐呭")
            except (ValueError, TypeError) as e:
                logger.exception(f"[{lanlan_name}] 澶勭悊鎴浘鏁版嵁澶辫触")
                return JSONResponse({
                    "success": False,
                    "error": f"鎴浘澶勭悊澶辫触: {str(e)}",
                    "action": "pass"
                }, status_code=500)
        else:
            logger.info(f"[{lanlan_name}] 鍓嶇閫夋嫨浣跨敤鐑棬鍐呭杩涜涓诲姩鎼瘽")
        
        if not use_screenshot:
            # 鐑棬鍐呭涓诲姩瀵硅瘽
            try:
                trending_content = await fetch_trending_content(bilibili_limit=10, weibo_limit=10)
                
                if not trending_content['success']:
                    return JSONResponse({
                        "success": False,
                        "error": "鏃犳硶鑾峰彇鐑棬鍐呭",
                        "detail": trending_content.get('error', '鏈煡閿欒')
                    }, status_code=500)
                
                formatted_content = format_trending_content(trending_content)
                logger.info(f"[{lanlan_name}] 鎴愬姛鑾峰彇鐑棬鍐呭")
                
            except Exception:
                logger.exception(f"[{lanlan_name}] 鑾峰彇鐑棬鍐呭澶辫触")
                return JSONResponse({
                    "success": False,
                    "error": "鐖彇鐑棬鍐呭鏃跺嚭閿?,
                    "detail": "璇锋鏌ョ綉缁滆繛鎺ユ垨鐑棬鍐呭鏈嶅姟鐘舵€?
                }, status_code=500)
        
        # 2. 鑾峰彇new_dialogue prompt
        try:
            async with httpx.AsyncClient() as client:
                resp = await client.get(f"http://localhost:{MEMORY_SERVER_PORT}/new_dialog/{lanlan_name}", timeout=5.0)
                memory_context = resp.text
        except Exception as e:
            logger.warning(f"[{lanlan_name}] 鑾峰彇璁板繂涓婁笅鏂囧け璐ワ紝浣跨敤绌轰笂涓嬫枃: {e}")
            memory_context = ""
        
        # 3. 鏋勯€犳彁绀鸿瘝锛堟牴鎹€夋嫨浣跨敤涓嶅悓鐨勬ā鏉匡級
        if use_screenshot:
            # 鎴浘妯℃澘锛氬熀浜庡睆骞曞唴瀹硅AI鍐冲畾鏄惁涓诲姩鍙戣捣瀵硅瘽
            system_prompt = proactive_chat_prompt_screenshot.format(
                lanlan_name=lanlan_name,
                master_name=master_name_current,
                screenshot_content=screenshot_content,
                memory_context=memory_context
            )
            logger.info(f"[{lanlan_name}] 浣跨敤鍥剧墖涓诲姩瀵硅瘽鎻愮ず璇?)
        else:
            # 鐑棬鍐呭妯℃澘锛氬熀浜庣綉缁滅儹鐐硅AI鍐冲畾鏄惁涓诲姩鍙戣捣瀵硅瘽
            system_prompt = proactive_chat_prompt.format(
                lanlan_name=lanlan_name,
                master_name=master_name_current,
                trending_content=formatted_content,
                memory_context=memory_context
            )
            logger.info(f"[{lanlan_name}] 浣跨敤鐑棬鍐呭涓诲姩瀵硅瘽鎻愮ず璇?)

        # 4. 鐩存帴浣跨敤langchain ChatOpenAI鑾峰彇AI鍥炲锛堜笉鍒涘缓涓存椂session锛?        try:
            # 浣跨敤 get_model_api_config 鑾峰彇 API 閰嶇疆
            correction_config = _config_manager.get_model_api_config('correction')
            
            # 瀹夊叏鑾峰彇閰嶇疆椤癸紝浣跨敤 .get() 閬垮厤 KeyError
            correction_model = correction_config.get('model')
            correction_base_url = correction_config.get('base_url')
            correction_api_key = correction_config.get('api_key')
            
            # 楠岃瘉蹇呴渶鐨勯厤缃」
            if not correction_model or not correction_api_key:
                logger.error("绾犻敊妯″瀷閰嶇疆缂哄け: model鎴朼pi_key鏈缃?)
                return JSONResponse({
                    "success": False,
                    "error": "绾犻敊妯″瀷閰嶇疆缂哄け",
                    "detail": "璇峰湪璁剧疆涓厤缃籂閿欐ā鍨嬬殑model鍜宎pi_key"
                }, status_code=500)
            
            llm = ChatOpenAI(
                model=correction_model,
                base_url=correction_base_url,
                api_key=correction_api_key,
                temperature=1.1,
                streaming=False  # 涓嶉渶瑕佹祦寮忥紝鐩存帴鑾峰彇瀹屾暣鍝嶅簲
            )
            
            # 鍙戦€佽姹傝幏鍙朅I鍐崇瓥 - Retry绛栫暐锛氶噸璇?娆★紝闂撮殧1绉掋€?绉?            # 濡傞渶璋冭瘯锛屽彲鍦ㄦ澶勪娇鐢?logger.debug 骞堕€傚綋鎴柇 system_prompt
            # logger.debug(f"[{lanlan_name}] proactive system_prompt: {system_prompt[:200]}...")
            max_retries = 3
            retry_delays = [1, 2]
            response_text = ""
            
            for attempt in range(max_retries):
                try:
                    response = await asyncio.wait_for(
                        llm.ainvoke([SystemMessage(content=system_prompt)]),
                        timeout=10.0
                    )
                    response_text = response.content.strip()
                    break  # 鎴愬姛鍒欓€€鍑洪噸璇曞惊鐜?                except (APIConnectionError, InternalServerError, RateLimitError) as e:
                    logger.info(f"[INFO] 鎹曡幏鍒?{type(e).__name__} 閿欒")
                    if attempt < max_retries - 1:
                        wait_time = retry_delays[attempt]
                        logger.warning(f"[{lanlan_name}] 涓诲姩鎼瘽LLM璋冪敤澶辫触 (灏濊瘯 {attempt + 1}/{max_retries})锛寋wait_time}绉掑悗閲嶈瘯: {e}")
                        # 鍚戝墠绔彂閫佺姸鎬佹彁绀?                        if mgr.websocket:
                            try:
                                await mgr.send_status(f"姝ｅ湪閲嶈瘯涓?..锛堢{attempt + 1}娆★級")
                            except:
                                pass
                        await asyncio.sleep(wait_time)
                    else:
                        logger.error(f"[{lanlan_name}] 涓诲姩鎼瘽LLM璋冪敤澶辫触锛屽凡杈惧埌鏈€澶ч噸璇曟鏁? {e}")
                        return JSONResponse({
                            "success": False,
                            "error": f"AI璋冪敤澶辫触锛屽凡閲嶈瘯{max_retries}娆?,
                            "detail": str(e)
                        }, status_code=503)
            
            logger.info(f"[{lanlan_name}] AI鍐崇瓥缁撴灉: {response_text[:100]}...")
            
            # 5. 鍒ゆ柇AI鏄惁閫夋嫨鎼瘽
            if "[PASS]" in response_text or not response_text:
                return JSONResponse({
                    "success": True,
                    "action": "pass",
                    "message": "AI閫夋嫨鏆傛椂涓嶆惌璇?
                })
            
            # 6. AI閫夋嫨鎼瘽锛岄渶瑕侀€氳繃session manager澶勭悊
            # 棣栧厛妫€鏌ユ槸鍚︽湁鐪熷疄鐨剋ebsocket杩炴帴
            if not mgr.websocket:
                return JSONResponse({
                    "success": False,
                    "error": "娌℃湁娲昏穬鐨刉ebSocket杩炴帴锛屾棤娉曚富鍔ㄦ惌璇濄€傝鍏堟墦寮€鍓嶇椤甸潰銆?
                }, status_code=400)
            
            # 妫€鏌ebsocket鏄惁杩炴帴
            try:
                from starlette.websockets import WebSocketState
                if hasattr(mgr.websocket, 'client_state'):
                    if mgr.websocket.client_state != WebSocketState.CONNECTED:
                        return JSONResponse({
                            "success": False,
                            "error": "WebSocket鏈繛鎺ワ紝鏃犳硶涓诲姩鎼瘽"
                        }, status_code=400)
            except Exception as e:
                logger.warning(f"妫€鏌ebSocket鐘舵€佸け璐? {e}")
            
            # 妫€鏌ユ槸鍚︽湁鐜版湁鐨剆ession锛屽鏋滄病鏈夊垯鍒涘缓涓€涓枃鏈瑂ession
            session_created = False
            if not mgr.session or not hasattr(mgr.session, '_conversation_history'):
                logger.info(f"[{lanlan_name}] 娌℃湁娲昏穬session锛屽垱寤烘枃鏈瑂ession鐢ㄤ簬涓诲姩鎼瘽")
                # 浣跨敤鐜版湁鐨勭湡瀹瀢ebsocket鍚姩session
                await mgr.start_session(mgr.websocket, new=True, input_mode='text')
                session_created = True
                logger.info(f"[{lanlan_name}] 鏂囨湰session宸插垱寤?)
            
            # 濡傛灉鏄柊鍒涘缓鐨剆ession锛岀瓑寰匱TS鍑嗗濂?            if session_created and mgr.use_tts:
                logger.info(f"[{lanlan_name}] 绛夊緟TTS鍑嗗...")
                max_wait = 5  # 鏈€澶氱瓑寰?绉?                wait_step = 0.1
                waited = 0
                while waited < max_wait:
                    async with mgr.tts_cache_lock:
                        if mgr.tts_ready:
                            logger.info(f"[{lanlan_name}] TTS宸插噯澶囧ソ")
                            break
                    await asyncio.sleep(wait_step)
                    waited += wait_step
                
                if waited >= max_wait:
                    logger.warning(f"[{lanlan_name}] TTS鍑嗗瓒呮椂锛岀户缁彂閫侊紙鍙兘娌℃湁璇煶锛?)
            
            # 鐜板湪鍙互灏咥I鐨勮瘽娣诲姞鍒板璇濆巻鍙蹭腑
            from langchain_core.messages import AIMessage
            mgr.session._conversation_history.append(AIMessage(content=response_text))
            logger.info(f"[{lanlan_name}] 宸插皢涓诲姩鎼瘽娣诲姞鍒板璇濆巻鍙?)
            
            # 鐢熸垚鏂扮殑speech_id锛堢敤浜嶵TS锛?            from uuid import uuid4
            async with mgr.lock:
                mgr.current_speech_id = str(uuid4())
            
            # 閫氳繃handle_text_data澶勭悊杩欐璇濓紙瑙﹀彂TTS鍜屽墠绔樉绀猴級
            # 鍒哻hunk鍙戦€佷互妯℃嫙娴佸紡鏁堟灉
            chunks = [response_text[i:i+10] for i in range(0, len(response_text), 10)]
            for i, chunk in enumerate(chunks):
                await mgr.handle_text_data(chunk, is_first_chunk=(i == 0))
                await asyncio.sleep(0.05)  # 灏忓欢杩熸ā鎷熸祦寮?            
            # 璋冪敤response瀹屾垚鍥炶皟
            if hasattr(mgr, 'handle_response_complete'):
                await mgr.handle_response_complete()
            
            return JSONResponse({
                "success": True,
                "action": "chat",
                "message": "涓诲姩鎼瘽宸插彂閫?,
                "lanlan_name": lanlan_name
            })
            
        except asyncio.TimeoutError:
            logger.error(f"[{lanlan_name}] AI鍥炲瓒呮椂")
            return JSONResponse({
                "success": False,
                "error": "AI澶勭悊瓒呮椂"
            }, status_code=504)
        except Exception as e:
            logger.error(f"[{lanlan_name}] AI澶勭悊澶辫触: {e}")
            return JSONResponse({
                "success": False,
                "error": "AI澶勭悊澶辫触",
                "detail": str(e)
            }, status_code=500)
        
    except Exception as e:
        logger.error(f"涓诲姩鎼瘽鎺ュ彛寮傚父: {e}")
        return JSONResponse({
            "success": False,
            "error": "鏈嶅姟鍣ㄥ唴閮ㄩ敊璇?,
            "detail": str(e)
        }, status_code=500)

@app.get("/l2d", response_class=HTMLResponse)
async def get_l2d_manager(request: Request):
    """娓叉煋Live2D妯″瀷绠＄悊鍣ㄩ〉闈?""
    return templates.TemplateResponse("templates/l2d_manager.html", {
        "request": request
    })

@app.get("/live2d_parameter_editor", response_class=HTMLResponse)
async def live2d_parameter_editor(request: Request):
    """Live2D鍙傛暟缂栬緫鍣ㄩ〉闈?""
    return templates.TemplateResponse("templates/live2d_parameter_editor.html", {
        "request": request
    })

@app.get('/api/characters/current_live2d_model')
async def get_current_live2d_model(catgirl_name: str = "", item_id: str = ""):
    """鑾峰彇鎸囧畾瑙掕壊鎴栧綋鍓嶈鑹茬殑Live2D妯″瀷淇℃伅
    
    Args:
        catgirl_name: 瑙掕壊鍚嶇О
        item_id: 鍙€夌殑鐗╁搧ID锛岀敤浜庣洿鎺ユ寚瀹氭ā鍨?    """
    try:
        characters = _config_manager.load_characters()
        
        # 濡傛灉娌℃湁鎸囧畾瑙掕壊鍚嶇О锛屼娇鐢ㄥ綋鍓嶇尗濞?        if not catgirl_name:
            catgirl_name = characters.get('褰撳墠鐚', '')
        
        # 鏌ユ壘鎸囧畾瑙掕壊鐨凩ive2D妯″瀷
        live2d_model_name = None
        model_info = None
        
        # 棣栧厛灏濊瘯閫氳繃item_id鏌ユ壘妯″瀷
        if item_id:
            try:
                logger.debug(f"灏濊瘯閫氳繃item_id {item_id} 鏌ユ壘妯″瀷")
                # 鑾峰彇鎵€鏈夋ā鍨?                all_models = find_models()
                # 鏌ユ壘鍖归厤item_id鐨勬ā鍨?                matching_model = next((m for m in all_models if m.get('item_id') == item_id), None)
                
                if matching_model:
                    logger.debug(f"閫氳繃item_id鎵惧埌妯″瀷: {matching_model['name']}")
                    # 澶嶅埗妯″瀷淇℃伅
                    model_info = matching_model.copy()
                    live2d_model_name = model_info['name']
            except Exception as e:
                logger.warning(f"閫氳繃item_id鏌ユ壘妯″瀷澶辫触: {e}")
        
        # 濡傛灉娌℃湁閫氳繃item_id鎵惧埌妯″瀷锛屽啀閫氳繃瑙掕壊鍚嶇О鏌ユ壘
        if not model_info and catgirl_name:
            # 鍦ㄧ尗濞樺垪琛ㄤ腑鏌ユ壘
            if '鐚' in characters and catgirl_name in characters['鐚']:
                catgirl_data = characters['鐚'][catgirl_name]
                live2d_model_name = catgirl_data.get('live2d')
                
                # 妫€鏌ユ槸鍚︽湁淇濆瓨鐨刬tem_id
                saved_item_id = catgirl_data.get('live2d_item_id')
                if saved_item_id:
                    logger.debug(f"鍙戠幇瑙掕壊 {catgirl_name} 淇濆瓨鐨刬tem_id: {saved_item_id}")
                    try:
                        # 灏濊瘯閫氳繃淇濆瓨鐨刬tem_id鏌ユ壘妯″瀷
                        all_models = find_models()
                        matching_model = next((m for m in all_models if m.get('item_id') == saved_item_id), None)
                        if matching_model:
                            logger.debug(f"閫氳繃淇濆瓨鐨刬tem_id鎵惧埌妯″瀷: {matching_model['name']}")
                            model_info = matching_model.copy()
                            live2d_model_name = model_info['name']
                    except Exception as e:
                        logger.warning(f"閫氳繃淇濆瓨鐨刬tem_id鏌ユ壘妯″瀷澶辫触: {e}")
        
        # 濡傛灉鎵惧埌浜嗘ā鍨嬪悕绉帮紝鑾峰彇妯″瀷淇℃伅
        if live2d_model_name:
            try:
                # 鍏堜粠瀹屾暣鐨勬ā鍨嬪垪琛ㄤ腑鏌ユ壘锛岃繖鏍峰彲浠ヨ幏鍙栧埌item_id绛夊畬鏁翠俊鎭?                all_models = find_models()
                # 鏌ユ壘鍖归厤鐨勬ā鍨?                matching_model = next((m for m in all_models if m['name'] == live2d_model_name), None)
                
                if matching_model:
                    # 浣跨敤瀹屾暣鐨勬ā鍨嬩俊鎭紝鍖呭惈item_id
                    model_info = matching_model.copy()
                    logger.debug(f"浠庡畬鏁存ā鍨嬪垪琛ㄨ幏鍙栨ā鍨嬩俊鎭? {model_info}")
                else:
                    # 濡傛灉鍦ㄥ畬鏁村垪琛ㄤ腑鎵句笉鍒帮紝鍥為€€鍒板師鏉ョ殑閫昏緫
                    model_dir, url_prefix = find_model_directory(live2d_model_name)
                    if os.path.exists(model_dir):
                        # 鏌ユ壘妯″瀷閰嶇疆鏂囦欢
                        model_files = [f for f in os.listdir(model_dir) if f.endswith('.model3.json')]
                        if model_files:
                            model_file = model_files[0]
                            
                            # 浣跨敤淇濆瓨鐨刬tem_id鏋勫缓model_path
                            # 浠庝箣鍓嶇殑閫昏緫涓幏鍙杝aved_item_id
                            saved_item_id = catgirl_data.get('live2d_item_id', '') if 'catgirl_data' in locals() else ''
                            
                            # 濡傛灉鏈変繚瀛樼殑item_id锛屼娇鐢ㄥ畠鏋勫缓璺緞
                            if saved_item_id:
                                model_path = f'{url_prefix}/{saved_item_id}/{model_file}'
                                logger.debug(f"浣跨敤淇濆瓨鐨刬tem_id鏋勫缓妯″瀷璺緞: {model_path}")
                            else:
                                # 鍘熷璺緞鏋勫缓閫昏緫
                                model_path = f'{url_prefix}/{live2d_model_name}/{model_file}'
                                logger.debug(f"浣跨敤妯″瀷鍚嶇О鏋勫缓璺緞: {model_path}")
                            
                            model_info = {
                                'name': live2d_model_name,
                                'item_id': saved_item_id,
                                'path': model_path
                            }
            except Exception as e:
                logger.warning(f"鑾峰彇妯″瀷淇℃伅澶辫触: {e}")
        
        # 鍥為€€鏈哄埗锛氬鏋滄病鏈夋壘鍒版ā鍨嬶紝浣跨敤榛樿鐨刴ao_pro
        if not live2d_model_name or not model_info:
            logger.info(f"鐚 {catgirl_name} 鏈缃甃ive2D妯″瀷锛屽洖閫€鍒伴粯璁ゆā鍨?mao_pro")
            live2d_model_name = 'mao_pro'
            try:
                # 鍏堜粠瀹屾暣鐨勬ā鍨嬪垪琛ㄤ腑鏌ユ壘mao_pro
                all_models = find_models()
                matching_model = next((m for m in all_models if m['name'] == 'mao_pro'), None)
                
                if matching_model:
                    model_info = matching_model.copy()
                    model_info['is_fallback'] = True
                else:
                    # 濡傛灉鎵句笉鍒帮紝鍥為€€鍒板師鏉ョ殑閫昏緫
                    model_dir, url_prefix = find_model_directory('mao_pro')
                    if os.path.exists(model_dir):
                        model_files = [f for f in os.listdir(model_dir) if f.endswith('.model3.json')]
                        if model_files:
                            model_file = model_files[0]
                            model_path = f'{url_prefix}/mao_pro/{model_file}'
                            model_info = {
                                'name': 'mao_pro',
                                'path': model_path,
                                'is_fallback': True  # 鏍囪杩欐槸鍥為€€妯″瀷
                            }
            except Exception as e:
                logger.error(f"鑾峰彇榛樿妯″瀷mao_pro澶辫触: {e}")
        
        return JSONResponse(content={
            'success': True,
            'catgirl_name': catgirl_name,
            'model_name': live2d_model_name,
            'model_info': model_info
        })
        
    except Exception as e:
        logger.error(f"鑾峰彇瑙掕壊Live2D妯″瀷澶辫触: {e}")
        return JSONResponse(content={
            'success': False,
            'error': str(e)
        })

@app.get('/chara_manager', response_class=HTMLResponse)
async def chara_manager(request: Request):
    """娓叉煋涓绘帶鍒堕〉闈?""
    return templates.TemplateResponse('templates/chara_manager.html', {"request": request})

@app.get('/voice_clone', response_class=HTMLResponse)
async def voice_clone_page(request: Request):
    return templates.TemplateResponse("templates/voice_clone.html", {"request": request})

@app.get("/api_key", response_class=HTMLResponse)
async def api_key_settings(request: Request):
    """API Key 璁剧疆椤甸潰"""
    return templates.TemplateResponse("templates/api_key_settings.html", {
        "request": request
    })

@app.get('/api/characters')
async def get_characters():
    return JSONResponse(content=_config_manager.load_characters())

@app.get('/steam_workshop_manager', response_class=HTMLResponse)
async def steam_workshop_manager_page(request: Request, lanlan_name: str = ""):
    return templates.TemplateResponse("templates/steam_workshop_manager.html", {"request": request, "lanlan_name": lanlan_name})

@app.get('/api/steam/workshop/subscribed-items')
async def get_subscribed_workshop_items():
    """
    鑾峰彇鐢ㄦ埛璁㈤槄鐨凷team鍒涙剰宸ュ潑鐗╁搧鍒楄〃
    杩斿洖鍖呭惈鐗╁搧ID銆佸熀鏈俊鎭拰鐘舵€佺殑JSON鏁版嵁
    """
    global steamworks
    
    # 妫€鏌teamworks鏄惁鍒濆鍖栨垚鍔?    if steamworks is None:
        return JSONResponse({
            "success": False,
            "error": "Steamworks鏈垵濮嬪寲",
            "message": "璇风‘淇漇team瀹㈡埛绔凡杩愯涓斿凡鐧诲綍"
        }, status_code=503)
    
    try:
        # 鑾峰彇璁㈤槄鐗╁搧鏁伴噺
        num_subscribed_items = steamworks.Workshop.GetNumSubscribedItems()
        logger.info(f"鑾峰彇鍒?{num_subscribed_items} 涓闃呯殑鍒涙剰宸ュ潑鐗╁搧")
        
        # 濡傛灉娌℃湁璁㈤槄鐗╁搧锛岃繑鍥炵┖鍒楄〃
        if num_subscribed_items == 0:
            return {
                "success": True,
                "items": [],
                "total": 0
            }
        
        # 鑾峰彇璁㈤槄鐗╁搧ID鍒楄〃
        subscribed_items = steamworks.Workshop.GetSubscribedItems()
        logger.info(f'鑾峰彇鍒?{len(subscribed_items)} 涓闃呯殑鍒涙剰宸ュ潑鐗╁搧')
        
        # 瀛樺偍澶勭悊鍚庣殑鐗╁搧淇℃伅
        items_info = []
        
        # 涓烘瘡涓墿鍝佽幏鍙栧熀鏈俊鎭拰鐘舵€?        for item_id in subscribed_items:
            try:
                # 纭繚item_id鏄暣鏁扮被鍨?                if isinstance(item_id, str):
                    try:
                        item_id = int(item_id)
                    except ValueError:
                        logger.error(f"鏃犳晥鐨勭墿鍝両D: {item_id}")
                        continue
                
                logger.info(f'姝ｅ湪澶勭悊鐗╁搧ID: {item_id}')
                
                # 鑾峰彇鐗╁搧鐘舵€?                item_state = steamworks.Workshop.GetItemState(item_id)
                logger.debug(f'鐗╁搧 {item_id} 鐘舵€? {item_state}')
                
                # 鍒濆鍖栧熀鏈墿鍝佷俊鎭紙纭繚鎵€鏈夊瓧娈甸兘鏈夐粯璁ゅ€硷級
                # 纭繚publishedFileId濮嬬粓涓哄瓧绗︿覆绫诲瀷锛岄伩鍏嶅墠绔痶oString()閿欒
                item_info = {
                    "publishedFileId": str(item_id),
                    "title": f"鏈煡鐗╁搧_{item_id}",
                    "description": "鏃犳硶鑾峰彇璇︾粏鎻忚堪",
                    "tags": [],
                    "state": {
                        "subscribed": bool(item_state & 1),  # EItemState.SUBSCRIBED
                        "legacyItem": bool(item_state & 2),
                        "installed": False,
                        "needsUpdate": bool(item_state & 8),  # EItemState.NEEDS_UPDATE
                        "downloading": False,
                        "downloadPending": bool(item_state & 32),  # EItemState.DOWNLOAD_PENDING
                        "isWorkshopItem": bool(item_state & 128)  # EItemState.IS_WORKSHOP_ITEM
                    },
                    "installedFolder": None,
                    "fileSizeOnDisk": 0,
                    "downloadProgress": {
                        "bytesDownloaded": 0,
                        "bytesTotal": 0,
                        "percentage": 0
                    },
                    # 娣诲姞棰濆鐨勬椂闂存埑淇℃伅 - 浣跨敤datetime鏇夸唬time妯″潡閬垮厤鍛藉悕鍐茬獊
                    "timeAdded": int(datetime.now().timestamp()),
                    "timeUpdated": int(datetime.now().timestamp())
                }
                
                # 灏濊瘯鑾峰彇鐗╁搧瀹夎淇℃伅锛堝鏋滃凡瀹夎锛?                try:
                    logger.debug(f'鑾峰彇鐗╁搧 {item_id} 鐨勫畨瑁呬俊鎭?)
                    result = steamworks.Workshop.GetItemInstallInfo(item_id)
                    
                    # 妫€鏌ヨ繑鍥炲€肩殑缁撴瀯 - 鏀寔瀛楀吀鏍煎紡锛堟牴鎹棩蹇楁樉绀猴級
                    if isinstance(result, dict):
                        logger.debug(f'鐗╁搧 {item_id} 瀹夎淇℃伅瀛楀吀: {result}')
                        
                        # 浠庡瓧鍏镐腑鎻愬彇淇℃伅
                        item_info["state"]["installed"] = True  # 濡傛灉杩斿洖瀛楀吀锛屽亣璁惧凡瀹夎
                        # 鑾峰彇瀹夎璺緞 - workshop.py涓凡缁忓皢folder瑙ｇ爜涓哄瓧绗︿覆
                        folder_path = result.get('folder', '')
                        item_info["installedFolder"] = str(folder_path) if folder_path else None
                        logger.debug(f'鐗╁搧 {item_id} 鐨勫畨瑁呰矾寰? {item_info["installedFolder"]}')
                        
                        # 澶勭悊纾佺洏澶у皬 - GetItemInstallInfo杩斿洖鐨刣isk_size鏄櫘閫氭暣鏁?                        disk_size = result.get('disk_size', 0)
                        item_info["fileSizeOnDisk"] = int(disk_size) if isinstance(disk_size, (int, float)) else 0
                    # 涔熸敮鎸佸厓缁勬牸寮忎綔涓哄閫?                    elif isinstance(result, tuple) and len(result) >= 3:
                        installed, folder, size = result
                        logger.debug(f'鐗╁搧 {item_id} 瀹夎鐘舵€? 宸插畨瑁?{installed}, 璺緞={folder}, 澶у皬={size}')
                        
                        # 瀹夊叏鐨勭被鍨嬭浆鎹?                        item_info["state"]["installed"] = bool(installed)
                        item_info["installedFolder"] = str(folder) if folder and isinstance(folder, (str, bytes)) else None
                        
                        # 澶勭悊澶у皬鍊?                        if isinstance(size, (int, float)):
                            item_info["fileSizeOnDisk"] = int(size)
                        else:
                            item_info["fileSizeOnDisk"] = 0
                    else:
                        logger.warning(f'鐗╁搧 {item_id} 鐨勫畨瑁呬俊鎭繑鍥炴牸寮忔湭鐭? {type(result)} - {result}')
                        item_info["state"]["installed"] = False
                except Exception as e:
                    logger.warning(f'鑾峰彇鐗╁搧 {item_id} 瀹夎淇℃伅澶辫触: {e}')
                    item_info["state"]["installed"] = False
                
                # 灏濊瘯鑾峰彇鐗╁搧涓嬭浇淇℃伅锛堝鏋滄鍦ㄤ笅杞斤級
                try:
                    logger.debug(f'鑾峰彇鐗╁搧 {item_id} 鐨勪笅杞戒俊鎭?)
                    result = steamworks.Workshop.GetItemDownloadInfo(item_id)
                    
                    # 妫€鏌ヨ繑鍥炲€肩殑缁撴瀯 - 鏀寔瀛楀吀鏍煎紡锛堜笌瀹夎淇℃伅淇濇寔涓€鑷达級
                    if isinstance(result, dict):
                        logger.debug(f'鐗╁搧 {item_id} 涓嬭浇淇℃伅瀛楀吀: {result}')
                        
                        # 浣跨敤姝ｇ‘鐨勯敭鍚嶈幏鍙栦笅杞戒俊鎭?                        downloaded = result.get('downloaded', 0)
                        total = result.get('total', 0)
                        progress = result.get('progress', 0.0)
                        
                        # 鏍规嵁total鍜宒ownloaded纭畾鏄惁姝ｅ湪涓嬭浇
                        item_info["state"]["downloading"] = total > 0 and downloaded < total
                        
                        # 璁剧疆涓嬭浇杩涘害淇℃伅
                        if downloaded > 0 or total > 0:
                            item_info["downloadProgress"] = {
                                "bytesDownloaded": int(downloaded),
                                "bytesTotal": int(total),
                                "percentage": progress * 100 if isinstance(progress, (int, float)) else 0
                            }
                    # 涔熸敮鎸佸厓缁勬牸寮忎綔涓哄閫?                    elif isinstance(result, tuple) and len(result) >= 3:
                        # 鍏冪粍涓簲璇ュ寘鍚笅杞界姸鎬併€佸凡涓嬭浇瀛楄妭鏁板拰鎬诲瓧鑺傛暟
                        downloaded, total, progress = result if len(result) >= 3 else (0, 0, 0.0)
                        logger.debug(f'鐗╁搧 {item_id} 涓嬭浇鐘舵€? 宸蹭笅杞?{downloaded}, 鎬昏={total}, 杩涘害={progress}')
                        
                        # 鏍规嵁total鍜宒ownloaded纭畾鏄惁姝ｅ湪涓嬭浇
                        item_info["state"]["downloading"] = total > 0 and downloaded < total
                        
                        # 璁剧疆涓嬭浇杩涘害淇℃伅
                        if downloaded > 0 or total > 0:
                            # 澶勭悊鍙兘鐨勭被鍨嬭浆鎹?                            try:
                                downloaded_value = int(downloaded.value) if hasattr(downloaded, 'value') else int(downloaded)
                                total_value = int(total.value) if hasattr(total, 'value') else int(total)
                                progress_value = float(progress.value) if hasattr(progress, 'value') else float(progress)
                            except:
                                downloaded_value, total_value, progress_value = 0, 0, 0.0
                                
                            item_info["downloadProgress"] = {
                                "bytesDownloaded": downloaded_value,
                                "bytesTotal": total_value,
                                "percentage": progress_value * 100
                            }
                    else:
                        logger.warning(f'鐗╁搧 {item_id} 鐨勪笅杞戒俊鎭繑鍥炴牸寮忔湭鐭? {type(result)} - {result}')
                        item_info["state"]["downloading"] = False
                except Exception as e:
                    logger.warning(f'鑾峰彇鐗╁搧 {item_id} 涓嬭浇淇℃伅澶辫触: {e}')
                    item_info["state"]["downloading"] = False
                
                # 灏濊瘯鑾峰彇鐗╁搧璇︾粏淇℃伅锛堟爣棰樸€佹弿杩扮瓑锛? 浣跨敤瀹樻柟鎺ㄨ崘鐨勬柟寮?                try:
                    # 浣跨敤瀹樻柟鎺ㄨ崘鐨凜reateQueryUGCDetailsRequest鍜孲endQueryUGCRequest鏂规硶
                    logger.debug(f'浣跨敤瀹樻柟鎺ㄨ崘鏂规硶鑾峰彇鐗╁搧 {item_id} 鐨勮缁嗕俊鎭?)
                    
                    # 鍒涘缓UGC璇︽儏鏌ヨ璇锋眰
                    query_handle = steamworks.Workshop.CreateQueryUGCDetailsRequest([item_id])
                    
                    if query_handle:
                        # 璁剧疆鍥炶皟鍑芥暟
                        details_received = False
                        
                        def query_completed_callback(result):
                            nonlocal details_received
                            details_received = True
                            # 鍥炶皟缁撴灉浼氬湪涓荤嚎绋嬩腑閫氳繃GetQueryUGCResult鑾峰彇
                            pass
                        
                        # 璁剧疆鍥炶皟
                        steamworks.Workshop.SetQueryUGCRequestCallback(query_completed_callback)
                        
                        # 鍙戦€佹煡璇㈣姹?                        steamworks.Workshop.SendQueryUGCRequest(query_handle)
                        
                        # 绛夊緟鏌ヨ瀹屾垚锛堢畝鍗曠殑杞鏂瑰紡锛?                        import time
                        timeout = 2  # 2绉掕秴鏃?                        start_time = time.time()
                        
                        # 鐢变簬杩欐槸寮傛鍥炶皟锛屾垜浠畝鍗曞湴绛夊緟涓€灏忔鏃堕棿璁╂煡璇㈡湁鏈轰細瀹屾垚
                        time.sleep(0.5)  # 绛夊緟0.5绉?                        
                        try:
                            # 灏濊瘯鑾峰彇鏌ヨ缁撴灉
                            result = steamworks.Workshop.GetQueryUGCResult(query_handle, 0)
                            if result:
                                # 浠庣粨鏋滀腑鎻愬彇淇℃伅
                                if hasattr(result, 'title') and result.title:
                                    item_info['title'] = result.title.decode('utf-8', errors='replace')
                                if hasattr(result, 'description') and result.description:
                                    item_info['description'] = result.description.decode('utf-8', errors='replace')
                                # 鑾峰彇鍒涘缓鍜屾洿鏂版椂闂?                                if hasattr(result, 'timeCreated'):
                                    item_info['timeAdded'] = int(result.timeCreated)
                                if hasattr(result, 'timeUpdated'):
                                    item_info['timeUpdated'] = int(result.timeUpdated)
                                # 鑾峰彇浣滆€呬俊鎭?                                if hasattr(result, 'steamIDOwner'):
                                    item_info['steamIDOwner'] = str(result.steamIDOwner)
                                # 鑾峰彇鏂囦欢澶у皬淇℃伅
                                if hasattr(result, 'fileSize'):
                                    item_info['fileSizeOnDisk'] = int(result.fileSize)
                                
                                logger.info(f"鎴愬姛鑾峰彇鐗╁搧 {item_id} 鐨勮鎯呬俊鎭?)
                        except Exception as query_error:
                            logger.warning(f"鑾峰彇鏌ヨ缁撴灉鏃跺嚭閿? {query_error}")
                except Exception as api_error:
                    logger.warning(f"浣跨敤瀹樻柟API鑾峰彇鐗╁搧 {item_id} 璇︽儏鏃跺嚭閿? {api_error}")
                
                # 浣滀负澶囬€夋柟妗堬紝濡傛灉鏈湴鏈夊畨瑁呰矾寰勶紝灏濊瘯浠庢湰鍦版枃浠惰幏鍙栦俊鎭?                if item_info['title'].startswith('鏈煡鐗╁搧_') or not item_info['description']:
                    install_folder = item_info.get('installedFolder')
                    if install_folder and os.path.exists(install_folder):
                        logger.debug(f'灏濊瘯浠庡畨瑁呮枃浠跺す鑾峰彇鐗╁搧淇℃伅: {install_folder}')
                        # 鏌ユ壘鍙兘鐨勯厤缃枃浠舵潵鑾峰彇鏇村淇℃伅
                        config_files = [
                            os.path.join(install_folder, "config.json"),
                            os.path.join(install_folder, "package.json"),
                            os.path.join(install_folder, "info.json"),
                            os.path.join(install_folder, "manifest.json"),
                            os.path.join(install_folder, "README.md"),
                            os.path.join(install_folder, "README.txt")
                        ]
                        
                        for config_path in config_files:
                            if os.path.exists(config_path):
                                try:
                                    with open(config_path, 'r', encoding='utf-8') as f:
                                        if config_path.endswith('.json'):
                                            config_data = json.load(f)
                                            # 灏濊瘯浠庨厤缃枃浠朵腑鎻愬彇鏍囬鍜屾弿杩?                                            if "title" in config_data and config_data["title"]:
                                                item_info["title"] = config_data["title"]
                                            elif "name" in config_data and config_data["name"]:
                                                item_info["title"] = config_data["name"]
                                            
                                            if "description" in config_data and config_data["description"]:
                                                item_info["description"] = config_data["description"]
                                        else:
                                            # 瀵逛簬鏂囨湰鏂囦欢锛屽皢绗竴琛屼綔涓烘爣棰?                                            first_line = f.readline().strip()
                                            if first_line and item_info['title'].startswith('鏈煡鐗╁搧_'):
                                                item_info['title'] = first_line[:100]  # 闄愬埗闀垮害
                                    logger.info(f"浠庢湰鍦版枃浠?{os.path.basename(config_path)} 鎴愬姛鑾峰彇鐗╁搧 {item_id} 鐨勪俊鎭?)
                                    break
                                except Exception as file_error:
                                    logger.warning(f"璇诲彇閰嶇疆鏂囦欢 {config_path} 鏃跺嚭閿? {file_error}")
                # 绉婚櫎浜嗘病鏈夊搴攖ry鍧楃殑except璇彞
                
                # 纭繚publishedFileId鏄瓧绗︿覆绫诲瀷
                item_info['publishedFileId'] = str(item_info['publishedFileId'])
                
                # 灏濊瘯鑾峰彇棰勮鍥句俊鎭?- 浼樺厛浠庢湰鍦版枃浠跺す鏌ユ壘
                preview_url = None
                install_folder = item_info.get('installedFolder')
                if install_folder and os.path.exists(install_folder):
                    try:
                        # 浣跨敤杈呭姪鍑芥暟鏌ユ壘棰勮鍥?                        preview_image_path = find_preview_image_in_folder(install_folder)
                        if preview_image_path:
                            # 涓哄墠绔彁渚涗唬鐞嗚闂殑璺緞鏍煎紡
                            # 闇€瑕佸皢璺緞鏍囧噯鍖栵紝纭繚鍙互閫氳繃proxy-image API璁块棶
                            if os.name == 'nt':
                                # Windows璺緞澶勭悊
                                proxy_path = preview_image_path.replace('\\', '/')
                            else:
                                proxy_path = preview_image_path
                            preview_url = f"/api/proxy-image?image_path={quote(proxy_path)}"
                            logger.debug(f'涓虹墿鍝?{item_id} 鎵惧埌鏈湴棰勮鍥? {preview_url}')
                    except Exception as preview_error:
                        logger.warning(f'鏌ユ壘鐗╁搧 {item_id} 棰勮鍥炬椂鍑洪敊: {preview_error}')
                
                # 娣诲姞棰勮鍥綰RL鍒扮墿鍝佷俊鎭?                if preview_url:
                    item_info['previewUrl'] = preview_url
                
                # 娣诲姞鐗╁搧淇℃伅鍒扮粨鏋滃垪琛?                items_info.append(item_info)
                logger.debug(f'鐗╁搧 {item_id} 淇℃伅宸叉坊鍔犲埌缁撴灉鍒楄〃: {item_info["title"]}')
                
            except Exception as item_error:
                logger.error(f"鑾峰彇鐗╁搧 {item_id} 淇℃伅鏃跺嚭閿? {item_error}")
                # 鍗充娇鍑洪敊锛屼篃娣诲姞涓€涓渶鍩烘湰鐨勭墿鍝佷俊鎭埌鍒楄〃涓?                try:
                    basic_item_info = {
                        "publishedFileId": str(item_id),  # 纭繚鏄瓧绗︿覆绫诲瀷
                        "title": f"鏈煡鐗╁搧_{item_id}",
                        "description": "鏃犳硶鑾峰彇璇︾粏淇℃伅",
                        "state": {
                            "subscribed": True,
                            "installed": False,
                            "downloading": False,
                            "needsUpdate": False,
                            "error": True
                        },
                        "error_message": str(item_error)
                    }
                    items_info.append(basic_item_info)
                    logger.info(f'宸叉坊鍔犵墿鍝?{item_id} 鐨勫熀鏈俊鎭埌缁撴灉鍒楄〃')
                except Exception as basic_error:
                    logger.error(f"娣诲姞鍩烘湰鐗╁搧淇℃伅涔熷け璐ヤ簡: {basic_error}")
                # 缁х画澶勭悊涓嬩竴涓墿鍝?                continue
        
        return {
            "success": True,
            "items": items_info,
            "total": len(items_info)
        }
        
    except Exception as e:
        logger.error(f"鑾峰彇璁㈤槄鐗╁搧鍒楄〃鏃跺嚭閿? {e}")
        return JSONResponse({
            "success": False,
            "error": f"鑾峰彇璁㈤槄鐗╁搧澶辫触: {str(e)}"
        }, status_code=500)

async def _init_and_mount_workshop():
    """
    鍒濆鍖栧苟鎸傝浇鍒涙剰宸ュ潑鐩綍
    
    璁捐鍘熷垯锛?    - main 灞傚彧璐熻矗璋冪敤锛屼笉缁存姢鐘舵€?    - 璺緞鐢?utils 灞傝绠楀苟鎸佷箙鍖栧埌 config 灞?    - 鍏朵粬浠ｇ爜闇€瑕佽矾寰勬椂璋冪敤 get_workshop_path() 鑾峰彇
    """
    try:
        # 1. 鑾峰彇璁㈤槄鐨勫垱鎰忓伐鍧婄墿鍝佸垪琛?        workshop_items_result = await get_subscribed_workshop_items()
        
        # 2. 鎻愬彇鐗╁搧鍒楄〃浼犵粰 utils 灞?        subscribed_items = []
        if isinstance(workshop_items_result, dict) and workshop_items_result.get('success', False):
            subscribed_items = workshop_items_result.get('items', [])
        
        # 3. 璋冪敤 utils 灞傚嚱鏁拌幏鍙?璁＄畻璺緞锛堣矾寰勪細琚寔涔呭寲鍒?config锛?        workshop_path = get_workshop_root(subscribed_items)
        
        # 4. 鎸傝浇闈欐€佹枃浠剁洰褰?        if workshop_path and os.path.exists(workshop_path) and os.path.isdir(workshop_path):
            try:
                app.mount("/workshop", StaticFiles(directory=workshop_path), name="workshop")
                logger.info(f"鉁?鎴愬姛鎸傝浇鍒涙剰宸ュ潑鐩綍: {workshop_path}")
            except Exception as e:
                logger.error(f"鎸傝浇鍒涙剰宸ュ潑鐩綍澶辫触: {e}")
        else:
            logger.warning(f"鍒涙剰宸ュ潑鐩綍涓嶅瓨鍦ㄦ垨涓嶆槸鏈夋晥鐨勭洰褰? {workshop_path}锛岃烦杩囨寕杞?)
    except Exception as e:
        logger.error(f"鍒濆鍖栧垱鎰忓伐鍧婄洰褰曟椂鍑洪敊: {e}")
        # 闄嶇骇锛氱‘淇濊嚦灏戞湁涓€涓粯璁よ矾寰勫彲鐢?        workshop_path = get_workshop_path()
        logger.info(f"浣跨敤閰嶇疆涓殑榛樿璺緞: {workshop_path}")
        if workshop_path and os.path.exists(workshop_path) and os.path.isdir(workshop_path):
            try:
                app.mount("/workshop", StaticFiles(directory=workshop_path), name="workshop")
                logger.info(f"鉁?闄嶇骇妯″紡涓嬫垚鍔熸寕杞藉垱鎰忓伐鍧婄洰褰? {workshop_path}")
            except Exception as mount_err:
                logger.error(f"闄嶇骇妯″紡鎸傝浇鍒涙剰宸ュ潑鐩綍浠嶇劧澶辫触: {mount_err}")
                
@app.get('/api/steam/workshop/item/{item_id}/path')
async def get_workshop_item_path(item_id: str):
    """
    鑾峰彇鍗曚釜Steam鍒涙剰宸ュ潑鐗╁搧鐨勪笅杞借矾寰?    姝PI绔偣涓撻棬鐢ㄤ簬鍦ㄧ鐞嗛〉闈腑鑾峰彇鐗╁搧鐨勫畨瑁呰矾寰?    """
    global steamworks
    
    # 妫€鏌teamworks鏄惁鍒濆鍖栨垚鍔?    if steamworks is None:
        return JSONResponse({
            "success": False,
            "error": "Steamworks鏈垵濮嬪寲",
            "message": "璇风‘淇漇team瀹㈡埛绔凡杩愯涓斿凡鐧诲綍"
        }, status_code=503)
    
    try:
        # 杞崲item_id涓烘暣鏁?        item_id_int = int(item_id)
        
        # 鑾峰彇鐗╁搧瀹夎淇℃伅
        install_info = steamworks.Workshop.GetItemInstallInfo(item_id_int)
        
        if not install_info:
            return JSONResponse({
                "success": False,
                "error": "鐗╁搧鏈畨瑁?,
                "message": f"鐗╁搧 {item_id} 灏氭湭瀹夎鎴栧畨瑁呬俊鎭笉鍙敤"
            }, status_code=404)
        
        # 鎻愬彇瀹夎璺緞
        folder_path = install_info.get('folder', '')
        
        # 鏋勫缓鍝嶅簲
        response = {
            "success": True,
            "item_id": item_id,
            "installed": True,
            "path": folder_path,
            "full_path": folder_path  # 瀹屾暣璺緞锛屼笌path淇濇寔涓€鑷?        }
        
        # 濡傛灉鏈夌鐩樺ぇ灏忎俊鎭紝涔熶竴骞惰繑鍥?        try:
            disk_size = install_info.get('disk_size')
            if isinstance(disk_size, (int, float)):
                response['size_on_disk'] = int(disk_size)
        except:
            pass
        
        return response
        
    except ValueError:
        return JSONResponse({
            "success": False,
            "error": "鏃犳晥鐨勭墿鍝両D",
            "message": "鐗╁搧ID蹇呴』鏄湁鏁堢殑鏁板瓧"
        }, status_code=400)
    except Exception as e:
        logger.error(f"鑾峰彇鐗╁搧 {item_id} 璺緞鏃跺嚭閿? {e}")
        return JSONResponse({
            "success": False,
            "error": "鑾峰彇璺緞澶辫触",
            "message": str(e)
        }, status_code=500)

@app.get('/api/steam/workshop/item/{item_id}')
async def get_workshop_item_details(item_id: str):
    """
    鑾峰彇鍗曚釜Steam鍒涙剰宸ュ潑鐗╁搧鐨勮缁嗕俊鎭?    """
    global steamworks
    
    # 妫€鏌teamworks鏄惁鍒濆鍖栨垚鍔?    if steamworks is None:
        return JSONResponse({
            "success": False,
            "error": "Steamworks鏈垵濮嬪寲",
            "message": "璇风‘淇漇team瀹㈡埛绔凡杩愯涓斿凡鐧诲綍"
        }, status_code=503)
    
    try:
        # 杞崲item_id涓烘暣鏁?        item_id_int = int(item_id)
        
        # 鑾峰彇鐗╁搧鐘舵€?        item_state = steamworks.Workshop.GetItemState(item_id_int)
        
        # 鍒涘缓鏌ヨ璇锋眰锛屼紶鍏ュ繀瑕佺殑published_file_ids鍙傛暟
        query_handle = steamworks.Workshop.CreateQueryUGCDetailsRequest([item_id_int])
        
        # 鍙戦€佹煡璇㈣姹?        # 娉ㄦ剰锛歋endQueryUGCRequest杩斿洖None鑰屼笉鏄竷灏斿€?        steamworks.Workshop.SendQueryUGCRequest(query_handle)
        
        # 鐩存帴鑾峰彇鏌ヨ缁撴灉锛屼笉妫€鏌andle
        result = steamworks.Workshop.GetQueryUGCResult(query_handle, 0)
        
        if result:
            
            if result:
                # 鑾峰彇鐗╁搧瀹夎淇℃伅 - 鏀寔瀛楀吀鏍煎紡锛堟牴鎹畐orkshop.py鐨勫疄鐜帮級
                install_info = steamworks.Workshop.GetItemInstallInfo(item_id_int)
                installed = bool(install_info)
                folder = install_info.get('folder', '') if installed else ''
                size = 0
                disk_size = install_info.get('disk_size')
                if isinstance(disk_size, (int, float)):
                    size = int(disk_size)
                
                # 鑾峰彇鐗╁搧涓嬭浇淇℃伅
                download_info = steamworks.Workshop.GetItemDownloadInfo(item_id_int)
                downloading = False
                bytes_downloaded = 0
                bytes_total = 0
                
                # 澶勭悊涓嬭浇淇℃伅锛堜娇鐢ㄦ纭殑閿悕锛歞ownloaded鍜宼otal锛?                if download_info:
                    if isinstance(download_info, dict):
                        downloaded = int(download_info.get("downloaded", 0) or 0)
                        total = int(download_info.get("total", 0) or 0)
                        downloading = downloaded > 0 and downloaded < total
                        bytes_downloaded = downloaded
                        bytes_total = total
                    elif isinstance(download_info, tuple) and len(download_info) >= 3:
                        # 鍏煎鍏冪粍鏍煎紡
                        downloading, bytes_downloaded, bytes_total = download_info
                
                # 瑙ｇ爜bytes绫诲瀷鐨勫瓧娈典负瀛楃涓诧紝閬垮厤JSON搴忓垪鍖栭敊璇?                title = result.title.decode('utf-8', errors='replace') if hasattr(result, 'title') and isinstance(result.title, bytes) else getattr(result, 'title', '')
                description = result.description.decode('utf-8', errors='replace') if hasattr(result, 'description') and isinstance(result.description, bytes) else getattr(result, 'description', '')
                
                # 鏋勫缓璇︾粏鐨勭墿鍝佷俊鎭?                item_info = {
                    "publishedFileId": item_id_int,
                    "title": title,
                    "description": description,
                    "steamIDOwner": result.steamIDOwner,
                    "timeCreated": result.timeCreated,
                    "timeUpdated": result.timeUpdated,
                    "previewImageUrl": result.URL,  # 浣跨敤result.URL浠ｆ浛涓嶅瓨鍦ㄧ殑previewImageUrl
                    "fileUrl": result.URL,  # 浣跨敤result.URL浠ｆ浛涓嶅瓨鍦ㄧ殑fileUrl
                    "fileSize": result.fileSize,
                    "fileId": result.file,  # 浣跨敤result.file浠ｆ浛涓嶅瓨鍦ㄧ殑fileId
                    "previewFileId": result.previewFile,  # 浣跨敤result.previewFile浠ｆ浛涓嶅瓨鍦ㄧ殑previewFileId
                    # 绉婚櫎涓嶅瓨鍦ㄧ殑appID灞炴€?                    "tags": [],
                    "state": {
                        "subscribed": bool(item_state & 1),
                        "legacyItem": bool(item_state & 2),
                        "installed": installed,
                        "needsUpdate": bool(item_state & 8),
                        "downloading": downloading,
                        "downloadPending": bool(item_state & 32),
                        "isWorkshopItem": bool(item_state & 128)
                    },
                    "installedFolder": folder if installed else None,
                    "fileSizeOnDisk": size if installed else 0,
                    "downloadProgress": {
                        "bytesDownloaded": bytes_downloaded if downloading else 0,
                        "bytesTotal": bytes_total if downloading else 0,
                        "percentage": (bytes_downloaded / bytes_total * 100) if bytes_total > 0 and downloading else 0
                    }
                }
                
                # 娉ㄦ剰锛歋teamWorkshop绫讳腑涓嶅瓨鍦≧eleaseQueryUGCRequest鏂规硶锛屾棤闇€閲婃斁鍙ユ焺
                
                return {
                    "success": True,
                    "item": item_info
                }
            else:
                # 娉ㄦ剰锛歋teamWorkshop绫讳腑涓嶅瓨鍦≧eleaseQueryUGCRequest鏂规硶
                return JSONResponse({
                    "success": False,
                    "error": "鑾峰彇鐗╁搧璇︽儏澶辫触锛屾湭鎵惧埌鐗╁搧"
                }, status_code=404)
            
    except ValueError:
        return JSONResponse({
            "success": False,
            "error": "鏃犳晥鐨勭墿鍝両D"
        }, status_code=400)
    except Exception as e:
        logger.error(f"鑾峰彇鐗╁搧 {item_id} 璇︽儏鏃跺嚭閿? {e}")
        return JSONResponse({
            "success": False,
            "error": f"鑾峰彇鐗╁搧璇︽儏澶辫触: {str(e)}"
        }, status_code=500)

@app.post('/api/steam/workshop/unsubscribe')
async def unsubscribe_workshop_item(request: Request):
    """
    鍙栨秷璁㈤槄Steam鍒涙剰宸ュ潑鐗╁搧
    鎺ユ敹鍖呭惈鐗╁搧ID鐨凱OST璇锋眰
    """
    global steamworks
    
    # 妫€鏌teamworks鏄惁鍒濆鍖栨垚鍔?    if steamworks is None:
        return JSONResponse({
            "success": False,
            "error": "Steamworks鏈垵濮嬪寲",
            "message": "璇风‘淇漇team瀹㈡埛绔凡杩愯涓斿凡鐧诲綍"
        }, status_code=503)
    
    try:
        # 鑾峰彇璇锋眰浣撲腑鐨勬暟鎹?        data = await request.json()
        item_id = data.get('item_id')
        
        if not item_id:
            return JSONResponse({
                "success": False,
                "error": "缂哄皯蹇呰鍙傛暟",
                "message": "璇锋眰涓己灏戠墿鍝両D"
            }, status_code=400)
        
        # 杞崲item_id涓烘暣鏁?        try:
            item_id_int = int(item_id)
        except ValueError:
            return JSONResponse({
                "success": False,
                "error": "鏃犳晥鐨勭墿鍝両D",
                "message": "鎻愪緵鐨勭墿鍝両D涓嶆槸鏈夋晥鐨勬暟瀛?
            }, status_code=400)
        
        # 瀹氫箟涓€涓畝鍗曠殑鍥炶皟鍑芥暟鏉ュ鐞嗗彇娑堣闃呯殑缁撴灉
        def unsubscribe_callback(result):
            # 璁板綍鍙栨秷璁㈤槄鐨勭粨鏋?            if result.result == 1:  # k_EResultOK
                logger.info(f"鍙栨秷璁㈤槄鎴愬姛鍥炶皟: {item_id_int}")
            else:
                logger.warning(f"鍙栨秷璁㈤槄澶辫触鍥炶皟: {item_id_int}, 閿欒浠ｇ爜: {result.result}")
        
        # 璋冪敤Steamworks鐨刄nsubscribeItem鏂规硶锛屽苟鎻愪緵鍥炶皟鍑芥暟
        steamworks.Workshop.UnsubscribeItem(item_id_int, callback=unsubscribe_callback)
        # 鐢变簬鍥炶皟鏄紓姝ョ殑锛屾垜浠繑鍥炶姹傚凡琚帴鍙楀鐞嗙殑鐘舵€?        logger.info(f"鍙栨秷璁㈤槄璇锋眰宸茶鎺ュ彈锛屾鍦ㄥ鐞? {item_id_int}")
        return {
            "success": True,
            "status": "accepted",
            "message": "鍙栨秷璁㈤槄璇锋眰宸茶鎺ュ彈锛屾鍦ㄥ鐞嗕腑銆傚疄闄呯粨鏋滃皢鍦ㄥ悗鍙板紓姝ュ畬鎴愩€?
        }
            
    except Exception as e:
        logger.error(f"鍙栨秷璁㈤槄鐗╁搧鏃跺嚭閿? {e}")
        return JSONResponse({
            "success": False,
            "error": "鏈嶅姟鍣ㄥ唴閮ㄩ敊璇?,
            "message": f"鍙栨秷璁㈤槄杩囩▼涓彂鐢熼敊璇? {str(e)}"
        }, status_code=500)

@app.get('/api/characters/current_catgirl')
async def get_current_catgirl():
    """鑾峰彇褰撳墠浣跨敤鐨勭尗濞樺悕绉?""
    characters = _config_manager.load_characters()
    current_catgirl = characters.get('褰撳墠鐚', '')
    return JSONResponse(content={'current_catgirl': current_catgirl})

@app.get('/api/characters/catgirl/{name}/voice_mode_status')
async def get_catgirl_voice_mode_status(name: str):
    """妫€鏌ユ寚瀹氳鑹叉槸鍚﹀湪璇煶妯″紡涓?""
    characters = _config_manager.load_characters()
    is_current = characters.get('褰撳墠鐚') == name
    
    if name not in session_manager:
        return JSONResponse({'is_voice_mode': False, 'is_current': is_current, 'is_active': False})
    
    mgr = session_manager[name]
    is_active = mgr.is_active if mgr else False
    
    is_voice_mode = False
    if is_active and mgr:
        # 妫€鏌ユ槸鍚︽槸璇煶妯″紡锛堥€氳繃session绫诲瀷鍒ゆ柇锛?        from main_helper.omni_realtime_client import OmniRealtimeClient
        is_voice_mode = mgr.session and isinstance(mgr.session, OmniRealtimeClient)
    
    return JSONResponse({
        'is_voice_mode': is_voice_mode,
        'is_current': is_current,
        'is_active': is_active
    })

@app.post('/api/characters/current_catgirl')
async def set_current_catgirl(request: Request):
    """璁剧疆褰撳墠浣跨敤鐨勭尗濞?""
    data = await request.json()
    catgirl_name = data.get('catgirl_name', '') if data else ''
    
    if not catgirl_name:
        return JSONResponse({'success': False, 'error': '鐚鍚嶇О涓嶈兘涓虹┖'}, status_code=400)
    
    characters = _config_manager.load_characters()
    if catgirl_name not in characters.get('鐚', {}):
        return JSONResponse({'success': False, 'error': '鎸囧畾鐨勭尗濞樹笉瀛樺湪'}, status_code=404)
    
    old_catgirl = characters.get('褰撳墠鐚', '')
    
    # 妫€鏌ュ綋鍓嶈鑹叉槸鍚︽湁娲昏穬鐨勮闊硈ession
    if old_catgirl and old_catgirl in session_manager:
        mgr = session_manager[old_catgirl]
        if mgr.is_active:
            # 妫€鏌ユ槸鍚︽槸璇煶妯″紡锛堥€氳繃session绫诲瀷鍒ゆ柇锛?            from main_helper.omni_realtime_client import OmniRealtimeClient
            is_voice_mode = mgr.session and isinstance(mgr.session, OmniRealtimeClient)
            
            if is_voice_mode:
                return JSONResponse({
                    'success': False, 
                    'error': '璇煶鐘舵€佷笅鏃犳硶鍒囨崲瑙掕壊锛岃鍏堝仠姝㈣闊冲璇濆悗鍐嶅垏鎹?
                }, status_code=400)
    characters['褰撳墠鐚'] = catgirl_name
    _config_manager.save_characters(characters)
    # 鑷姩閲嶆柊鍔犺浇閰嶇疆
    await initialize_character_data()
    
    # 閫氳繃WebSocket閫氱煡鎵€鏈夎繛鎺ョ殑瀹㈡埛绔?    # 浣跨敤session_manager涓殑websocket锛屼絾闇€瑕佺‘淇漺ebsocket宸茶缃?    notification_count = 0
    logger.info(f"寮€濮嬮€氱煡WebSocket瀹㈡埛绔細鐚浠?{old_catgirl} 鍒囨崲鍒?{catgirl_name}")
    
    message = json.dumps({
        "type": "catgirl_switched",
        "new_catgirl": catgirl_name,
        "old_catgirl": old_catgirl
    })
    
    # 閬嶅巻鎵€鏈塻ession_manager锛屽皾璇曞彂閫佹秷鎭?    for lanlan_name, mgr in session_manager.items():
        ws = mgr.websocket
        logger.info(f"妫€鏌?{lanlan_name} 鐨刉ebSocket: websocket瀛樺湪={ws is not None}")
        
        if ws:
            try:
                await ws.send_text(message)
                notification_count += 1
                logger.info(f"鉁?宸查€氳繃WebSocket閫氱煡 {lanlan_name} 鐨勮繛鎺ワ細鐚宸蹭粠 {old_catgirl} 鍒囨崲鍒?{catgirl_name}")
            except Exception as e:
                logger.warning(f"鉂?閫氱煡 {lanlan_name} 鐨勮繛鎺ュけ璐? {e}")
                # 濡傛灉鍙戦€佸け璐ワ紝鍙兘鏄繛鎺ュ凡鏂紑锛屾竻绌簑ebsocket寮曠敤
                if mgr.websocket == ws:
                    mgr.websocket = None
    
    if notification_count > 0:
        logger.info(f"鉁?宸查€氳繃WebSocket閫氱煡 {notification_count} 涓繛鎺ョ殑瀹㈡埛绔細鐚宸蹭粠 {old_catgirl} 鍒囨崲鍒?{catgirl_name}")
    else:
        logger.warning(f"鈿狅笍 娌℃湁鎵惧埌浠讳綍娲昏穬鐨刉ebSocket杩炴帴鏉ラ€氱煡鐚鍒囨崲")
        logger.warning(f"鎻愮ず锛氳纭繚鍓嶇椤甸潰宸叉墦寮€骞跺缓绔嬩簡WebSocket杩炴帴锛屼笖宸茶皟鐢╯tart_session")
    
    return {"success": True}

@app.post('/api/characters/reload')
async def reload_character_config():
    """閲嶆柊鍔犺浇瑙掕壊閰嶇疆锛堢儹閲嶈浇锛?""
    try:
        await initialize_character_data()
        return {"success": True, "message": "瑙掕壊閰嶇疆宸查噸鏂板姞杞?}
    except Exception as e:
        logger.error(f"閲嶆柊鍔犺浇瑙掕壊閰嶇疆澶辫触: {e}")
        return JSONResponse(
            {'success': False, 'error': f'閲嶆柊鍔犺浇澶辫触: {str(e)}'}, 
            status_code=500
        )

@app.post('/api/characters/master')
async def update_master(request: Request):
    data = await request.json()
    if not data or not data.get('妗ｆ鍚?):
        return JSONResponse({'success': False, 'error': '妗ｆ鍚嶄负蹇呭～椤?}, status_code=400)
    characters = _config_manager.load_characters()
    characters['涓讳汉'] = {k: v for k, v in data.items() if v}
    _config_manager.save_characters(characters)
    # 鑷姩閲嶆柊鍔犺浇閰嶇疆
    await initialize_character_data()
    return {"success": True}

@app.post('/api/characters/catgirl')
async def add_catgirl(request: Request):
    data = await request.json()
    if not data or not data.get('妗ｆ鍚?):
        return JSONResponse({'success': False, 'error': '妗ｆ鍚嶄负蹇呭～椤?}, status_code=400)
    
    characters = _config_manager.load_characters()
    key = data['妗ｆ鍚?]
    if key in characters.get('鐚', {}):
        return JSONResponse({'success': False, 'error': '璇ョ尗濞樺凡瀛樺湪'}, status_code=400)
    
    if '鐚' not in characters:
        characters['鐚'] = {}
    
    # 鍒涘缓鐚鏁版嵁锛屽彧淇濆瓨闈炵┖瀛楁
    catgirl_data = {}
    for k, v in data.items():
        if k != '妗ｆ鍚?:
            # voice_id 鐗规畩澶勭悊锛氱┖瀛楃涓茶〃绀哄垹闄よ瀛楁
            if k == 'voice_id' and v == '':
                continue  # 涓嶆坊鍔犺瀛楁锛岀浉褰撲簬鍒犻櫎
            elif v:  # 鍙繚瀛橀潪绌哄瓧娈?                catgirl_data[k] = v
    
    characters['鐚'][key] = catgirl_data
    _config_manager.save_characters(characters)
    # 鑷姩閲嶆柊鍔犺浇閰嶇疆
    await initialize_character_data()
    
    # 閫氱煡璁板繂鏈嶅姟鍣ㄩ噸鏂板姞杞介厤缃?    try:
        import httpx
        async with httpx.AsyncClient() as client:
            resp = await client.post(f"http://localhost:{MEMORY_SERVER_PORT}/reload", timeout=5.0)
            if resp.status_code == 200:
                result = resp.json()
                if result.get('status') == 'success':
                    logger.info(f"鉁?宸查€氱煡璁板繂鏈嶅姟鍣ㄩ噸鏂板姞杞介厤缃紙鏂拌鑹? {key}锛?)
                else:
                    logger.warning(f"鈿狅笍 璁板繂鏈嶅姟鍣ㄩ噸鏂板姞杞介厤缃繑鍥? {result.get('message')}")
            else:
                logger.warning(f"鈿狅笍 璁板繂鏈嶅姟鍣ㄩ噸鏂板姞杞介厤缃け璐ワ紝鐘舵€佺爜: {resp.status_code}")
    except Exception as e:
        logger.warning(f"鈿狅笍 閫氱煡璁板繂鏈嶅姟鍣ㄩ噸鏂板姞杞介厤缃椂鍑洪敊: {e}锛堜笉褰卞搷瑙掕壊鍒涘缓锛?)
    
    return {"success": True}

@app.put('/api/characters/catgirl/{name}')
async def update_catgirl(name: str, request: Request):
    data = await request.json()
    if not data:
        return JSONResponse({'success': False, 'error': '鏃犳暟鎹?}, status_code=400)
    characters = _config_manager.load_characters()
    if name not in characters.get('鐚', {}):
        return JSONResponse({'success': False, 'error': '鐚涓嶅瓨鍦?}, status_code=404)
    
    # 璁板綍鏇存柊鍓嶇殑voice_id锛岀敤浜庢娴嬫槸鍚﹀彉鏇?    old_voice_id = characters['鐚'][name].get('voice_id', '')
    
    # 濡傛灉鍖呭惈voice_id锛岄獙璇佸叾鏈夋晥鎬?    if 'voice_id' in data:
        voice_id = data['voice_id']
        # 绌哄瓧绗︿覆琛ㄧず鍒犻櫎voice_id锛岃烦杩囬獙璇?        if voice_id != '' and not _config_manager.validate_voice_id(voice_id):
            voices = _config_manager.get_voices_for_current_api()
            available_voices = list(voices.keys())
            return JSONResponse({
                'success': False, 
                'error': f'voice_id "{voice_id}" 鍦ㄥ綋鍓岮PI鐨勯煶鑹插簱涓笉瀛樺湪',
                'available_voices': available_voices
            }, status_code=400)
    
    # 鍙洿鏂板墠绔紶鏉ョ殑瀛楁锛屾湭浼犲瓧娈典繚鐣欏師鍊硷紝涓斾笉鍏佽閫氳繃姝ゆ帴鍙ｄ慨鏀?system_prompt
    removed_fields = []
    for k, v in characters['鐚'][name].items():
        if k not in data and k not in ('妗ｆ鍚?, 'system_prompt', 'voice_id', 'live2d'):
            removed_fields.append(k)
    for k in removed_fields:
        characters['鐚'][name].pop(k)
    
    # 澶勭悊voice_id鐨勭壒娈婇€昏緫锛氬鏋滀紶鍏ョ┖瀛楃涓诧紝鍒欏垹闄よ瀛楁
    if 'voice_id' in data and data['voice_id'] == '':
        characters['鐚'][name].pop('voice_id', None)
    
    # 鏇存柊鍏朵粬瀛楁
    for k, v in data.items():
        if k not in ('妗ｆ鍚?, 'voice_id') and v:
            characters['鐚'][name][k] = v
        elif k == 'voice_id' and v:  # voice_id闈炵┖鏃舵墠鏇存柊
            characters['鐚'][name][k] = v
    _config_manager.save_characters(characters)
    
    # 鑾峰彇鏇存柊鍚庣殑voice_id
    new_voice_id = characters['鐚'][name].get('voice_id', '')
    voice_id_changed = (old_voice_id != new_voice_id)
    
    # 濡傛灉鏄綋鍓嶆椿璺冪殑鐚涓攙oice_id鍙戠敓浜嗗彉鏇达紝闇€瑕佸厛閫氱煡鍓嶇锛屽啀鍏抽棴session
    is_current_catgirl = (name == characters.get('褰撳墠鐚', ''))
    session_ended = False
    
    if voice_id_changed and is_current_catgirl and name in session_manager:
        # 妫€鏌ユ槸鍚︽湁娲昏穬鐨剆ession
        if session_manager[name].is_active:
            logger.info(f"妫€娴嬪埌 {name} 鐨剉oice_id宸插彉鏇达紙{old_voice_id} -> {new_voice_id}锛夛紝鍑嗗鍒锋柊...")
            
            # 1. 鍏堝彂閫佸埛鏂版秷鎭紙WebSocket杩樿繛鐫€锛?            if session_manager[name].websocket:
                try:
                    await session_manager[name].websocket.send_text(json.dumps({
                        "type": "reload_page",
                        "message": "璇煶宸叉洿鏂帮紝椤甸潰鍗冲皢鍒锋柊"
                    }))
                    logger.info(f"宸查€氱煡 {name} 鐨勫墠绔埛鏂伴〉闈?)
                except Exception as e:
                    logger.warning(f"閫氱煡鍓嶇鍒锋柊椤甸潰澶辫触: {e}")
            
            # 2. 绔嬪埢鍏抽棴session锛堣繖浼氭柇寮€WebSocket锛?            try:
                await session_manager[name].end_session(by_server=True)
                session_ended = True
                logger.info(f"{name} 鐨剆ession宸茬粨鏉?)
            except Exception as e:
                logger.error(f"缁撴潫session鏃跺嚭閿? {e}")
    
    # 鏂规3锛氭潯浠舵€ч噸鏂板姞杞?- 鍙湁褰撳墠鐚鎴杤oice_id鍙樻洿鏃舵墠閲嶆柊鍔犺浇閰嶇疆
    if voice_id_changed and is_current_catgirl:
        # 鑷姩閲嶆柊鍔犺浇閰嶇疆
        await initialize_character_data()
        logger.info(f"閰嶇疆宸查噸鏂板姞杞斤紝鏂扮殑voice_id宸茬敓鏁?)
    elif voice_id_changed and not is_current_catgirl:
        # 涓嶆槸褰撳墠鐚锛岃烦杩囬噸鏂板姞杞斤紝閬垮厤褰卞搷褰撳墠鐚鐨剆ession
        logger.info(f"鍒囨崲鐨勬槸鍏朵粬鐚 {name} 鐨勯煶鑹诧紝璺宠繃閲嶆柊鍔犺浇浠ラ伩鍏嶅奖鍝嶅綋鍓嶇尗濞樼殑session")
    
    return {"success": True, "voice_id_changed": voice_id_changed, "session_restarted": session_ended}

@app.put('/api/characters/catgirl/l2d/{name}')
async def update_catgirl_l2d(name: str, request: Request):
    """鏇存柊鎸囧畾鐚鐨凩ive2D妯″瀷璁剧疆"""
    try:
        data = await request.json()
        live2d_model = data.get('live2d')
        item_id = data.get('item_id')  # 鑾峰彇鍙€夌殑item_id
        
        if not live2d_model:
            return JSONResponse(content={
                'success': False,
                'error': '鏈彁渚汱ive2D妯″瀷鍚嶇О'
            })
        
        # 鍔犺浇褰撳墠瑙掕壊閰嶇疆
        characters = _config_manager.load_characters()
        
        # 纭繚鐚閰嶇疆瀛樺湪
        if '鐚' not in characters:
            characters['鐚'] = {}
        
        # 纭繚鎸囧畾鐚鐨勯厤缃瓨鍦?        if name not in characters['鐚']:
            characters['鐚'][name] = {}
        
        # 鏇存柊Live2D妯″瀷璁剧疆锛屽悓鏃朵繚瀛榠tem_id锛堝鏋滄湁锛?        characters['鐚'][name]['live2d'] = live2d_model
        if item_id:
            characters['鐚'][name]['live2d_item_id'] = item_id
            logger.debug(f"宸蹭繚瀛樿鑹?{name} 鐨勬ā鍨?{live2d_model} 鍜宨tem_id {item_id}")
        else:
            logger.debug(f"宸蹭繚瀛樿鑹?{name} 鐨勬ā鍨?{live2d_model}")
        
        # 淇濆瓨閰嶇疆
        _config_manager.save_characters(characters)
        # 鑷姩閲嶆柊鍔犺浇閰嶇疆
        await initialize_character_data()
        
        return JSONResponse(content={
            'success': True,
            'message': f'宸叉洿鏂拌鑹?{name} 鐨凩ive2D妯″瀷涓?{live2d_model}'
        })
        
    except Exception as e:
        logger.error(f"鏇存柊瑙掕壊Live2D妯″瀷澶辫触: {e}")
        return JSONResponse(content={
            'success': False,
            'error': str(e)
        })

@app.put('/api/characters/catgirl/voice_id/{name}')
async def update_catgirl_voice_id(name: str, request: Request):
    data = await request.json()
    if not data:
        return JSONResponse({'success': False, 'error': '鏃犳暟鎹?}, status_code=400)
    characters = _config_manager.load_characters()
    if name not in characters.get('鐚', {}):
        return JSONResponse({'success': False, 'error': '鐚涓嶅瓨鍦?}, status_code=404)
    if 'voice_id' in data:
        voice_id = data['voice_id']
        # 楠岃瘉voice_id鏄惁鍦╲oice_storage涓?        if not _config_manager.validate_voice_id(voice_id):
            voices = _config_manager.get_voices_for_current_api()
            available_voices = list(voices.keys())
            return JSONResponse({
                'success': False, 
                'error': f'voice_id "{voice_id}" 鍦ㄥ綋鍓岮PI鐨勯煶鑹插簱涓笉瀛樺湪',
                'available_voices': available_voices
            }, status_code=400)
        characters['鐚'][name]['voice_id'] = voice_id
    _config_manager.save_characters(characters)
    
    # 濡傛灉鏄綋鍓嶆椿璺冪殑鐚锛岄渶瑕佸厛閫氱煡鍓嶇锛屽啀鍏抽棴session
    is_current_catgirl = (name == characters.get('褰撳墠鐚', ''))
    session_ended = False
    
    if is_current_catgirl and name in session_manager:
        # 妫€鏌ユ槸鍚︽湁娲昏穬鐨剆ession
        if session_manager[name].is_active:
            logger.info(f"妫€娴嬪埌 {name} 鐨剉oice_id宸叉洿鏂帮紝鍑嗗鍒锋柊...")
            
            # 1. 鍏堝彂閫佸埛鏂版秷鎭紙WebSocket杩樿繛鐫€锛?            if session_manager[name].websocket:
                try:
                    await session_manager[name].websocket.send_text(json.dumps({
                        "type": "reload_page",
                        "message": "璇煶宸叉洿鏂帮紝椤甸潰鍗冲皢鍒锋柊"
                    }))
                    logger.info(f"宸查€氱煡 {name} 鐨勫墠绔埛鏂伴〉闈?)
                except Exception as e:
                    logger.warning(f"閫氱煡鍓嶇鍒锋柊椤甸潰澶辫触: {e}")
            
            # 2. 绔嬪埢鍏抽棴session锛堣繖浼氭柇寮€WebSocket锛?            try:
                await session_manager[name].end_session(by_server=True)
                session_ended = True
                logger.info(f"{name} 鐨剆ession宸茬粨鏉?)
            except Exception as e:
                logger.error(f"缁撴潫session鏃跺嚭閿? {e}")
    
    # 鏂规3锛氭潯浠舵€ч噸鏂板姞杞?- 鍙湁褰撳墠鐚鎵嶉噸鏂板姞杞介厤缃?    if is_current_catgirl:
        # 3. 閲嶆柊鍔犺浇閰嶇疆锛岃鏂扮殑voice_id鐢熸晥
        await initialize_character_data()
        logger.info(f"閰嶇疆宸查噸鏂板姞杞斤紝鏂扮殑voice_id宸茬敓鏁?)
    else:
        # 涓嶆槸褰撳墠鐚锛岃烦杩囬噸鏂板姞杞斤紝閬垮厤褰卞搷褰撳墠鐚鐨剆ession
        logger.info(f"鍒囨崲鐨勬槸鍏朵粬鐚 {name} 鐨勯煶鑹诧紝璺宠繃閲嶆柊鍔犺浇浠ラ伩鍏嶅奖鍝嶅綋鍓嶇尗濞樼殑session")
    
    return {"success": True, "session_restarted": session_ended}

@app.post('/api/characters/clear_voice_ids')
async def clear_voice_ids():
    """娓呴櫎鎵€鏈夎鑹茬殑鏈湴Voice ID璁板綍"""
    try:
        characters = _config_manager.load_characters()
        cleared_count = 0
        
        # 娓呴櫎鎵€鏈夌尗濞樼殑voice_id
        if '鐚' in characters:
            for name in characters['鐚']:
                if 'voice_id' in characters['鐚'][name] and characters['鐚'][name]['voice_id']:
                    characters['鐚'][name]['voice_id'] = ''
                    cleared_count += 1
        
        _config_manager.save_characters(characters)
        # 鑷姩閲嶆柊鍔犺浇閰嶇疆
        await initialize_character_data()
        
        return JSONResponse({
            'success': True, 
            'message': f'宸叉竻闄?{cleared_count} 涓鑹茬殑Voice ID璁板綍',
            'cleared_count': cleared_count
        })
    except Exception as e:
        return JSONResponse({
            'success': False, 
            'error': f'娓呴櫎Voice ID璁板綍鏃跺嚭閿? {str(e)}'
        }, status_code=500)

@app.post('/api/characters/set_microphone')
async def set_microphone(request: Request):
    try:
        data = await request.json()
        microphone_id = data.get('microphone_id')
        
        # 浣跨敤鏍囧噯鐨刲oad/save鍑芥暟
        characters_data = _config_manager.load_characters()
        
        # 娣诲姞鎴栨洿鏂伴害鍏嬮閫夋嫨
        characters_data['褰撳墠楹﹀厠椋?] = microphone_id
        
        # 淇濆瓨閰嶇疆
        _config_manager.save_characters(characters_data)
        # 鑷姩閲嶆柊鍔犺浇閰嶇疆
        await initialize_character_data()
        
        return {"success": True}
    except Exception as e:
        logger.error(f"淇濆瓨楹﹀厠椋庨€夋嫨澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.get('/api/characters/get_microphone')
async def get_microphone():
    try:
        # 浣跨敤閰嶇疆绠＄悊鍣ㄥ姞杞借鑹查厤缃?        characters_data = _config_manager.load_characters()
        
        # 鑾峰彇淇濆瓨鐨勯害鍏嬮閫夋嫨
        microphone_id = characters_data.get('褰撳墠楹﹀厠椋?)
        
        return {"microphone_id": microphone_id}
    except Exception as e:
        logger.error(f"鑾峰彇楹﹀厠椋庨€夋嫨澶辫触: {e}")
        return {"microphone_id": None}

@app.post('/api/voice_clone')
async def voice_clone(file: UploadFile = File(...), prefix: str = Form(...)):
    # 鐩存帴璇诲彇鍒板唴瀛?    try:
        file_content = await file.read()
        file_buffer = io.BytesIO(file_content)
    except Exception as e:
        logger.error(f"璇诲彇鏂囦欢鍒板唴瀛樺け璐? {e}")
        return JSONResponse({'error': f'璇诲彇鏂囦欢澶辫触: {e}'}, status_code=500)


    def validate_audio_file(file_buffer: io.BytesIO, filename: str) -> tuple[str, str]:
        """
        楠岃瘉闊抽鏂囦欢绫诲瀷鍜屾牸寮?        杩斿洖: (mime_type, error_message)
        """
        file_path_obj = pathlib.Path(filename)
        file_extension = file_path_obj.suffix.lower()
        
        # 妫€鏌ユ枃浠舵墿灞曞悕
        if file_extension not in ['.wav', '.mp3', '.m4a']:
            return "", f"涓嶆敮鎸佺殑鏂囦欢鏍煎紡: {file_extension}銆備粎鏀寔 WAV銆丮P3 鍜?M4A 鏍煎紡銆?
        
        # 鏍规嵁鎵╁睍鍚嶇‘瀹歁IME绫诲瀷
        if file_extension == '.wav':
            mime_type = "audio/wav"
            # 妫€鏌AV鏂囦欢鏄惁涓?6bit
            try:
                file_buffer.seek(0)
                with wave.open(file_buffer, 'rb') as wav_file:
                    # 妫€鏌ラ噰鏍峰搴︼紙bit depth锛?                    if wav_file.getsampwidth() != 2:  # 2 bytes = 16 bits
                        return "", f"WAV鏂囦欢蹇呴』鏄?6bit鏍煎紡锛屽綋鍓嶆枃浠舵槸{wav_file.getsampwidth() * 8}bit銆?
                    
                    # 妫€鏌ュ０閬撴暟锛堝缓璁崟澹伴亾锛?                    channels = wav_file.getnchannels()
                    if channels > 1:
                        return "", f"寤鸿浣跨敤鍗曞０閬揥AV鏂囦欢锛屽綋鍓嶆枃浠舵湁{channels}涓０閬撱€?
                    
                    # 妫€鏌ラ噰鏍风巼
                    sample_rate = wav_file.getframerate()
                    if sample_rate not in [8000, 16000, 22050, 44100, 48000]:
                        return "", f"寤鸿浣跨敤鏍囧噯閲囨牱鐜?8000, 16000, 22050, 44100, 48000)锛屽綋鍓嶆枃浠堕噰鏍风巼: {sample_rate}Hz銆?
                file_buffer.seek(0)
            except Exception as e:
                return "", f"WAV鏂囦欢鏍煎紡閿欒: {str(e)}銆傝纭鎮ㄧ殑鏂囦欢鏄悎娉曠殑WAV鏂囦欢銆?
                
        elif file_extension == '.mp3':
            mime_type = "audio/mpeg"
            try:
                file_buffer.seek(0)
                # 璇诲彇鏇村瀛楄妭浠ユ敮鎸佷笉鍚岀殑MP3鏍煎紡
                header = file_buffer.read(32)
                file_buffer.seek(0)

                # 妫€鏌ユ枃浠跺ぇ灏忔槸鍚﹀悎鐞?                file_size = len(file_buffer.getvalue())
                if file_size < 1024:  # 鑷冲皯1KB
                    return "", "MP3鏂囦欢澶皬锛屽彲鑳戒笉鏄湁鏁堢殑闊抽鏂囦欢銆?
                if file_size > 1024 * 1024 * 10:  # 10MB
                    return "", "MP3鏂囦欢澶ぇ锛屽彲鑳戒笉鏄湁鏁堢殑闊抽鏂囦欢銆?
                
                # 鏇村鏉剧殑MP3鏂囦欢澶存鏌?                # MP3鏂囦欢閫氬父浠D3鏍囩鎴栧抚鍚屾瀛楀紑澶?                # 妫€鏌ユ槸鍚︿互ID3鏍囩寮€澶?(ID3v2)
                has_id3_header = header.startswith(b'ID3')
                # 妫€鏌ユ槸鍚︽湁甯у悓姝ュ瓧 (FF FA, FF FB, FF F2, FF F3, FF E3绛?
                has_frame_sync = False
                for i in range(len(header) - 1):
                    if header[i] == 0xFF and (header[i+1] & 0xE0) == 0xE0:
                        has_frame_sync = True
                        break
                
                # 濡傛灉鏃㈡病鏈塈D3鏍囩涔熸病鏈夊抚鍚屾瀛楋紝鍒欒涓烘枃浠跺彲鑳芥棤鏁?                # 浣嗚繖鍙槸涓€涓鍛婏紝涓嶅簲璇ヤ弗鏍兼嫆缁?                if not has_id3_header and not has_frame_sync:
                    return mime_type, "璀﹀憡: MP3鏂囦欢鍙兘鏍煎紡涓嶆爣鍑嗭紝鏂囦欢澶? {header[:4].hex()}"
                        
            except Exception as e:
                return "", f"MP3鏂囦欢璇诲彇閿欒: {str(e)}銆傝纭鎮ㄧ殑鏂囦欢鏄悎娉曠殑MP3鏂囦欢銆?
                
        elif file_extension == '.m4a':
            mime_type = "audio/mp4"
            try:
                file_buffer.seek(0)
                # 璇诲彇鏂囦欢澶存潵楠岃瘉M4A鏍煎紡
                header = file_buffer.read(32)
                file_buffer.seek(0)
                
                # M4A鏂囦欢搴旇浠?ftyp'鐩掑瓙寮€濮嬶紝閫氬父鍦ㄥ亸绉?瀛楄妭澶?                # 妫€鏌ユ槸鍚﹀寘鍚?ftyp'鏍囪瘑
                if b'ftyp' not in header:
                    return "", "M4A鏂囦欢鏍煎紡鏃犳晥鎴栧凡鎹熷潖銆傝纭鎮ㄧ殑鏂囦欢鏄悎娉曠殑M4A鏂囦欢銆?
                
                # 杩涗竴姝ラ獙璇侊細妫€鏌ユ槸鍚﹀寘鍚父瑙佺殑M4A绫诲瀷鏍囪瘑
                # M4A閫氬父鍖呭惈'mp4a', 'M4A ', 'M4V '绛夌被鍨?                valid_types = [b'mp4a', b'M4A ', b'M4V ', b'isom', b'iso2', b'avc1']
                has_valid_type = any(t in header for t in valid_types)
                
                if not has_valid_type:
                    return mime_type,  "璀﹀憡: M4A鏂囦欢鏍煎紡鏃犳晥鎴栧凡鎹熷潖銆傝纭鎮ㄧ殑鏂囦欢鏄悎娉曠殑M4A鏂囦欢銆?
                        
            except Exception as e:
                return "", f"M4A鏂囦欢璇诲彇閿欒: {str(e)}銆傝纭鎮ㄧ殑鏂囦欢鏄悎娉曠殑M4A鏂囦欢銆?
        
        return mime_type, ""

    try:
        # 1. 楠岃瘉闊抽鏂囦欢
        mime_type, error_msg = validate_audio_file(file_buffer, file.filename)
        if not mime_type:
            return JSONResponse({'error': error_msg}, status_code=400)
        
        # 妫€鏌ユ枃浠跺ぇ灏忥紙tfLink鏀寔鏈€澶?00MB锛?        file_size = len(file_content)
        if file_size > 100 * 1024 * 1024:  # 100MB
            return JSONResponse({'error': '鏂囦欢澶у皬瓒呰繃100MB锛岃秴杩噒fLink鐨勯檺鍒?}, status_code=400)
        
        # 2. 涓婁紶鍒?tfLink - 鐩存帴浣跨敤鍐呭瓨涓殑鍐呭
        file_buffer.seek(0)
        # 鏍规嵁tfLink API鏂囨。锛屼娇鐢╩ultipart/form-data涓婁紶鏂囦欢
        # 鍙傛暟鍚嶅簲涓?file'
        files = {'file': (file.filename, file_buffer, mime_type)}
        
        # 娣诲姞鏇村鐨勮姹傚ご锛岀‘淇濆吋瀹规€?        headers = {
            'Accept': 'application/json'
        }
        
        logger.info(f"姝ｅ湪涓婁紶鏂囦欢鍒皌fLink锛屾枃浠跺悕: {file.filename}, 澶у皬: {file_size} bytes, MIME绫诲瀷: {mime_type}")
        async with httpx.AsyncClient(timeout=60) as client:
            resp = await client.post('http://47.101.214.205:8000/api/upload', files=files, headers=headers)

            # 妫€鏌ュ搷搴旂姸鎬?            if resp.status_code != 200:
                logger.error(f"涓婁紶鍒皌fLink澶辫触锛岀姸鎬佺爜: {resp.status_code}, 鍝嶅簲鍐呭: {resp.text}")
                return JSONResponse({'error': f'涓婁紶鍒皌fLink澶辫触锛岀姸鎬佺爜: {resp.status_code}, 璇︽儏: {resp.text[:200]}'}, status_code=500)
            
            try:
                # 瑙ｆ瀽JSON鍝嶅簲
                data = resp.json()
                logger.info(f"tfLink鍘熷鍝嶅簲: {data}")
                
                # 鑾峰彇涓嬭浇閾炬帴
                tmp_url = None
                possible_keys = ['downloadLink', 'download_link', 'url', 'direct_link', 'link', 'download_url']
                for key in possible_keys:
                    if key in data:
                        tmp_url = data[key]
                        logger.info(f"鎵惧埌涓嬭浇閾炬帴閿? {key}")
                        break
                
                if not tmp_url:
                    logger.error(f"鏃犳硶浠庡搷搴斾腑鎻愬彇URL: {data}")
                    return JSONResponse({'error': f'涓婁紶鎴愬姛浣嗘棤娉曚粠鍝嶅簲涓彁鍙朥RL'}, status_code=500)
                
                # 纭繚URL鏈夋晥
                if not tmp_url.startswith(('http://', 'https://')):
                    logger.error(f"鏃犳晥鐨刄RL鏍煎紡: {tmp_url}")
                    return JSONResponse({'error': f'鏃犳晥鐨刄RL鏍煎紡: {tmp_url}'}, status_code=500)
                    
                # 娴嬭瘯URL鏄惁鍙闂?                test_resp = await client.head(tmp_url, timeout=10)
                if test_resp.status_code >= 400:
                    logger.error(f"鐢熸垚鐨刄RL鏃犳硶璁块棶: {tmp_url}, 鐘舵€佺爜: {test_resp.status_code}")
                    return JSONResponse({'error': f'鐢熸垚鐨勪复鏃禪RL鏃犳硶璁块棶锛岃閲嶈瘯'}, status_code=500)
                    
                logger.info(f"鎴愬姛鑾峰彇涓存椂URL骞堕獙璇佸彲璁块棶鎬? {tmp_url}")
                
            except ValueError:
                raw_text = resp.text
                logger.error(f"涓婁紶鎴愬姛浣嗗搷搴旀牸寮忔棤娉曡В鏋? {raw_text}")
                return JSONResponse({'error': f'涓婁紶鎴愬姛浣嗗搷搴旀牸寮忔棤娉曡В鏋? {raw_text[:200]}'}, status_code=500)
        
        # 3. 鐢ㄧ洿閾炬敞鍐岄煶鑹?        # 浣跨敤 get_model_api_config('tts_custom') 鑾峰彇姝ｇ‘鐨?API 閰嶇疆
        # tts_custom 浼氫紭鍏堜娇鐢ㄨ嚜瀹氫箟 TTS API锛屽叾娆℃槸 Qwen Cosyvoice API锛堢洰鍓嶅敮涓€鏀寔 voice clone 鐨勬湇鍔★級
        tts_config = _config_manager.get_model_api_config('tts_custom')
        audio_api_key = tts_config.get('api_key', '')
        
        if not audio_api_key:
            logger.error("鏈厤缃?AUDIO_API_KEY")
            return JSONResponse({
                'error': '鏈厤缃煶棰慉PI瀵嗛挜锛岃鍦ㄨ缃腑閰嶇疆AUDIO_API_KEY',
                'suggestion': '璇峰墠寰€璁剧疆椤甸潰閰嶇疆闊抽API瀵嗛挜'
            }, status_code=400)
        
        dashscope.api_key = audio_api_key
        service = VoiceEnrollmentService()
        target_model = "cosyvoice-v3-plus"
        
        # 閲嶈瘯閰嶇疆
        max_retries = 3
        retry_delay = 3  # 閲嶈瘯鍓嶇瓑寰呯殑绉掓暟
        
        for attempt in range(max_retries):
            try:
                logger.info(f"寮€濮嬮煶鑹叉敞鍐岋紙灏濊瘯 {attempt + 1}/{max_retries}锛夛紝浣跨敤URL: {tmp_url}")
                
                # 灏濊瘯鎵ц闊宠壊娉ㄥ唽
                voice_id = service.create_voice(target_model=target_model, prefix=prefix, url=tmp_url)
                    
                logger.info(f"闊宠壊娉ㄥ唽鎴愬姛锛寁oice_id: {voice_id}")
                voice_data = {
                    'voice_id': voice_id,
                    'prefix': prefix,
                    'file_url': tmp_url,
                    'created_at': datetime.now().isoformat()
                }
                try:
                    _config_manager.save_voice_for_current_api(voice_id, voice_data)
                    logger.info(f"voice_id宸蹭繚瀛樺埌闊宠壊搴? {voice_id}")
                    
                    # 楠岃瘉voice_id鏄惁鑳藉琚纭鍙栵紙娣诲姞鐭殏寤惰繜锛岄伩鍏嶆枃浠剁郴缁熷欢杩燂級
                    await asyncio.sleep(0.1)  # 绛夊緟100ms锛岀‘淇濇枃浠跺啓鍏ュ畬鎴?                    
                    # 鏈€澶氶獙璇?娆★紝姣忔闂撮殧100ms
                    validation_success = False
                    for validation_attempt in range(3):
                        if _config_manager.validate_voice_id(voice_id):
                            validation_success = True
                            logger.info(f"voice_id淇濆瓨楠岃瘉鎴愬姛: {voice_id} (灏濊瘯 {validation_attempt + 1})")
                            break
                        if validation_attempt < 2:
                            await asyncio.sleep(0.1)
                    
                    if not validation_success:
                        logger.warning(f"voice_id淇濆瓨鍚庨獙璇佸け璐ワ紝浣嗗彲鑳藉凡鎴愬姛淇濆瓨: {voice_id}")
                        # 涓嶈繑鍥為敊璇紝鍥犱负淇濆瓨鍙兘宸叉垚鍔燂紝鍙槸楠岃瘉澶辫触
                        # 缁х画杩斿洖鎴愬姛锛岃鐢ㄦ埛灏濊瘯浣跨敤
                    
                except Exception as save_error:
                    logger.error(f"淇濆瓨voice_id鍒伴煶鑹插簱澶辫触: {save_error}")
                    return JSONResponse({
                        'error': f'闊宠壊娉ㄥ唽鎴愬姛浣嗕繚瀛樺埌闊宠壊搴撳け璐? {str(save_error)}',
                        'voice_id': voice_id,
                        'file_url': tmp_url
                    }, status_code=500)
                    
                return JSONResponse({
                    'voice_id': voice_id,
                    'request_id': service.get_last_request_id(),
                    'file_url': tmp_url,
                    'message': '闊宠壊娉ㄥ唽鎴愬姛骞跺凡淇濆瓨鍒伴煶鑹插簱'
                })
                
            except Exception as e:
                logger.error(f"闊宠壊娉ㄥ唽澶辫触锛堝皾璇?{attempt + 1}/{max_retries}锛? {str(e)}")
                error_detail = str(e)
                
                # 妫€鏌ユ槸鍚︽槸瓒呮椂閿欒
                is_timeout = ("ResponseTimeout" in error_detail or 
                             "response timeout" in error_detail.lower() or
                             "timeout" in error_detail.lower())
                
                # 妫€鏌ユ槸鍚︽槸鏂囦欢涓嬭浇澶辫触閿欒
                is_download_failed = ("download audio failed" in error_detail or 
                                     "415" in error_detail)
                
                # 濡傛灉鏄秴鏃舵垨涓嬭浇澶辫触锛屼笖杩樻湁閲嶈瘯鏈轰細锛屽垯閲嶈瘯
                if (is_timeout or is_download_failed) and attempt < max_retries - 1:
                    logger.warning(f"妫€娴嬪埌{'瓒呮椂' if is_timeout else '鏂囦欢涓嬭浇澶辫触'}閿欒锛岀瓑寰?{retry_delay} 绉掑悗閲嶈瘯...")
                    await asyncio.sleep(retry_delay)
                    continue  # 閲嶈瘯
                
                # 濡傛灉鏄渶鍚庝竴娆″皾璇曟垨闈炲彲閲嶈瘯閿欒锛岃繑鍥為敊璇?                if is_timeout:
                    return JSONResponse({
                        'error': f'闊宠壊娉ㄥ唽瓒呮椂锛屽凡灏濊瘯{max_retries}娆?,
                        'detail': error_detail,
                        'file_url': tmp_url,
                        'suggestion': '璇锋鏌ユ偍鐨勭綉缁滆繛鎺ワ紝鎴栫◢鍚庡啀璇曘€傚鏋滈棶棰樻寔缁紝鍙兘鏄湇鍔″櫒绻佸繖銆?
                    }, status_code=408)
                elif is_download_failed:
                    return JSONResponse({
                        'error': f'闊宠壊娉ㄥ唽澶辫触: 鏃犳硶涓嬭浇闊抽鏂囦欢锛屽凡灏濊瘯{max_retries}娆?,
                        'detail': error_detail,
                        'file_url': tmp_url,
                        'suggestion': '璇锋鏌ユ枃浠禪RL鏄惁鍙闂紝鎴栫◢鍚庨噸璇?
                    }, status_code=415)
                else:
                    # 鍏朵粬閿欒鐩存帴杩斿洖
                    return JSONResponse({
                        'error': f'闊宠壊娉ㄥ唽澶辫触: {error_detail}',
                        'file_url': tmp_url,
                        'attempt': attempt + 1,
                        'max_retries': max_retries
                    }, status_code=500)
    except Exception as e:
        # 纭繚tmp_url鍦ㄥ嚭鐜板紓甯告椂涔熸湁瀹氫箟
        tmp_url = locals().get('tmp_url', '鏈幏鍙栧埌URL')
        logger.error(f"娉ㄥ唽闊宠壊鏃跺彂鐢熸湭棰勬湡鐨勯敊璇? {str(e)}")
        return JSONResponse({'error': f'娉ㄥ唽闊宠壊鏃跺彂鐢熼敊璇? {str(e)}', 'file_url': tmp_url}, status_code=500)

@app.get('/api/voices')
async def get_voices():
    """鑾峰彇褰撳墠API key瀵瑰簲鐨勬墍鏈夊凡娉ㄥ唽闊宠壊"""
    return {"voices": _config_manager.get_voices_for_current_api()}

@app.post('/api/voices')
async def register_voice(request: Request):
    """娉ㄥ唽鏂伴煶鑹?""
    try:
        data = await request.json()
        voice_id = data.get('voice_id')
        voice_data = data.get('voice_data')
        
        if not voice_id or not voice_data:
            return JSONResponse({
                'success': False,
                'error': '缂哄皯蹇呰鍙傛暟'
            }, status_code=400)
        
        # 鍑嗗闊宠壊鏁版嵁
        complete_voice_data = {
            **voice_data,
            'voice_id': voice_id,
            'created_at': datetime.now().isoformat()
        }
        
        try:
            _config_manager.save_voice_for_current_api(voice_id, complete_voice_data)
        except Exception as e:
            logger.warning(f"淇濆瓨闊宠壊閰嶇疆澶辫触: {e}")
            return JSONResponse({
                'success': False,
                'error': f'淇濆瓨闊宠壊閰嶇疆澶辫触: {str(e)}'
            }, status_code=500)
            
        return {"success": True, "message": "闊宠壊娉ㄥ唽鎴愬姛"}
    except Exception as e:
        return JSONResponse({
            'success': False,
            'error': str(e)
        }, status_code=500)

@app.delete('/api/characters/catgirl/{name}')
async def delete_catgirl(name: str):
    import shutil
    
    characters = _config_manager.load_characters()
    if name not in characters.get('鐚', {}):
        return JSONResponse({'success': False, 'error': '鐚涓嶅瓨鍦?}, status_code=404)
    
    # 妫€鏌ユ槸鍚︽槸褰撳墠姝ｅ湪浣跨敤鐨勭尗濞?    current_catgirl = characters.get('褰撳墠鐚', '')
    if name == current_catgirl:
        return JSONResponse({'success': False, 'error': '涓嶈兘鍒犻櫎褰撳墠姝ｅ湪浣跨敤鐨勭尗濞橈紒璇峰厛鍒囨崲鍒板叾浠栫尗濞樺悗鍐嶅垹闄ゃ€?}, status_code=400)
    
    # 鍒犻櫎瀵瑰簲鐨勮蹇嗘枃浠?    try:
        memory_paths = [_config_manager.memory_dir, _config_manager.project_memory_dir]
        files_to_delete = [
            f'semantic_memory_{name}',  # 璇箟璁板繂鐩綍
            f'time_indexed_{name}',     # 鏃堕棿绱㈠紩鏁版嵁搴撴枃浠?            f'settings_{name}.json',    # 璁剧疆鏂囦欢
            f'recent_{name}.json',      # 鏈€杩戣亰澶╄褰曟枃浠?        ]
        
        for base_dir in memory_paths:
            for file_name in files_to_delete:
                file_path = base_dir / file_name
                if file_path.exists():
                    try:
                        if file_path.is_dir():
                            shutil.rmtree(file_path)
                        else:
                            file_path.unlink()
                        logger.info(f"宸插垹闄? {file_path}")
                    except Exception as e:
                        logger.warning(f"鍒犻櫎澶辫触 {file_path}: {e}")
    except Exception as e:
        logger.error(f"鍒犻櫎璁板繂鏂囦欢鏃跺嚭閿? {e}")
    
    # 鍒犻櫎瑙掕壊閰嶇疆
    del characters['鐚'][name]
    _config_manager.save_characters(characters)
    await initialize_character_data()
    return {"success": True}

@app.post('/api/beacon/shutdown')
async def beacon_shutdown():
    """Beacon API for graceful server shutdown"""
    try:
        # 浠?app.state 鑾峰彇閰嶇疆
        current_config = get_start_config()
        # Only respond to beacon if server was started with --open-browser
        if current_config['browser_mode_enabled']:
            logger.info("鏀跺埌beacon淇″彿锛屽噯澶囧叧闂湇鍔″櫒...")
            # Schedule server shutdown
            asyncio.create_task(shutdown_server_async())
            return {"success": True, "message": "鏈嶅姟鍣ㄥ叧闂俊鍙峰凡鎺ユ敹"}
    except Exception as e:
        logger.error(f"Beacon澶勭悊閿欒: {e}")
        return {"success": False, "error": str(e)}

async def shutdown_server_async():
    """寮傛鍏抽棴鏈嶅姟鍣?""
    try:
        # Give a small delay to allow the beacon response to be sent
        await asyncio.sleep(0.5)
        logger.info("姝ｅ湪鍏抽棴鏈嶅姟鍣?..")
        
        # 鍚憁emory_server鍙戦€佸叧闂俊鍙?        try:
            from config import MEMORY_SERVER_PORT
            shutdown_url = f"http://localhost:{MEMORY_SERVER_PORT}/shutdown"
            async with httpx.AsyncClient(timeout=1) as client:
                response = await client.post(shutdown_url)
                if response.status_code == 200:
                    logger.info("宸插悜memory_server鍙戦€佸叧闂俊鍙?)
                else:
                    logger.warning(f"鍚憁emory_server鍙戦€佸叧闂俊鍙峰け璐ワ紝鐘舵€佺爜: {response.status_code}")
        except Exception as e:
            logger.warning(f"鍚憁emory_server鍙戦€佸叧闂俊鍙锋椂鍑洪敊: {e}")
        
        # Signal the server to stop
        current_config = get_start_config()
        if current_config['server'] is not None:
            current_config['server'].should_exit = True
    except Exception as e:
        logger.error(f"鍏抽棴鏈嶅姟鍣ㄦ椂鍑洪敊: {e}")

@app.post('/api/characters/catgirl/{old_name}/rename')
async def rename_catgirl(old_name: str, request: Request):
    data = await request.json()
    new_name = data.get('new_name') if data else None
    if not new_name:
        return JSONResponse({'success': False, 'error': '鏂版。妗堝悕涓嶈兘涓虹┖'}, status_code=400)
    characters = _config_manager.load_characters()
    if old_name not in characters.get('鐚', {}):
        return JSONResponse({'success': False, 'error': '鍘熺尗濞樹笉瀛樺湪'}, status_code=404)
    if new_name in characters['鐚']:
        return JSONResponse({'success': False, 'error': '鏂版。妗堝悕宸插瓨鍦?}, status_code=400)
    
    # 濡傛灉褰撳墠鐚鏄閲嶅懡鍚嶇殑鐚锛岄渶瑕佸厛淇濆瓨WebSocket杩炴帴骞跺彂閫侀€氱煡
    # 蹇呴』鍦?initialize_character_data() 涔嬪墠鍙戦€侊紝鍥犱负閭ｄ釜鍑芥暟浼氬垹闄ゆ棫鐨?session_manager 鏉＄洰
    is_current_catgirl = characters.get('褰撳墠鐚') == old_name
    
    # 妫€鏌ュ綋鍓嶈鑹叉槸鍚︽湁娲昏穬鐨勮闊硈ession
    if is_current_catgirl and old_name in session_manager:
        mgr = session_manager[old_name]
        if mgr.is_active:
            # 妫€鏌ユ槸鍚︽槸璇煶妯″紡锛堥€氳繃session绫诲瀷鍒ゆ柇锛?            from main_helper.omni_realtime_client import OmniRealtimeClient
            is_voice_mode = mgr.session and isinstance(mgr.session, OmniRealtimeClient)
            
            if is_voice_mode:
                return JSONResponse({
                    'success': False, 
                    'error': '璇煶鐘舵€佷笅鏃犳硶淇敼瑙掕壊鍚嶇О锛岃鍏堝仠姝㈣闊冲璇濆悗鍐嶄慨鏀?
                }, status_code=400)
    if is_current_catgirl:
        logger.info(f"寮€濮嬮€氱煡WebSocket瀹㈡埛绔細鐚浠?{old_name} 閲嶅懡鍚嶄负 {new_name}")
        message = json.dumps({
            "type": "catgirl_switched",
            "new_catgirl": new_name,
            "old_catgirl": old_name
        })
        # 鍦?initialize_character_data() 涔嬪墠鍙戦€佹秷鎭紝鍥犱负涔嬪悗鏃х殑 session_manager 浼氳鍒犻櫎
        if old_name in session_manager:
            ws = session_manager[old_name].websocket
            if ws:
                try:
                    await ws.send_text(message)
                    logger.info(f"宸插悜 {old_name} 鍙戦€侀噸鍛藉悕閫氱煡")
                except Exception as e:
                    logger.warning(f"鍙戦€侀噸鍛藉悕閫氱煡缁?{old_name} 澶辫触: {e}")
    
    # 閲嶅懡鍚?    characters['鐚'][new_name] = characters['鐚'].pop(old_name)
    # 濡傛灉褰撳墠鐚鏄閲嶅懡鍚嶇殑鐚锛屼篃闇€瑕佹洿鏂?    if is_current_catgirl:
        characters['褰撳墠鐚'] = new_name
    _config_manager.save_characters(characters)
    # 鑷姩閲嶆柊鍔犺浇閰嶇疆
    await initialize_character_data()
    
    return {"success": True}

@app.post('/api/characters/catgirl/{name}/unregister_voice')
async def unregister_voice(name: str):
    """瑙ｉ櫎鐚鐨勫０闊虫敞鍐?""
    try:
        characters = _config_manager.load_characters()
        if name not in characters.get('鐚', {}):
            return JSONResponse({'success': False, 'error': '鐚涓嶅瓨鍦?}, status_code=404)
        
        # 妫€鏌ユ槸鍚﹀凡鏈塿oice_id
        if not characters['鐚'][name].get('voice_id'):
            return JSONResponse({'success': False, 'error': '璇ョ尗濞樻湭娉ㄥ唽澹伴煶'}, status_code=400)
        
        # 鍒犻櫎voice_id瀛楁
        if 'voice_id' in characters['鐚'][name]:
            characters['鐚'][name].pop('voice_id')
        _config_manager.save_characters(characters)
        # 鑷姩閲嶆柊鍔犺浇閰嶇疆
        await initialize_character_data()
        
        logger.info(f"宸茶В闄ょ尗濞?'{name}' 鐨勫０闊虫敞鍐?)
        return {"success": True, "message": "澹伴煶娉ㄥ唽宸茶В闄?}
        
    except Exception as e:
        logger.error(f"瑙ｉ櫎澹伴煶娉ㄥ唽鏃跺嚭閿? {e}")
        return JSONResponse({'success': False, 'error': f'瑙ｉ櫎娉ㄥ唽澶辫触: {str(e)}'}, status_code=500)

@app.get('/api/memory/recent_files')
async def get_recent_files():
    """鑾峰彇 memory 鐩綍涓嬫墍鏈?recent*.json 鏂囦欢鍚嶅垪琛?""
    from utils.config_manager import get_config_manager
    cm = get_config_manager()
    files = glob.glob(str(cm.memory_dir / 'recent*.json'))
    file_names = [os.path.basename(f) for f in files]
    return {"files": file_names}

@app.get('/api/memory/review_config')
async def get_review_config():
    """鑾峰彇璁板繂鏁寸悊閰嶇疆"""
    try:
        from utils.config_manager import get_config_manager
        config_manager = get_config_manager()
        config_path = str(config_manager.get_config_path('core_config.json'))
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
                # 濡傛灉閰嶇疆涓病鏈夎繖涓敭锛岄粯璁よ繑鍥濼rue锛堝紑鍚級
                return {"enabled": config_data.get('recent_memory_auto_review', True)}
        else:
            # 濡傛灉閰嶇疆鏂囦欢涓嶅瓨鍦紝榛樿杩斿洖True锛堝紑鍚級
            return {"enabled": True}
    except Exception as e:
        logger.error(f"璇诲彇璁板繂鏁寸悊閰嶇疆澶辫触: {e}")
        return {"enabled": True}

@app.post('/api/memory/review_config')
async def update_review_config(request: Request):
    """鏇存柊璁板繂鏁寸悊閰嶇疆"""
    try:
        data = await request.json()
        enabled = data.get('enabled', True)
        
        from utils.config_manager import get_config_manager
        config_manager = get_config_manager()
        config_path = str(config_manager.get_config_path('core_config.json'))
        config_data = {}
        
        # 璇诲彇鐜版湁閰嶇疆
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
        
        # 鏇存柊閰嶇疆
        config_data['recent_memory_auto_review'] = enabled
        
        # 淇濆瓨閰嶇疆
        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(config_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"璁板繂鏁寸悊閰嶇疆宸叉洿鏂? enabled={enabled}")
        return {"success": True, "enabled": enabled}
    except Exception as e:
        logger.error(f"鏇存柊璁板繂鏁寸悊閰嶇疆澶辫触: {e}")
        return {"success": False, "error": str(e)}

@app.get('/api/memory/recent_file')
async def get_recent_file(filename: str):
    """鑾峰彇鎸囧畾 recent*.json 鏂囦欢鍐呭"""
    from utils.config_manager import get_config_manager
    cm = get_config_manager()
    file_path = str(cm.memory_dir / filename)
    if not (filename.startswith('recent') and filename.endswith('.json')):
        return JSONResponse({"success": False, "error": "鏂囦欢鍚嶄笉鍚堟硶"}, status_code=400)
    if not os.path.exists(file_path):
        return JSONResponse({"success": False, "error": "鏂囦欢涓嶅瓨鍦?}, status_code=404)
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    return {"content": content}

@app.get("/api/live2d/model_config/{model_name}")
async def get_model_config(model_name: str):
    """鑾峰彇鎸囧畾Live2D妯″瀷鐨刴odel3.json閰嶇疆"""
    try:
        # 鏌ユ壘妯″瀷鐩綍锛堝彲鑳藉湪static鎴栫敤鎴锋枃妗ｇ洰褰曪級
        model_dir, url_prefix = find_model_directory(model_name)
        if not os.path.exists(model_dir):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷鐩綍涓嶅瓨鍦?})
        
        # 鏌ユ壘.model3.json鏂囦欢
        model_json_path = None
        for file in os.listdir(model_dir):
            if file.endswith('.model3.json'):
                model_json_path = os.path.join(model_dir, file)
                break
        
        if not model_json_path or not os.path.exists(model_json_path):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷閰嶇疆鏂囦欢涓嶅瓨鍦?})
        
        with open(model_json_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)
        
        # 妫€鏌ュ苟鑷姩娣诲姞缂哄け鐨勯厤缃?        config_updated = False
        
        # 纭繚FileReferences瀛樺湪
        if 'FileReferences' not in config_data:
            config_data['FileReferences'] = {}
            config_updated = True
        
        # 纭繚Motions瀛樺湪
        if 'Motions' not in config_data['FileReferences']:
            config_data['FileReferences']['Motions'] = {}
            config_updated = True
        
        # 纭繚Expressions瀛樺湪
        if 'Expressions' not in config_data['FileReferences']:
            config_data['FileReferences']['Expressions'] = []
            config_updated = True
        
        # 濡傛灉閰嶇疆鏈夋洿鏂帮紝淇濆瓨鍒版枃浠?        if config_updated:
            with open(model_json_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, ensure_ascii=False, indent=4)
            logger.info(f"宸蹭负妯″瀷 {model_name} 鑷姩娣诲姞缂哄け鐨勯厤缃」")
            
        return {"success": True, "config": config_data}
    except Exception as e:
        logger.error(f"鑾峰彇妯″瀷閰嶇疆澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.post("/api/live2d/model_config/{model_name}")
async def update_model_config(model_name: str, request: Request):
    """鏇存柊鎸囧畾Live2D妯″瀷鐨刴odel3.json閰嶇疆"""
    try:
        data = await request.json()
        
        # 鏌ユ壘妯″瀷鐩綍锛堝彲鑳藉湪static鎴栫敤鎴锋枃妗ｇ洰褰曪級
        model_dir, url_prefix = find_model_directory(model_name)
        if not os.path.exists(model_dir):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷鐩綍涓嶅瓨鍦?})
        
        # 鏌ユ壘.model3.json鏂囦欢
        model_json_path = None
        for file in os.listdir(model_dir):
            if file.endswith('.model3.json'):
                model_json_path = os.path.join(model_dir, file)
                break
        
        if not model_json_path or not os.path.exists(model_json_path):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷閰嶇疆鏂囦欢涓嶅瓨鍦?})
        
        # 涓轰簡瀹夊叏锛屽彧鍏佽淇敼 Motions 鍜?Expressions
        with open(model_json_path, 'r', encoding='utf-8') as f:
            current_config = json.load(f)
            
        if 'FileReferences' in data and 'Motions' in data['FileReferences']:
            current_config['FileReferences']['Motions'] = data['FileReferences']['Motions']
            
        if 'FileReferences' in data and 'Expressions' in data['FileReferences']:
            current_config['FileReferences']['Expressions'] = data['FileReferences']['Expressions']

        with open(model_json_path, 'w', encoding='utf-8') as f:
            json.dump(current_config, f, ensure_ascii=False, indent=4) # 浣跨敤 indent=4 淇濇寔鏍煎紡
            
        return {"success": True, "message": "妯″瀷閰嶇疆宸叉洿鏂?}
    except Exception as e:
        logger.error(f"鏇存柊妯″瀷閰嶇疆澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.get('/api/live2d/model_files/{model_name}')
async def get_model_files(model_name: str):
    """鑾峰彇鎸囧畾Live2D妯″瀷鐨勫姩浣滃拰琛ㄦ儏鏂囦欢鍒楄〃"""
    try:
        # 鏌ユ壘妯″瀷鐩綍锛堝彲鑳藉湪static鎴栫敤鎴锋枃妗ｇ洰褰曪級
        model_dir, url_prefix = find_model_directory(model_name)
        
        if not os.path.exists(model_dir):
            return {"success": False, "error": f"妯″瀷 {model_name} 涓嶅瓨鍦?}
        
        motion_files = []
        expression_files = []
        
        # 閫掑綊鎼滅储鎵€鏈夊瓙鏂囦欢澶?        def search_files_recursive(directory, target_ext, result_list):
            """閫掑綊鎼滅储鎸囧畾鎵╁睍鍚嶇殑鏂囦欢"""
            try:
                for item in os.listdir(directory):
                    item_path = os.path.join(directory, item)
                    if os.path.isfile(item_path):
                        if item.endswith(target_ext):
                            # 璁＄畻鐩稿浜庢ā鍨嬫牴鐩綍鐨勮矾寰?                            relative_path = os.path.relpath(item_path, model_dir)
                            # 杞崲涓烘鏂滄潬鏍煎紡锛堣法骞冲彴鍏煎锛?                            relative_path = relative_path.replace('\\', '/')
                            result_list.append(relative_path)
                    elif os.path.isdir(item_path):
                        # 閫掑綊鎼滅储瀛愮洰褰?                        search_files_recursive(item_path, target_ext, result_list)
            except Exception as e:
                logger.warning(f"鎼滅储鐩綍 {directory} 鏃跺嚭閿? {e}")
        
        # 鎼滅储鍔ㄤ綔鏂囦欢
        search_files_recursive(model_dir, '.motion3.json', motion_files)
        
        # 鎼滅储琛ㄦ儏鏂囦欢
        search_files_recursive(model_dir, '.exp3.json', expression_files)
        
        logger.info(f"妯″瀷 {model_name} 鏂囦欢缁熻: {len(motion_files)} 涓姩浣滄枃浠? {len(expression_files)} 涓〃鎯呮枃浠?)
        return {
            "success": True, 
            "motion_files": motion_files,
            "expression_files": expression_files
        }
    except Exception as e:
        logger.error(f"鑾峰彇妯″瀷鏂囦欢鍒楄〃澶辫触: {e}")
        return {"success": False, "error": str(e)}

@app.get('/api/live2d/model_parameters/{model_name}')
async def get_model_parameters(model_name: str):
    """鑾峰彇鎸囧畾Live2D妯″瀷鐨勫弬鏁颁俊鎭紙浠?cdi3.json鏂囦欢锛?""
    try:
        # 鏌ユ壘妯″瀷鐩綍
        model_dir, url_prefix = find_model_directory(model_name)
        
        if not os.path.exists(model_dir):
            return {"success": False, "error": f"妯″瀷 {model_name} 涓嶅瓨鍦?}
        
        # 鏌ユ壘.cdi3.json鏂囦欢
        cdi3_file = None
        for file in os.listdir(model_dir):
            if file.endswith('.cdi3.json'):
                cdi3_file = os.path.join(model_dir, file)
                break
        
        if not cdi3_file or not os.path.exists(cdi3_file):
            return {"success": False, "error": "鏈壘鍒?cdi3.json鏂囦欢"}
        
        # 璇诲彇.cdi3.json鏂囦欢
        with open(cdi3_file, 'r', encoding='utf-8') as f:
            cdi3_data = json.load(f)
        
        # 鎻愬彇鍙傛暟淇℃伅
        parameters = []
        if 'Parameters' in cdi3_data and isinstance(cdi3_data['Parameters'], list):
            for param in cdi3_data['Parameters']:
                if isinstance(param, dict) and 'Id' in param:
                    parameters.append({
                        'id': param.get('Id'),
                        'groupId': param.get('GroupId', ''),
                        'name': param.get('Name', param.get('Id'))
                    })
        
        # 鎻愬彇鍙傛暟缁勪俊鎭?        parameter_groups = {}
        if 'ParameterGroups' in cdi3_data and isinstance(cdi3_data['ParameterGroups'], list):
            for group in cdi3_data['ParameterGroups']:
                if isinstance(group, dict) and 'Id' in group:
                    parameter_groups[group.get('Id')] = {
                        'id': group.get('Id'),
                        'name': group.get('Name', group.get('Id'))
                    }
        
        return {
            "success": True,
            "parameters": parameters,
            "parameter_groups": parameter_groups
        }
    except Exception as e:
        logger.error(f"鑾峰彇妯″瀷鍙傛暟淇℃伅澶辫触: {e}")
        return {"success": False, "error": str(e)}

@app.post('/api/live2d/save_model_parameters/{model_name}')
async def save_model_parameters(model_name: str, request: Request):
    """淇濆瓨妯″瀷鍙傛暟鍒版ā鍨嬬洰褰曠殑parameters.json鏂囦欢"""
    try:
        # 鏌ユ壘妯″瀷鐩綍
        model_dir, url_prefix = find_model_directory(model_name)
        
        if not os.path.exists(model_dir):
            return JSONResponse(status_code=404, content={"success": False, "error": f"妯″瀷 {model_name} 涓嶅瓨鍦?})
        
        # 鑾峰彇璇锋眰浣撲腑鐨勫弬鏁?        body = await request.json()
        parameters = body.get('parameters', {})
        
        if not isinstance(parameters, dict):
            return JSONResponse(status_code=400, content={"success": False, "error": "鍙傛暟鏍煎紡閿欒"})
        
        # 淇濆瓨鍒皃arameters.json鏂囦欢
        parameters_file = os.path.join(model_dir, 'parameters.json')
        with open(parameters_file, 'w', encoding='utf-8') as f:
            json.dump(parameters, f, indent=2, ensure_ascii=False)
        
        logger.info(f"宸蹭繚瀛樻ā鍨嬪弬鏁板埌: {parameters_file}, 鍙傛暟鏁伴噺: {len(parameters)}")
        return {"success": True, "message": "鍙傛暟淇濆瓨鎴愬姛"}
    except Exception as e:
        logger.error(f"淇濆瓨妯″瀷鍙傛暟澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.get('/api/live2d/load_model_parameters/{model_name}')
async def load_model_parameters(model_name: str):
    """浠庢ā鍨嬬洰褰曠殑parameters.json鏂囦欢鍔犺浇鍙傛暟"""
    try:
        # 鏌ユ壘妯″瀷鐩綍
        model_dir, url_prefix = find_model_directory(model_name)
        
        if not os.path.exists(model_dir):
            return {"success": False, "error": f"妯″瀷 {model_name} 涓嶅瓨鍦?}
        
        # 璇诲彇parameters.json鏂囦欢
        parameters_file = os.path.join(model_dir, 'parameters.json')
        
        if not os.path.exists(parameters_file):
            return {"success": True, "parameters": {}}  # 鏂囦欢涓嶅瓨鍦ㄦ椂杩斿洖绌哄弬鏁?        
        with open(parameters_file, 'r', encoding='utf-8') as f:
            parameters = json.load(f)
        
        if not isinstance(parameters, dict):
            return {"success": True, "parameters": {}}
        
        logger.info(f"宸插姞杞芥ā鍨嬪弬鏁颁粠: {parameters_file}, 鍙傛暟鏁伴噺: {len(parameters)}")
        return {"success": True, "parameters": parameters}
    except Exception as e:
        logger.error(f"鍔犺浇妯″瀷鍙傛暟澶辫触: {e}")
        return {"success": False, "error": str(e), "parameters": {}}

@app.get("/api/live2d/model_config_by_id/{model_id}")
async def get_model_config(model_id: str):
    """鑾峰彇鎸囧畾Live2D妯″瀷鐨刴odel3.json閰嶇疆"""
    try:
        # 鏌ユ壘妯″瀷鐩綍锛堝彲鑳藉湪static鎴栫敤鎴锋枃妗ｇ洰褰曪級
        model_dir, url_prefix = find_model_by_workshop_item_id(model_id)
        if not os.path.exists(model_dir):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷鐩綍涓嶅瓨鍦?})
        
        # 鏌ユ壘.model3.json鏂囦欢
        model_json_path = None
        for file in os.listdir(model_dir):
            if file.endswith('.model3.json'):
                model_json_path = os.path.join(model_dir, file)
                break
        
        if not model_json_path or not os.path.exists(model_json_path):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷閰嶇疆鏂囦欢涓嶅瓨鍦?})
        
        with open(model_json_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)
        
        # 妫€鏌ュ苟鑷姩娣诲姞缂哄け鐨勯厤缃?        config_updated = False
        
        # 纭繚FileReferences瀛樺湪
        if 'FileReferences' not in config_data:
            config_data['FileReferences'] = {}
            config_updated = True
        
        # 纭繚Motions瀛樺湪
        if 'Motions' not in config_data['FileReferences']:
            config_data['FileReferences']['Motions'] = {}
            config_updated = True
        
        # 纭繚Expressions瀛樺湪
        if 'Expressions' not in config_data['FileReferences']:
            config_data['FileReferences']['Expressions'] = []
            config_updated = True
        
        # 濡傛灉閰嶇疆鏈夋洿鏂帮紝淇濆瓨鍒版枃浠?        if config_updated:
            with open(model_json_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, ensure_ascii=False, indent=4)
            logger.info(f"宸蹭负妯″瀷 {model_id} 鑷姩娣诲姞缂哄け鐨勯厤缃」")
            
        return {"success": True, "config": config_data}
    except Exception as e:
        logger.error(f"鑾峰彇妯″瀷閰嶇疆澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.post("/api/live2d/model_config_by_id/{model_id}")
async def update_model_config(model_id: str, request: Request):
    """鏇存柊鎸囧畾Live2D妯″瀷鐨刴odel3.json閰嶇疆"""
    try:
        data = await request.json()
        
        # 鏌ユ壘妯″瀷鐩綍锛堝彲鑳藉湪static鎴栫敤鎴锋枃妗ｇ洰褰曪級
        model_dir, url_prefix = find_model_by_workshop_item_id(model_id)
        if not os.path.exists(model_dir):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷鐩綍涓嶅瓨鍦?})
        
        # 鏌ユ壘.model3.json鏂囦欢
        model_json_path = None
        for file in os.listdir(model_dir):
            if file.endswith('.model3.json'):
                model_json_path = os.path.join(model_dir, file)
                break
        
        if not model_json_path or not os.path.exists(model_json_path):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷閰嶇疆鏂囦欢涓嶅瓨鍦?})
        
        # 涓轰簡瀹夊叏锛屽彧鍏佽淇敼 Motions 鍜?Expressions
        with open(model_json_path, 'r', encoding='utf-8') as f:
            current_config = json.load(f)
            
        if 'FileReferences' in data and 'Motions' in data['FileReferences']:
            current_config['FileReferences']['Motions'] = data['FileReferences']['Motions']
            
        if 'FileReferences' in data and 'Expressions' in data['FileReferences']:
            current_config['FileReferences']['Expressions'] = data['FileReferences']['Expressions']

        with open(model_json_path, 'w', encoding='utf-8') as f:
            json.dump(current_config, f, ensure_ascii=False, indent=4) # 浣跨敤 indent=4 淇濇寔鏍煎紡
            
        return {"success": True, "message": "妯″瀷閰嶇疆宸叉洿鏂?}
    except Exception as e:
        logger.error(f"鏇存柊妯″瀷閰嶇疆澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.get('/api/live2d/model_files_by_id/{model_id}')
async def get_model_files_by_id(model_id: str):
    """鑾峰彇鎸囧畾Live2D妯″瀷鐨勫姩浣滃拰琛ㄦ儏鏂囦欢鍒楄〃"""
    try:
        # 鐩存帴鎷掔粷鏃犳晥鐨刴odel_id
        if not model_id or model_id.lower() == 'undefined':
            logger.warning("鎺ユ敹鍒版棤鏁堢殑model_id璇锋眰锛岃繑鍥炲け璐?)
            return {"success": False, "error": "鏃犳晥鐨勬ā鍨婭D"}
        
        # 灏濊瘯閫氳繃model_id鏌ユ壘妯″瀷
        model_dir = None
        url_prefix = None
        
        # 棣栧厛灏濊瘯閫氳繃workshop item_id鏌ユ壘
        try:
            model_dir, url_prefix = find_workshop_item_by_id(model_id)
            logger.debug(f"閫氳繃model_id {model_id} 鏌ユ壘妯″瀷鐩綍: {model_dir}")
        except Exception as e:
            logger.warning(f"閫氳繃model_id鏌ユ壘澶辫触: {e}")
        
        # 濡傛灉閫氳繃model_id鎵句笉鍒版湁鏁堢殑鐩綍锛屽皾璇曞皢model_id褰撲綔model_name鍥為€€鏌ユ壘
        if not model_dir or not os.path.exists(model_dir):
            logger.info(f"灏濊瘯灏?{model_id} 浣滀负妯″瀷鍚嶇О鍥為€€鏌ユ壘")
            try:
                model_dir, url_prefix = find_model_directory(model_id)
                logger.debug(f"浣滀负妯″瀷鍚嶇О鏌ユ壘鐨勭洰褰? {model_dir}")
            except Exception as e:
                logger.warning(f"浣滀负妯″瀷鍚嶇О鏌ユ壘澶辫触: {e}")
        
        # 娣诲姞棰濆鐨勯敊璇鏌?        if not model_dir:
            logger.error(f"鑾峰彇妯″瀷鐩綍澶辫触: 鐩綍璺緞涓虹┖")
            return {"success": False, "error": "鑾峰彇妯″瀷鐩綍澶辫触: 鏃犳晥鐨勮矾寰?}
            
        if not os.path.exists(model_dir):
            logger.warning(f"妯″瀷鐩綍涓嶅瓨鍦? {model_dir}")
            return {"success": False, "error": "妯″瀷涓嶅瓨鍦?}
        
        motion_files = []
        expression_files = []
        
        # 閫掑綊鎼滅储鎵€鏈夊瓙鏂囦欢澶?        def search_files_recursive(directory, target_ext, result_list):
            """閫掑綊鎼滅储鎸囧畾鎵╁睍鍚嶇殑鏂囦欢"""
            try:
                for item in os.listdir(directory):
                    item_path = os.path.join(directory, item)
                    if os.path.isfile(item_path):
                        if item.endswith(target_ext):
                            # 璁＄畻鐩稿浜庢ā鍨嬫牴鐩綍鐨勮矾寰?                            relative_path = os.path.relpath(item_path, model_dir)
                            # 杞崲涓烘鏂滄潬鏍煎紡锛堣法骞冲彴鍏煎锛?                            relative_path = relative_path.replace('\\', '/')
                            result_list.append(relative_path)
                    elif os.path.isdir(item_path):
                        # 閫掑綊鎼滅储瀛愮洰褰?                        search_files_recursive(item_path, target_ext, result_list)
            except Exception as e:
                logger.warning(f"鎼滅储鐩綍 {directory} 鏃跺嚭閿? {e}")
        
        # 鎼滅储鍔ㄤ綔鏂囦欢
        search_files_recursive(model_dir, '.motion3.json', motion_files)
        
        # 鎼滅储琛ㄦ儏鏂囦欢
        search_files_recursive(model_dir, '.exp3.json', expression_files)
        
        # 鏌ユ壘妯″瀷閰嶇疆鏂囦欢锛坢odel3.json锛?        model_config_file = None
        for file in os.listdir(model_dir):
            if file.endswith('.model3.json'):
                model_config_file = file
                break
        
        # 鏋勫缓妯″瀷閰嶇疆鏂囦欢鐨刄RL
        model_config_url = None
        if model_config_file and url_prefix:
            # 瀵逛簬workshop妯″瀷锛岄渶瑕佸湪URL涓寘鍚玦tem_id
            if url_prefix == '/workshop':
                model_config_url = f"{url_prefix}/{model_id}/{model_config_file}"
            else:
                model_config_url = f"{url_prefix}/{model_config_file}"
            logger.debug(f"涓烘ā鍨?{model_id} 鏋勫缓鐨勯厤缃甎RL: {model_config_url}")
        
        logger.info(f"鏂囦欢缁熻: {len(motion_files)} 涓姩浣滄枃浠? {len(expression_files)} 涓〃鎯呮枃浠?)
        return {
            "success": True, 
            "motion_files": motion_files,
            "expression_files": expression_files,
            "model_config_url": model_config_url
        }
    except Exception as e:
        logger.error(f"鑾峰彇妯″瀷鏂囦欢鍒楄〃澶辫触: {e}")
        return {"success": False, "error": str(e)}


# Steam 鍒涙剰宸ュ潑绠＄悊鐩稿叧API璺敱
# 纭繚杩欎釜璺敱琚纭敞鍐?if _IS_MAIN_PROCESS:
    logger.info('娉ㄥ唽Steam鍒涙剰宸ュ潑鎵弿API璺敱')
@app.post('/api/steam/workshop/local-items/scan')
async def scan_local_workshop_items(request: Request):
    try:
        logger.info('鎺ユ敹鍒版壂鎻忔湰鍦板垱鎰忓伐鍧婄墿鍝佺殑API璇锋眰')
        
        # 纭繚閰嶇疆宸插姞杞?        from utils.workshop_utils import load_workshop_config
        workshop_config_data = load_workshop_config()
        logger.info(f'鍒涙剰宸ュ潑閰嶇疆宸插姞杞? {workshop_config_data}')
        
        data = await request.json()
        logger.info(f'璇锋眰鏁版嵁: {data}')
        folder_path = data.get('folder_path')
        
        # 瀹夊叏妫€鏌ワ細濮嬬粓浣跨敤get_workshop_path()浣滀负鍩虹鐩綍
        base_workshop_folder = os.path.abspath(os.path.normpath(get_workshop_path()))
        
        # 濡傛灉娌℃湁鎻愪緵璺緞锛屼娇鐢ㄩ粯璁よ矾寰?        default_path_used = False
        if not folder_path:
            # 浼樺厛浣跨敤get_workshop_path()鍑芥暟鑾峰彇璺緞
            folder_path = base_workshop_folder
            default_path_used = True
            logger.info(f'鏈彁渚涙枃浠跺す璺緞锛屼娇鐢ㄩ粯璁よ矾寰? {folder_path}')
            # 纭繚榛樿鏂囦欢澶瑰瓨鍦?            ensure_workshop_folder_exists(folder_path)
        else:
            # 鐢ㄦ埛鎻愪緵浜嗚矾寰勶紝鏍囧噯鍖栧鐞?            folder_path = os.path.normpath(folder_path)
            
            # 濡傛灉鏄浉瀵硅矾寰勶紝鍩轰簬榛樿璺緞瑙ｆ瀽
            if not os.path.isabs(folder_path):
                folder_path = os.path.normpath(folder_path)
            
            logger.info(f'鐢ㄦ埛鎸囧畾璺緞: {folder_path}')
        
        logger.info(f'鏈€缁堜娇鐢ㄧ殑鏂囦欢澶硅矾寰? {folder_path}, 榛樿璺緞浣跨敤鐘舵€? {default_path_used}')
        
        if not os.path.exists(folder_path):
            logger.warning(f'鏂囦欢澶逛笉瀛樺湪: {folder_path}')
            return JSONResponse(content={"success": False, "error": f"鎸囧畾鐨勬枃浠跺す涓嶅瓨鍦? {folder_path}", "default_path_used": default_path_used}, status_code=404)
        
        if not os.path.isdir(folder_path):
            logger.warning(f'鎸囧畾鐨勮矾寰勪笉鏄枃浠跺す: {folder_path}')
            return JSONResponse(content={"success": False, "error": f"鎸囧畾鐨勮矾寰勪笉鏄枃浠跺す: {folder_path}", "default_path_used": default_path_used}, status_code=400)
        
        # 鎵弿鏈湴鍒涙剰宸ュ潑鐗╁搧
        local_items = []
        published_items = []
        item_id = 1
        
        # 鑾峰彇Steam涓嬭浇鐨剋orkshop璺緞锛岃繖涓矾寰勯渶瑕佽鎺掗櫎
        steam_workshop_path = get_workshop_path()
        
        # 閬嶅巻鏂囦欢澶癸紝鎵弿鎵€鏈夊瓙鏂囦欢澶?        for item_folder in os.listdir(folder_path):
            item_path = os.path.join(folder_path, item_folder)
            if os.path.isdir(item_path):
                    
                # 鎺掗櫎Steam涓嬭浇鐨勭墿鍝佺洰褰曪紙WORKSHOP_PATH锛?                if os.path.normpath(item_path) == os.path.normpath(steam_workshop_path):
                    logger.info(f"璺宠繃Steam涓嬭浇鐨剋orkshop鐩綍: {item_path}")
                    continue
                stat_info = os.stat(item_path)
                
                # 澶勭悊棰勮鍥捐矾寰勶紙濡傛灉鏈夛級
                preview_image = find_preview_image_in_folder(item_path)
                
                local_items.append({
                    "id": f"local_{item_id}",
                    "name": item_folder,
                    "path": item_path,  # 杩斿洖缁濆璺緞
                    "lastModified": stat_info.st_mtime,
                    "size": get_folder_size(item_path),
                    "tags": ["鏈湴鏂囦欢"],
                    "previewImage": preview_image  # 杩斿洖缁濆璺緞
                })
                item_id += 1
        
        logger.info(f"鎵弿瀹屾垚锛屾壘鍒?{len(local_items)} 涓湰鍦板垱鎰忓伐鍧婄墿鍝?)
        
        return JSONResponse(content={
            "success": True,
            "local_items": local_items,
            "published_items": published_items,
            "folder_path": folder_path,  # 杩斿洖缁濆璺緞
            "default_path_used": default_path_used
        })
        
    except Exception as e:
        logger.error(f"鎵弿鏈湴鍒涙剰宸ュ潑鐗╁搧澶辫触: {e}")
        return JSONResponse(content={"success": False, "error": str(e)}, status_code=500)

# 鑾峰彇鍒涙剰宸ュ潑閰嶇疆
@app.get('/api/steam/workshop/config')
async def get_workshop_config():
    try:
        from utils.workshop_utils import load_workshop_config
        workshop_config_data = load_workshop_config()
        return {"success": True, "config": workshop_config_data}
    except Exception as e:
        logger.error(f"鑾峰彇鍒涙剰宸ュ潑閰嶇疆澶辫触: {str(e)}")
        return {"success": False, "error": str(e)}

# 淇濆瓨鍒涙剰宸ュ潑閰嶇疆
@app.post('/api/steam/workshop/config')
async def save_workshop_config_api(config_data: dict):
    try:
        # 瀵煎叆涓巊et_workshop_config鐩稿悓璺緞鐨勫嚱鏁帮紝淇濇寔涓€鑷存€?        from utils.workshop_utils import load_workshop_config, save_workshop_config, ensure_workshop_folder_exists
        
        # 鍏堝姞杞界幇鏈夐厤缃紝閬垮厤浣跨敤鍏ㄥ眬鍙橀噺瀵艰嚧鐨勪笉涓€鑷撮棶棰?        workshop_config_data = load_workshop_config() or {}
        
        # 鏇存柊閰嶇疆
        if 'default_workshop_folder' in config_data:
            workshop_config_data['default_workshop_folder'] = config_data['default_workshop_folder']
        if 'auto_create_folder' in config_data:
            workshop_config_data['auto_create_folder'] = config_data['auto_create_folder']
        # 鏀寔鐢ㄦ埛mod璺緞閰嶇疆
        if 'user_mod_folder' in config_data:
            workshop_config_data['user_mod_folder'] = config_data['user_mod_folder']
        
        # 淇濆瓨閰嶇疆鍒版枃浠讹紝浼犻€掑畬鏁寸殑閰嶇疆鏁版嵁浣滀负鍙傛暟
        save_workshop_config(workshop_config_data)
        
        # 濡傛灉鍚敤浜嗚嚜鍔ㄥ垱寤烘枃浠跺す涓旀彁渚涗簡璺緞锛屽垯纭繚鏂囦欢澶瑰瓨鍦?        if workshop_config_data.get('auto_create_folder', True):
            # 浼樺厛浣跨敤user_mod_folder锛屽鏋滄病鏈夊垯浣跨敤default_workshop_folder
            folder_path = workshop_config_data.get('user_mod_folder') or workshop_config_data.get('default_workshop_folder')
            if folder_path:
                ensure_workshop_folder_exists(folder_path)
        
        return {"success": True, "config": workshop_config_data}
    except Exception as e:
        logger.error(f"淇濆瓨鍒涙剰宸ュ潑閰嶇疆澶辫触: {str(e)}")
        return {"success": False, "error": str(e)}

@app.get('/api/proxy-image')
async def proxy_image(image_path: str):
    """浠ｇ悊璁块棶鏈湴鍥剧墖鏂囦欢锛屾敮鎸佺粷瀵硅矾寰勫拰鐩稿璺緞锛岀壒鍒槸Steam鍒涙剰宸ュ潑鐩綍"""

    try:
        logger.info(f"浠ｇ悊鍥剧墖璇锋眰锛屽師濮嬭矾寰? {image_path}")
        
        # 瑙ｇ爜URL缂栫爜鐨勮矾寰勶紙澶勭悊鍙岄噸缂栫爜鎯呭喌锛?        decoded_path = unquote(image_path)
        # 鍐嶆瑙ｇ爜浠ュ鐞嗗彲鑳界殑鍙岄噸缂栫爜
        decoded_path = unquote(decoded_path)
        
        logger.info(f"瑙ｇ爜鍚庣殑璺緞: {decoded_path}")
        
        # 妫€鏌ユ槸鍚︽槸杩滅▼URL锛屽鏋滄槸鍒欑洿鎺ヨ繑鍥為敊璇紙鐩墠鍙敮鎸佹湰鍦版枃浠讹級
        if decoded_path.startswith(('http://', 'https://')):
            return JSONResponse(content={"success": False, "error": "鏆備笉鏀寔杩滅▼鍥剧墖URL"}, status_code=400)
        
        # 鑾峰彇鍩虹鐩綍鍜屽厑璁歌闂殑鐩綍鍒楄〃
        base_dir = _get_app_root()
        allowed_dirs = [
            os.path.realpath(os.path.join(base_dir, 'static')),
            os.path.realpath(os.path.join(base_dir, 'assets'))
        ]
        
        
        # 娣诲姞get_workshop_path()杩斿洖鐨勮矾寰勪綔涓哄厑璁哥洰褰曪紝鏀寔鐩稿璺緞瑙ｆ瀽
        try:
            workshop_base_dir = os.path.abspath(os.path.normpath(get_workshop_path()))
            if os.path.exists(workshop_base_dir):
                real_workshop_dir = os.path.realpath(workshop_base_dir)
                if real_workshop_dir not in allowed_dirs:
                    allowed_dirs.append(real_workshop_dir)
                    logger.info(f"娣诲姞鍏佽鐨勯粯璁ゅ垱鎰忓伐鍧婄洰褰? {real_workshop_dir}")
        except Exception as e:
            logger.warning(f"鏃犳硶娣诲姞榛樿鍒涙剰宸ュ潑鐩綍: {str(e)}")
        
        # 鍔ㄦ€佹坊鍔犺矾寰勫埌鍏佽鍒楄〃锛氬鏋滆姹傜殑璺緞鍖呭惈鍒涙剰宸ュ潑鐩稿叧鏍囪瘑锛屽垯鍏佽璁块棶
        try:
            # 妫€鏌ヨВ鐮佸悗鐨勮矾寰勬槸鍚﹀寘鍚垱鎰忓伐鍧婄浉鍏宠矾寰勬爣璇?            if ('steamapps\\workshop' in decoded_path.lower() or 
                'steamapps/workshop' in decoded_path.lower()):
                
                # 鑾峰彇鍒涙剰宸ュ潑鐖剁洰褰?                workshop_related_dir = None
                
                # 鏂规硶1锛氬鏋滆矾寰勫瓨鍦紝鑾峰彇鏂囦欢鎵€鍦ㄧ洰褰曟垨鐩存帴浣跨敤鐩綍璺緞
                if os.path.exists(decoded_path):
                    if os.path.isfile(decoded_path):
                        workshop_related_dir = os.path.dirname(decoded_path)
                    else:
                        workshop_related_dir = decoded_path
                else:
                    # 鏂规硶2锛氬皾璇曚粠璺緞涓彁鍙栧垱鎰忓伐鍧婄浉鍏抽儴鍒?                    import re
                    match = re.search(r'(.*?steamapps[/\\]workshop)', decoded_path, re.IGNORECASE)
                    if match:
                        workshop_related_dir = match.group(1)
                
                # 鏂规硶3锛氬鏋滄槸Steam鍒涙剰宸ュ潑鍐呭璺緞锛岃幏鍙朿ontent鐩綍
                if not workshop_related_dir:
                    content_match = re.search(r'(.*?steamapps[/\\]workshop[/\\]content)', decoded_path, re.IGNORECASE)
                    if content_match:
                        workshop_related_dir = content_match.group(1)
                
                # 濡傛灉鎵惧埌浜嗙浉鍏崇洰褰曪紝娣诲姞鍒板厑璁稿垪琛?                if workshop_related_dir and os.path.exists(workshop_related_dir):
                    real_workshop_dir = os.path.realpath(workshop_related_dir)
                    if real_workshop_dir not in allowed_dirs:
                        allowed_dirs.append(real_workshop_dir)
                        logger.info(f"鍔ㄦ€佹坊鍔犲厑璁哥殑鍒涙剰宸ュ潑鐩稿叧鐩綍: {real_workshop_dir}")
        except Exception as e:
            logger.warning(f"鍔ㄦ€佹坊鍔犲垱鎰忓伐鍧婅矾寰勫け璐? {str(e)}")
        
        logger.info(f"褰撳墠鍏佽鐨勭洰褰曞垪琛? {allowed_dirs}")

        # Windows璺緞澶勭悊锛氱‘淇濊矾寰勫垎闅旂姝ｇ‘
        if os.name == 'nt':  # Windows绯荤粺
            # 鏇挎崲鍙兘鐨勬枩鏉犱负鍙嶆枩鏉狅紝纭繚Windows璺緞鏍煎紡姝ｇ‘
            decoded_path = decoded_path.replace('/', '\\')
            # 澶勭悊鍙兘鐨勫弻閲嶇紪鐮侀棶棰?            if decoded_path.startswith('\\\\'):
                decoded_path = decoded_path[2:]  # 绉婚櫎澶氫綑鐨勫弽鏂滄潬鍓嶇紑
        
        # 灏濊瘯瑙ｆ瀽璺緞
        final_path = None
        
        # 灏濊瘯浣滀负缁濆璺緞
        if os.path.exists(decoded_path) and os.path.isfile(decoded_path):
            # 瑙勮寖鍖栬矾寰勪互闃叉璺緞閬嶅巻鏀诲嚮
            real_path = os.path.realpath(decoded_path)
            # 妫€鏌ヨ矾寰勬槸鍚﹀湪鍏佽鐨勭洰褰曞唴
            if any(real_path.startswith(allowed_dir) for allowed_dir in allowed_dirs):
                final_path = real_path
        
        # 灏濊瘯澶囬€夎矾寰勬牸寮?        if final_path is None:
            alt_path = decoded_path.replace('\\', '/')
            if os.path.exists(alt_path) and os.path.isfile(alt_path):
                real_path = os.path.realpath(alt_path)
                if any(real_path.startswith(allowed_dir) for allowed_dir in allowed_dirs):
                    final_path = real_path
        
        # 灏濊瘯鐩稿璺緞澶勭悊 - 鐩稿浜巗tatic鐩綍
        if final_path is None:
            # 瀵逛簬浠?./static寮€澶寸殑鐩稿璺緞锛屽皾璇曠洿鎺ヤ粠static鐩綍瑙ｆ瀽
            if decoded_path.startswith('..\\static') or decoded_path.startswith('../static'):
                # 鎻愬彇static鍚庨潰鐨勯儴鍒?                relative_part = decoded_path.split('static')[1]
                if relative_part.startswith(('\\', '/')):
                    relative_part = relative_part[1:]
                # 鏋勫缓瀹屾暣璺緞
                relative_path = os.path.join(allowed_dirs[0], relative_part)  # static鐩綍
                if os.path.exists(relative_path) and os.path.isfile(relative_path):
                    real_path = os.path.realpath(relative_path)
                    if any(real_path.startswith(allowed_dir) for allowed_dir in allowed_dirs):
                        final_path = real_path
        
        # 灏濊瘯鐩稿浜庨粯璁ゅ垱鎰忓伐鍧婄洰褰曠殑璺緞澶勭悊
        if final_path is None:
            try:
                workshop_base_dir = os.path.abspath(os.path.normpath(get_workshop_path()))
                
                # 灏濊瘯灏嗚В鐮佽矾寰勪綔涓虹浉瀵逛簬鍒涙剰宸ュ潑鐩綍鐨勮矾寰?                rel_workshop_path = os.path.join(workshop_base_dir, decoded_path)
                rel_workshop_path = os.path.normpath(rel_workshop_path)
                
                logger.info(f"灏濊瘯鐩稿浜庡垱鎰忓伐鍧婄洰褰曠殑璺緞: {rel_workshop_path}")
                
                if os.path.exists(rel_workshop_path) and os.path.isfile(rel_workshop_path):
                    real_path = os.path.realpath(rel_workshop_path)
                    # 纭繚璺緞鍦ㄥ厑璁哥殑鐩綍鍐?                    if real_path.startswith(workshop_base_dir):
                        final_path = real_path
                        logger.info(f"鎵惧埌鐩稿浜庡垱鎰忓伐鍧婄洰褰曠殑鍥剧墖: {final_path}")
            except Exception as e:
                logger.warning(f"澶勭悊鐩稿浜庡垱鎰忓伐鍧婄洰褰曠殑璺緞澶辫触: {str(e)}")
        
        
        # 濡傛灉浠嶆湭鎵惧埌鏈夋晥璺緞锛岃繑鍥為敊璇?        if final_path is None:
            return JSONResponse(content={"success": False, "error": f"鏂囦欢涓嶅瓨鍦ㄦ垨鏃犺闂潈闄? {decoded_path}"}, status_code=404)
        
        # 妫€鏌ユ枃浠舵墿灞曞悕鏄惁涓哄浘鐗?        image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']
        if os.path.splitext(final_path)[1].lower() not in image_extensions:
            return JSONResponse(content={"success": False, "error": "涓嶆槸鏈夋晥鐨勫浘鐗囨枃浠?}, status_code=400)
        
        # 璇诲彇鍥剧墖鏂囦欢
        with open(final_path, 'rb') as f:
            image_data = f.read()
        
        # 鏍规嵁鏂囦欢鎵╁睍鍚嶈缃甅IME绫诲瀷
        ext = os.path.splitext(final_path)[1].lower()
        mime_type = {
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.png': 'image/png',
            '.gif': 'image/gif',
            '.bmp': 'image/bmp',
            '.webp': 'image/webp'
        }.get(ext, 'application/octet-stream')
        
        # 杩斿洖鍥剧墖鏁版嵁
        return Response(content=image_data, media_type=mime_type)
    except Exception as e:
        logger.error(f"浠ｇ悊鍥剧墖璁块棶澶辫触: {str(e)}")
        return JSONResponse(content={"success": False, "error": f"璁块棶鍥剧墖澶辫触: {str(e)}"}, status_code=500)


@app.get('/api/steam/workshop/local-items/{item_id}')
async def get_local_workshop_item(item_id: str, folder_path: str = None):
    try:
        # 杩欎釜鎺ュ彛闇€瑕佷粠缂撳瓨鎴栦复鏃跺瓨鍌ㄤ腑鑾峰彇鐗╁搧淇℃伅
        # 杩欓噷绠€鍖栧疄鐜帮紝瀹為檯搴旂敤涓簲璇ユ湁鏇村畬鍠勭殑缂撳瓨鏈哄埗
        # folder_path 宸茬粡閫氳繃鍑芥暟鍙傛暟鑾峰彇
        
        if not folder_path:
            return JSONResponse(content={"success": False, "error": "鏈彁渚涙枃浠跺す璺緞"}, status_code=400)
        
        # 瀹夊叏妫€鏌ワ細濮嬬粓浣跨敤get_workshop_path()浣滀负鍩虹鐩綍
        base_workshop_folder = os.path.abspath(os.path.normpath(get_workshop_path()))
        
        # Windows璺緞澶勭悊锛氱‘淇濊矾寰勫垎闅旂姝ｇ‘
        if os.name == 'nt':  # Windows绯荤粺
            # 瑙ｇ爜骞跺鐞哤indows璺緞
            decoded_folder_path = unquote(folder_path)
            # 鏇挎崲鏂滄潬涓哄弽鏂滄潬锛岀‘淇漌indows璺緞鏍煎紡姝ｇ‘
            decoded_folder_path = decoded_folder_path.replace('/', '\\')
            # 澶勭悊鍙兘鐨勫弻閲嶇紪鐮侀棶棰?            if decoded_folder_path.startswith('\\\\'):
                decoded_folder_path = decoded_folder_path[2:]  # 绉婚櫎澶氫綑鐨勫弽鏂滄潬鍓嶇紑
        else:
            decoded_folder_path = unquote(folder_path)
        
        # 鍏抽敭淇锛氬皢鐩稿璺緞杞崲涓哄熀浜庡熀纭€鐩綍鐨勭粷瀵硅矾寰?        # 纭繚璺緞鏄粷瀵硅矾寰勶紝濡傛灉涓嶆槸鍒欒涓虹浉瀵硅矾寰?        if not os.path.isabs(decoded_folder_path):
            # 灏嗙浉瀵硅矾寰勮浆鎹负鍩轰簬鍩虹鐩綍鐨勭粷瀵硅矾寰?            full_path = os.path.join(base_workshop_folder, decoded_folder_path)
        else:
            # 濡傛灉宸茬粡鏄粷瀵硅矾寰勶紝浠嶇劧纭繚瀹冨湪鍩虹鐩綍鍐咃紙瀹夊叏妫€鏌ワ級
            full_path = decoded_folder_path
            # 鏍囧噯鍖栬矾寰?            full_path = os.path.normpath(full_path)
            
        # 瀹夊叏妫€鏌ワ細楠岃瘉璺緞鏄惁鍦ㄥ熀纭€鐩綍鍐?        if not full_path.startswith(base_workshop_folder):
            logger.warning(f'璺緞閬嶅巻灏濊瘯琚嫆缁? {folder_path}')
            return JSONResponse(content={"success": False, "error": "璁块棶琚嫆缁? 璺緞涓嶅湪鍏佽鐨勮寖鍥村唴"}, status_code=403)
        
        folder_path = full_path
        logger.info(f'澶勭悊鍚庣殑瀹屾暣璺緞: {folder_path}')
        
        # 瑙ｆ瀽鏈湴ID
        if item_id.startswith('local_'):
            index = int(item_id.split('_')[1])
            
            try:
                # 妫€鏌older_path鏄惁宸茬粡鏄」鐩枃浠跺す璺緞
                if os.path.isdir(folder_path):
                    # 鎯呭喌1锛歠older_path鐩存帴鎸囧悜椤圭洰鏂囦欢澶?                    stat_info = os.stat(folder_path)
                    item_name = os.path.basename(folder_path)
                    
                    item = {
                        "id": item_id,
                        "name": item_name,
                        "path": folder_path,
                        "lastModified": stat_info.st_mtime,
                        "size": get_folder_size(folder_path),
                        "tags": ["妯＄粍"],
                        "previewImage": find_preview_image_in_folder(folder_path)
                    }
                    
                    return JSONResponse(content={"success": True, "item": item})
                else:
                    # 鎯呭喌2锛氬皾璇曞師濮嬮€昏緫锛屼粠folder_path涓煡鎵剧index涓瓙鏂囦欢澶?                    items = []
                    for i, item_folder in enumerate(os.listdir(folder_path)):
                        item_path = os.path.join(folder_path, item_folder)
                        if os.path.isdir(item_path) and i + 1 == index:
                            stat_info = os.stat(item_path)
                            items.append({
                                "id": f"local_{i + 1}",
                                "name": item_folder,
                                "path": item_path,
                                "lastModified": stat_info.st_mtime,
                                "size": get_folder_size(item_path),
                                "tags": ["妯＄粍"],
                                "previewImage": find_preview_image_in_folder(item_path)
                            })
                            break
                    
                    if items:
                        return JSONResponse(content={"success": True, "item": items[0]})
                    else:
                        return JSONResponse(content={"success": False, "error": "鐗╁搧涓嶅瓨鍦?}, status_code=404)
            except Exception as e:
                logger.error(f"澶勭悊鏈湴鐗╁搧璺緞鏃跺嚭閿? {e}")
                return JSONResponse(content={"success": False, "error": f"璺緞澶勭悊閿欒: {str(e)}"}, status_code=500)
        
        return JSONResponse(content={"success": False, "error": "鏃犳晥鐨勭墿鍝両D鏍煎紡"}, status_code=400)
        
    except Exception as e:
        logger.error(f"鑾峰彇鏈湴鍒涙剰宸ュ潑鐗╁搧澶辫触: {e}")
        return JSONResponse(content={"success": False, "error": str(e)}, status_code=500)

@app.get('/api/steam/workshop/check-upload-status')
async def check_upload_status(item_path: str = None):
    try:
        # 楠岃瘉璺緞鍙傛暟
        if not item_path:
            return JSONResponse(content={
                "success": False,
                "error": "鏈彁渚涚墿鍝佹枃浠跺す璺緞"
            }, status_code=400)
        
        # 瀹夊叏妫€鏌ワ細浣跨敤get_workshop_path()浣滀负鍩虹鐩綍
        base_workshop_folder = os.path.abspath(os.path.normpath(get_workshop_path()))
        
        # Windows璺緞澶勭悊锛氱‘淇濊矾寰勫垎闅旂姝ｇ‘
        if os.name == 'nt':  # Windows绯荤粺
            # 瑙ｇ爜骞跺鐞哤indows璺緞
            decoded_item_path = unquote(item_path)
            # 鏇挎崲鏂滄潬涓哄弽鏂滄潬锛岀‘淇漌indows璺緞鏍煎紡姝ｇ‘
            decoded_item_path = decoded_item_path.replace('/', '\\')
            # 澶勭悊鍙兘鐨勫弻閲嶇紪鐮侀棶棰?            if decoded_item_path.startswith('\\\\'):
                decoded_item_path = decoded_item_path[2:]  # 绉婚櫎澶氫綑鐨勫弽鏂滄潬鍓嶇紑
        else:
            decoded_item_path = unquote(item_path)
        
        # 灏嗙浉瀵硅矾寰勮浆鎹负鍩轰簬鍩虹鐩綍鐨勭粷瀵硅矾寰?        if not os.path.isabs(decoded_item_path):
            full_path = os.path.join(base_workshop_folder, decoded_item_path)
        else:
            full_path = decoded_item_path
            full_path = os.path.normpath(full_path)
        
        # 瀹夊叏妫€鏌ワ細楠岃瘉璺緞鏄惁鍦ㄥ熀纭€鐩綍鍐?        if not full_path.startswith(base_workshop_folder):
            logger.warning(f'璺緞閬嶅巻灏濊瘯琚嫆缁? {item_path}')
            return JSONResponse(content={"success": False, "error": "璁块棶琚嫆缁? 璺緞涓嶅湪鍏佽鐨勮寖鍥村唴"}, status_code=403)
        
        # 楠岃瘉璺緞瀛樺湪鎬?        if not os.path.exists(full_path) or not os.path.isdir(full_path):
            return JSONResponse(content={
                "success": False,
                "error": "鏃犳晥鐨勭墿鍝佹枃浠跺す璺緞"
            }, status_code=400)
        
        # 鎼滅储浠team_workshop_id_寮€澶寸殑txt鏂囦欢
        import glob
        import re
        
        upload_files = glob.glob(os.path.join(full_path, "steam_workshop_id_*.txt"))
        
        # 鎻愬彇绗竴涓壘鍒扮殑鐗╁搧ID
        published_file_id = None
        if upload_files:
            # 鑾峰彇绗竴涓枃浠?            first_file = upload_files[0]
            
            # 浠庢枃浠跺悕鎻愬彇ID
            match = re.search(r'steam_workshop_id_(\d+)\.txt', os.path.basename(first_file))
            if match:
                published_file_id = match.group(1)
        
        # 杩斿洖妫€鏌ョ粨鏋?        return JSONResponse(content={
            "success": True,
            "is_published": published_file_id is not None,
            "published_file_id": published_file_id
        })
        
    except Exception as e:
        logger.error(f"妫€鏌ヤ笂浼犵姸鎬佸け璐? {e}")
        return JSONResponse(content={
            "success": False,
            "error": str(e),
            "message": "妫€鏌ヤ笂浼犵姸鎬佹椂鍙戠敓閿欒"
        }, status_code=500)

@app.post('/api/steam/workshop/publish')
async def publish_to_workshop(request: Request):
    global steamworks
    
    # 妫€鏌teamworks鏄惁鍒濆鍖栨垚鍔?    if steamworks is None:
        return JSONResponse(content={
            "success": False,
            "error": "Steamworks鏈垵濮嬪寲",
            "message": "璇风‘淇漇team瀹㈡埛绔凡杩愯涓斿凡鐧诲綍"
        }, status_code=503)
    
    try:
        data = await request.json()
        
        # 楠岃瘉蹇呰鐨勫瓧娈?        required_fields = ['title', 'content_folder', 'visibility']
        for field in required_fields:
            if field not in data:
                return JSONResponse(content={"success": False, "error": f"缂哄皯蹇呰瀛楁: {field}"}, status_code=400)
        
        # 鎻愬彇鏁版嵁
        title = data['title']
        content_folder = data['content_folder']
        visibility = int(data['visibility'])
        preview_image = data.get('preview_image', '')
        description = data.get('description', '')
        tags = data.get('tags', [])
        change_note = data.get('change_note', '鍒濆鍙戝竷')
        
        # 瑙勮寖鍖栬矾寰勫鐞?- 鏀硅繘鐗堬紝纭繚鍦ㄦ墍鏈夋儏鍐典笅閮借兘姝ｇ‘澶勭悊璺緞
        content_folder = unquote(content_folder)
        # 澶勭悊Windows璺緞锛岀‘淇濅娇鐢ㄦ纭殑璺緞鍒嗛殧绗?        if os.name == 'nt':
            # 灏嗘墍鏈夎矾寰勫垎闅旂缁熶竴涓哄弽鏂滄潬
            content_folder = content_folder.replace('/', '\\')
            # 娓呯悊鍙兘鐨勯敊璇墠缂€
            if content_folder.startswith('\\\\'):
                content_folder = content_folder[2:]
        else:
            # 闈濿indows绯荤粺浣跨敤姝ｆ枩鏉?            content_folder = content_folder.replace('\\', '/')
        
        # 楠岃瘉鍐呭鏂囦欢澶瑰瓨鍦ㄥ苟鏄竴涓洰褰?        if not os.path.exists(content_folder):
            return JSONResponse(content={
                "success": False,
                "error": "鍐呭鏂囦欢澶逛笉瀛樺湪",
                "message": f"鎸囧畾鐨勫唴瀹规枃浠跺す涓嶅瓨鍦? {content_folder}"
            }, status_code=404)
        
        if not os.path.isdir(content_folder):
            return JSONResponse(content={
                "success": False,
                "error": "涓嶆槸鏈夋晥鐨勬枃浠跺す",
                "message": f"鎸囧畾鐨勮矾寰勪笉鏄湁鏁堢殑鏂囦欢澶? {content_folder}"
            }, status_code=400)
        
        # 澧炲姞鍐呭鏂囦欢澶规鏌ワ細纭繚鏂囦欢澶逛腑鑷冲皯鏈夋枃浠讹紝楠岃瘉鏂囦欢澶规槸鍚﹀寘鍚唴瀹?        if not any(os.scandir(content_folder)):
            return JSONResponse(content={
                "success": False,
                "error": "鍐呭鏂囦欢澶逛负绌?,
                "message": f"鍐呭鏂囦欢澶逛负绌猴紝璇风‘淇濆寘鍚涓婁紶鐨勬枃浠? {content_folder}"
            }, status_code=400)
        
        # 妫€鏌ユ枃浠跺す鏉冮檺
        if not os.access(content_folder, os.R_OK):
            return JSONResponse(content={
                "success": False,
                "error": "娌℃湁鏂囦欢澶硅闂潈闄?,
                "message": f"娌℃湁璇诲彇鍐呭鏂囦欢澶圭殑鏉冮檺: {content_folder}"
            }, status_code=403)
        
        # 澶勭悊棰勮鍥剧墖璺緞
        if preview_image:
            preview_image = unquote(preview_image)
            if os.name == 'nt':
                preview_image = preview_image.replace('/', '\\')
                if preview_image.startswith('\\\\'):
                    preview_image = preview_image[2:]
            else:
                preview_image = preview_image.replace('\\', '/')
            
            # 楠岃瘉棰勮鍥剧墖瀛樺湪
            if not os.path.exists(preview_image):
                # 濡傛灉鎸囧畾鐨勯瑙堝浘涓嶅瓨鍦紝灏濊瘯鍦ㄥ唴瀹规枃浠跺す涓煡鎵鹃粯璁ら瑙堝浘
                logger.warning(f'鎸囧畾鐨勯瑙堝浘鐗囦笉瀛樺湪锛屽皾璇曞湪鍐呭鏂囦欢澶逛腑鏌ユ壘: {preview_image}')
                auto_preview = find_preview_image_in_folder(content_folder)
                if auto_preview:
                    logger.info(f'鎵惧埌鑷姩棰勮鍥剧墖: {auto_preview}')
                    preview_image = auto_preview
                else:
                    logger.warning(f'鏃犳硶鎵惧埌棰勮鍥剧墖')
                    preview_image = ''
            
            if preview_image and not os.path.isfile(preview_image):
                return JSONResponse(content={
                    "success": False,
                    "error": "棰勮鍥剧墖鏃犳晥",
                    "message": f"棰勮鍥剧墖璺緞涓嶆槸鏈夋晥鐨勬枃浠? {preview_image}"
                }, status_code=400)
        else:
            # 濡傛灉鏈寚瀹氶瑙堝浘鐗囷紝灏濊瘯鑷姩鏌ユ壘
            auto_preview = find_preview_image_in_folder(content_folder)
            if auto_preview:
                logger.info(f'鑷姩鎵惧埌棰勮鍥剧墖: {auto_preview}')
                preview_image = auto_preview
        
        # 璁板綍灏嗚涓婁紶鐨勫唴瀹逛俊鎭?        logger.info(f"鍑嗗鍙戝竷鍒涙剰宸ュ潑鐗╁搧: {title}")
        logger.info(f"鍐呭鏂囦欢澶? {content_folder}")
        logger.info(f"棰勮鍥剧墖: {preview_image or '鏃?}")
        logger.info(f"鍙鎬? {visibility}")
        logger.info(f"鏍囩: {tags}")
        logger.info(f"鍐呭鏂囦欢澶瑰寘鍚枃浠舵暟閲? {len([f for f in os.listdir(content_folder) if os.path.isfile(os.path.join(content_folder, f))])}")
        logger.info(f"鍐呭鏂囦欢澶瑰寘鍚瓙鏂囦欢澶规暟閲? {len([f for f in os.listdir(content_folder) if os.path.isdir(os.path.join(content_folder, f))])}")
        
        # 浣跨敤绾跨▼姹犳墽琛孲teamworks API璋冪敤锛堝洜涓鸿繖浜涙槸闃诲鎿嶄綔锛?        loop = asyncio.get_event_loop()
        published_file_id = await loop.run_in_executor(
            None, 
            lambda: _publish_workshop_item(
                steamworks, title, description, content_folder, 
                preview_image, visibility, tags, change_note
            )
        )
        
        logger.info(f"鎴愬姛鍙戝竷鍒涙剰宸ュ潑鐗╁搧锛孖D: {published_file_id}")
        return JSONResponse(content={
            "success": True,
            "published_file_id": published_file_id,
            "message": "鍙戝竷鎴愬姛"
        })
        
    except ValueError as ve:
        logger.error(f"鍙傛暟閿欒: {ve}")
        return JSONResponse(content={"success": False, "error": str(ve)}, status_code=400)
    except SteamNotLoadedException as se:
        logger.error(f"Steamworks API閿欒: {se}")
        return JSONResponse(content={
            "success": False,
            "error": "Steamworks API閿欒",
            "message": "璇风‘淇漇team瀹㈡埛绔凡杩愯涓斿凡鐧诲綍"
        }, status_code=503)
    except Exception as e:
        logger.error(f"鍙戝竷鍒板垱鎰忓伐鍧婂け璐? {e}")
        return JSONResponse(content={"success": False, "error": str(e)}, status_code=500)


def _format_size(size_bytes):
    """
    灏嗗瓧鑺傚ぇ灏忔牸寮忓寲涓轰汉绫诲彲璇荤殑鏍煎紡
    """
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} TB"

def _publish_workshop_item(steamworks, title, description, content_folder, preview_image, visibility, tags, change_note):
    """
    鍦ㄥ崟鐙殑绾跨▼涓墽琛孲team鍒涙剰宸ュ潑鍙戝竷鎿嶄綔
    """
    # 鍦ㄥ嚱鏁板唴閮ㄦ坊鍔犲鍏ヨ鍙ワ紝纭繚鏋氫妇鍦ㄥ嚱鏁颁綔鐢ㄥ煙鍐呭彲鐢?    from steamworks.enums import EItemUpdateStatus
    
    # 妫€鏌ユ槸鍚﹀瓨鍦ㄧ幇鏈夌殑涓婁紶鏍囪鏂囦欢锛岄伩鍏嶉噸澶嶄笂浼?    try:
        if os.path.exists(content_folder) and os.path.isdir(content_folder):
            # 鏌ユ壘浠team_workshop_id_寮€澶寸殑txt鏂囦欢
            import glob
            marker_files = glob.glob(os.path.join(content_folder, "steam_workshop_id_*.txt"))
            
            if marker_files:
                # 浣跨敤绗竴涓壘鍒扮殑鏍囪鏂囦欢
                marker_file = marker_files[0]
                
                # 浠庢枃浠跺悕涓彁鍙栫墿鍝両D
                import re
                match = re.search(r'steam_workshop_id_([0-9]+)\.txt', marker_file)
                if match:
                    existing_item_id = int(match.group(1))
                    logger.info(f"妫€娴嬪埌鐗╁搧宸蹭笂浼狅紝鎵惧埌鏍囪鏂囦欢: {marker_file}锛岀墿鍝両D: {existing_item_id}")
                    return existing_item_id
    except Exception as e:
        logger.error(f"妫€鏌ヤ笂浼犳爣璁版枃浠舵椂鍑洪敊: {e}")
        # 鍗充娇妫€鏌ュけ璐ワ紝涔熺户缁皾璇曚笂浼狅紝涓嶉樆姝㈠姛鑳?    try:
        # 鍐嶆楠岃瘉鍐呭鏂囦欢澶癸紝纭繚鍦ㄥ绾跨▼鐜涓粛鐒舵湁鏁?        if not os.path.exists(content_folder) or not os.path.isdir(content_folder):
            raise Exception(f"鍐呭鏂囦欢澶逛笉瀛樺湪鎴栨棤鏁? {content_folder}")
        
        # 缁熻鏂囦欢澶瑰唴瀹癸紝纭繚鏈夋枃浠跺彲涓婁紶
        file_count = 0
        for root, dirs, files in os.walk(content_folder):
            file_count += len(files)
        
        if file_count == 0:
            raise Exception(f"鍐呭鏂囦欢澶逛腑娌℃湁鎵惧埌鍙笂浼犵殑鏂囦欢: {content_folder}")
        
        logger.info(f"鍐呭鏂囦欢澶归獙璇侀€氳繃锛屽寘鍚?{file_count} 涓枃浠?)
        
        # 鑾峰彇褰撳墠搴旂敤ID
        app_id = steamworks.app_id
        logger.info(f"浣跨敤搴旂敤ID: {app_id} 杩涜鍒涙剰宸ュ潑涓婁紶")
        
        # 澧炲己鐨凷team杩炴帴鐘舵€侀獙璇?        try:
            # 鍩虹杩炴帴鐘舵€佹鏌?            is_steam_running = steamworks.IsSteamRunning()
            is_overlay_enabled = steamworks.IsOverlayEnabled()
            is_logged_on = steamworks.Users.LoggedOn()
            steam_id = steamworks.Users.GetSteamID()
            
            # 搴旂敤鐩稿叧鏉冮檺妫€鏌?            app_owned = steamworks.Apps.IsAppInstalled(app_id)
            app_owned_license = steamworks.Apps.IsSubscribedApp(app_id)
            app_subscribed = steamworks.Apps.IsSubscribed()
            
            # 璁板綍璇︾粏鐨勮繛鎺ョ姸鎬?            logger.info(f"Steam瀹㈡埛绔繍琛岀姸鎬? {is_steam_running}")
            logger.info(f"Steam瑕嗙洊灞傚惎鐢ㄧ姸鎬? {is_overlay_enabled}")
            logger.info(f"鐢ㄦ埛鐧诲綍鐘舵€? {is_logged_on}")
            logger.info(f"鐢ㄦ埛SteamID: {steam_id}")
            logger.info(f"搴旂敤ID {app_id} 瀹夎鐘舵€? {app_owned}")
            logger.info(f"搴旂敤ID {app_id} 璁㈤槄璁稿彲鐘舵€? {app_owned_license}")
            logger.info(f"褰撳墠搴旂敤璁㈤槄鐘舵€? {app_subscribed}")
            
            # 棰勬鏌ヨ繛鎺ョ姸鎬侊紝濡傛灉瀛樺湪闂鍒欐彁鍓嶆姤閿?            if not is_steam_running:
                raise Exception("Steam瀹㈡埛绔湭杩愯锛岃鍏堝惎鍔⊿team瀹㈡埛绔?)
            if not is_logged_on:
                raise Exception("鐢ㄦ埛鏈櫥褰昐team锛岃纭繚宸茬櫥褰昐team瀹㈡埛绔?)
            
        except Exception as e:
            logger.error(f"Steam杩炴帴鐘舵€侀獙璇佸け璐? {e}")
            # 鍗充娇楠岃瘉澶辫触涔熺户缁墽琛岋紝浣嗘彁渚涜鍛?            logger.warning(f"缁х画灏濊瘯鍒涙剰宸ュ潑涓婁紶锛屼絾鍙兘浼氬洜涓篠team杩炴帴闂鑰屽け璐?)
        
        # 閿欒鏄犲皠琛紝鏍规嵁閿欒鐮佹彁渚涙洿鍏蜂綋鐨勯敊璇俊鎭?        error_codes = {
            1: "鎴愬姛",
            10: "鏉冮檺涓嶈冻 - 鍙兘闇€瑕佺櫥褰昐team瀹㈡埛绔垨缂哄皯鍒涙剰宸ュ潑涓婁紶鏉冮檺",
            111: "缃戠粶杩炴帴閿欒 - 鏃犳硶杩炴帴鍒癝team缃戠粶",
            100: "鏈嶅姟涓嶅彲鐢?- Steam鍒涙剰宸ュ潑鏈嶅姟鏆傛椂涓嶅彲鐢?,
            8: "鏂囦欢宸插瓨鍦?- 鐩稿悓鍐呭鐨勭墿鍝佸凡瀛樺湪",
            34: "鏈嶅姟鍣ㄥ繖 - Steam鏈嶅姟鍣ㄦ殏鏃舵棤娉曞鐞嗚姹?,
            116: "璇锋眰瓒呮椂 - 涓嶴team鏈嶅姟鍣ㄩ€氫俊瓒呮椂"
        }
        
        # 瀵逛簬鏂扮墿鍝侊紝鍏堝垱寤轰竴涓┖鐗╁搧
        # 浣跨敤鍥炶皟鏉ュ鐞嗗垱寤虹粨鏋?        created_item_id = [None]
        created_event = threading.Event()
        create_result = [None]  # 鐢ㄤ簬瀛樺偍鍒涘缓缁撴灉
        
        def onCreateItem(result):
            nonlocal created_item_id, create_result
            create_result[0] = result.result
            # 鐩存帴浠庣粨鏋勪綋璇诲彇瀛楁鑰屼笉鏄瓧鍏?            if result.result == 1:  # k_EResultOK
                created_item_id[0] = result.publishedFileId
                logger.info(f"鎴愬姛鍒涘缓鍒涙剰宸ュ潑鐗╁搧锛孖D: {created_item_id[0]}")
                created_event.set()
            else:
                error_msg = error_codes.get(result.result, f"鏈煡閿欒鐮? {result.result}")
                logger.error(f"鍒涘缓鍒涙剰宸ュ潑鐗╁搧澶辫触锛岄敊璇爜: {result.result} ({error_msg})")
                created_event.set()
        
        # 璁剧疆鍒涘缓鐗╁搧鍥炶皟
        steamworks.Workshop.SetItemCreatedCallback(onCreateItem)
        
        # 鍒涘缓鏂扮殑鍒涙剰宸ュ潑鐗╁搧锛堜娇鐢ㄦ枃浠剁被鍨嬫灇涓捐〃绀篣GC锛?        logger.info(f"寮€濮嬪垱寤哄垱鎰忓伐鍧婄墿鍝? {title}")
        logger.info(f"璋冪敤SteamWorkshop.CreateItem({app_id}, {EWorkshopFileType.COMMUNITY})")
        steamworks.Workshop.CreateItem(app_id, EWorkshopFileType.COMMUNITY)
        
        # 绛夊緟鍒涘缓瀹屾垚鎴栬秴鏃讹紝澧炲姞瓒呮椂鏃堕棿骞舵坊鍔犺皟璇曚俊鎭?        logger.info("绛夊緟鍒涙剰宸ュ潑鐗╁搧鍒涘缓瀹屾垚...")
        # 浣跨敤寰幆绛夊緟锛屽畾鏈熻皟鐢╮un_callbacks澶勭悊鍥炶皟
        start_time = time.time()
        timeout = 60  # 瓒呮椂鏃堕棿60绉?        while time.time() - start_time < timeout:
            if created_event.is_set():
                break
            # 瀹氭湡璋冪敤run_callbacks澶勭悊Steam API鍥炶皟
            try:
                steamworks.run_callbacks()
            except Exception as e:
                logger.error(f"鎵цSteam鍥炶皟鏃跺嚭閿? {str(e)}")
            time.sleep(0.1)  # 姣?00姣妫€鏌ヤ竴娆?        
        if not created_event.is_set():
            logger.error("鍒涘缓鍒涙剰宸ュ潑鐗╁搧瓒呮椂锛屽彲鑳芥槸缃戠粶闂鎴朣team鏈嶅姟鏆傛椂涓嶅彲鐢?)
            raise TimeoutError("鍒涘缓鍒涙剰宸ュ潑鐗╁搧瓒呮椂")
        
        if created_item_id[0] is None:
            # 鎻愪緵鏇村叿浣撶殑閿欒淇℃伅
            error_msg = error_codes.get(create_result[0], f"鏈煡閿欒鐮? {create_result[0]}")
            logger.error(f"鍒涘缓鍒涙剰宸ュ潑鐗╁搧澶辫触: {error_msg}")
            
            # 閽堝閿欒鐮?0锛堟潈闄愪笉瓒筹級鎻愪緵鏇磋缁嗙殑閿欒淇℃伅鍜岃В鍐虫柟妗?            if create_result[0] == 10:
                detailed_error = f"""鏉冮檺涓嶈冻 - 璇风‘淇?
1. Steam瀹㈡埛绔凡鍚姩骞剁櫥褰?2. 鎮ㄧ殑Steam璐﹀彿鎷ユ湁搴旂敤ID {app_id} 鐨勮闂潈闄?3. Steam鍒涙剰宸ュ潑鍔熻兘鏈绂佺敤
4. 灏濊瘯浠ョ鐞嗗憳鏉冮檺杩愯搴旂敤绋嬪簭
5. 妫€鏌ラ槻鐏璁剧疆鏄惁闃绘浜嗗簲鐢ㄧ▼搴忚闂甋team缃戠粶
6. 纭繚steam_appid.txt鏂囦欢涓殑搴旂敤ID姝ｇ‘
7. 鎮ㄧ殑Steam璐﹀彿鏈夋潈闄愪笂浼犲埌璇ュ簲鐢ㄧ殑鍒涙剰宸ュ潑"""
                logger.error(f"鍒涙剰宸ュ潑涓婁紶澶辫触 - 璇︾粏璇婃柇淇℃伅:")
                logger.error(f"- 搴旂敤ID: {app_id}")
                logger.error(f"- Steam杩愯鐘舵€? {steamworks.IsSteamRunning()}")
                logger.error(f"- 鐢ㄦ埛鐧诲綍鐘舵€? {steamworks.Users.LoggedOn()}")
                logger.error(f"- 搴旂敤璁㈤槄鐘舵€? {steamworks.Apps.IsSubscribedApp(app_id)}")
                raise Exception(f"鍒涘缓鍒涙剰宸ュ潑鐗╁搧澶辫触: {detailed_error} (閿欒鐮? {create_result[0]})")
            else:
                raise Exception(f"鍒涘缓鍒涙剰宸ュ潑鐗╁搧澶辫触: {error_msg} (閿欒鐮? {create_result[0]})")
        
        # 寮€濮嬫洿鏂扮墿鍝?        logger.info(f"寮€濮嬫洿鏂扮墿鍝佸唴瀹? {title}")
        update_handle = steamworks.Workshop.StartItemUpdate(app_id, created_item_id[0])
        
        # 璁剧疆鐗╁搧灞炴€?        logger.info("璁剧疆鐗╁搧鍩烘湰灞炴€?..")
        steamworks.Workshop.SetItemTitle(update_handle, title)
        if description:
            steamworks.Workshop.SetItemDescription(update_handle, description)
        
        # 璁剧疆鐗╁搧鍐呭 - 杩欐槸鏂囦欢涓婁紶鐨勬牳蹇冩楠?        logger.info(f"璁剧疆鐗╁搧鍐呭鏂囦欢澶? {content_folder}")
        content_set_result = steamworks.Workshop.SetItemContent(update_handle, content_folder)
        logger.info(f"鍐呭璁剧疆缁撴灉: {content_set_result}")
        
        # 璁剧疆棰勮鍥剧墖锛堝鏋滄彁渚涳級
        if preview_image:
            logger.info(f"璁剧疆棰勮鍥剧墖: {preview_image}")
            preview_set_result = steamworks.Workshop.SetItemPreview(update_handle, preview_image)
            logger.info(f"棰勮鍥剧墖璁剧疆缁撴灉: {preview_set_result}")
        
        # 瀵煎叆鏋氫妇绫诲瀷骞跺皢鏁存暟鍊艰浆鎹负鏋氫妇瀵硅薄
        from steamworks.enums import ERemoteStoragePublishedFileVisibility
        if visibility == 0:
            visibility_enum = ERemoteStoragePublishedFileVisibility.PUBLIC
        elif visibility == 1:
            visibility_enum = ERemoteStoragePublishedFileVisibility.FRIENDS_ONLY
        elif visibility == 2:
            visibility_enum = ERemoteStoragePublishedFileVisibility.PRIVATE
        else:
            # 榛樿璁句负鍏紑
            visibility_enum = ERemoteStoragePublishedFileVisibility.PUBLIC
            
        # 璁剧疆鐗╁搧鍙鎬?        logger.info(f"璁剧疆鐗╁搧鍙鎬? {visibility_enum}")
        steamworks.Workshop.SetItemVisibility(update_handle, visibility_enum)
        
        # 璁剧疆鏍囩锛堝鏋滄湁锛?        if tags:
            logger.info(f"璁剧疆鐗╁搧鏍囩: {tags}")
            steamworks.Workshop.SetItemTags(update_handle, tags)
        
        # 鎻愪氦鏇存柊锛屼娇鐢ㄥ洖璋冩潵澶勭悊缁撴灉
        updated = [False]
        error_code = [0]
        update_event = threading.Event()
        
        def onSubmitItemUpdate(result):
            nonlocal updated, error_code
            # 鐩存帴浠庣粨鏋勪綋璇诲彇瀛楁鑰屼笉鏄瓧鍏?            error_code[0] = result.result
            if result.result == 1:  # k_EResultOK
                updated[0] = True
                logger.info(f"鐗╁搧鏇存柊鎻愪氦鎴愬姛锛岀粨鏋滀唬鐮? {result.result}")
            else:
                logger.error(f"鎻愪氦鍒涙剰宸ュ潑鐗╁搧鏇存柊澶辫触锛岄敊璇爜: {result.result}")
            update_event.set()
        
        # 璁剧疆鏇存柊鐗╁搧鍥炶皟
        steamworks.Workshop.SetItemUpdatedCallback(onSubmitItemUpdate)
        
        # 鎻愪氦鏇存柊
        logger.info(f"寮€濮嬫彁浜ょ墿鍝佹洿鏂帮紝鏇存柊璇存槑: {change_note}")
        steamworks.Workshop.SubmitItemUpdate(update_handle, change_note)
        
        # 绛夊緟鏇存柊瀹屾垚鎴栬秴鏃讹紝澧炲姞瓒呮椂鏃堕棿骞舵坊鍔犺皟璇曚俊鎭?        logger.info("绛夊緟鍒涙剰宸ュ潑鐗╁搧鏇存柊瀹屾垚...")
        # 浣跨敤寰幆绛夊緟锛屽畾鏈熻皟鐢╮un_callbacks澶勭悊鍥炶皟
        start_time = time.time()
        timeout = 180  # 瓒呮椂鏃堕棿180绉?        last_progress = -1
        
        while time.time() - start_time < timeout:
            if update_event.is_set():
                break
            # 瀹氭湡璋冪敤run_callbacks澶勭悊Steam API鍥炶皟
            try:
                steamworks.run_callbacks()
                # 璁板綍涓婁紶杩涘害锛堟洿璇︾粏鐨勮繘搴︽姤鍛婏級
                if update_handle:
                    progress = steamworks.Workshop.GetItemUpdateProgress(update_handle)
                    if 'status' in progress:
                        status_text = "鏈煡"
                        if progress['status'] == EItemUpdateStatus.UPLOADING_CONTENT:
                            status_text = "涓婁紶鍐呭"
                        elif progress['status'] == EItemUpdateStatus.UPLOADING_PREVIEW_FILE:
                            status_text = "涓婁紶棰勮鍥?
                        elif progress['status'] == EItemUpdateStatus.COMMITTING_CHANGES:
                            status_text = "鎻愪氦鏇存敼"
                        
                        if 'progress' in progress:
                            current_progress = int(progress['progress'] * 100)
                            # 鍙湁杩涘害鏈夋槑鏄惧彉鍖栨椂鎵嶈褰曟棩蹇?                            if current_progress != last_progress:
                                logger.info(f"涓婁紶鐘舵€? {status_text}, 杩涘害: {current_progress}%")
                                last_progress = current_progress
            except Exception as e:
                logger.error(f"鎵цSteam鍥炶皟鏃跺嚭閿? {str(e)}")
            time.sleep(0.5)  # 姣?00姣妫€鏌ヤ竴娆★紝鍑忓皯鏃ュ織閲?        
        if not update_event.is_set():
            logger.error("鎻愪氦鍒涙剰宸ュ潑鐗╁搧鏇存柊瓒呮椂锛屽彲鑳芥槸缃戠粶闂鎴朣team鏈嶅姟鏆傛椂涓嶅彲鐢?)
            raise TimeoutError("鎻愪氦鍒涙剰宸ュ潑鐗╁搧鏇存柊瓒呮椂")
        
        if not updated[0]:
            # 鏍规嵁閿欒鐮佹彁渚涙洿璇︾粏鐨勯敊璇俊鎭?            if error_code[0] == 25:  # LIMIT_EXCEEDED
                error_msg = "鎻愪氦鍒涙剰宸ュ潑鐗╁搧鏇存柊澶辫触锛氬唴瀹硅秴杩嘢team闄愬埗锛堥敊璇爜25锛夈€傝妫€鏌ュ唴瀹瑰ぇ灏忋€佹枃浠舵暟閲忔垨鍏朵粬闄愬埗銆?
            else:
                error_msg = f"鎻愪氦鍒涙剰宸ュ潑鐗╁搧鏇存柊澶辫触锛岄敊璇爜: {error_code[0]}"
            logger.error(error_msg)
            raise Exception(error_msg)
        
        logger.info(f"鍒涙剰宸ュ潑鐗╁搧涓婁紶鎴愬姛瀹屾垚锛佺墿鍝両D: {created_item_id[0]}")
        
        # 鍦ㄥ師鏂囦欢澶瑰垱寤哄甫鐗╁搧ID鐨則xt鏂囦欢锛屾爣璁颁负宸蹭笂浼?        try:
            marker_file_path = os.path.join(content_folder, f"steam_workshop_id_{created_item_id[0]}.txt")
            with open(marker_file_path, 'w', encoding='utf-8') as f:
                f.write(f"Steam鍒涙剰宸ュ潑鐗╁搧ID: {created_item_id[0]}\n")
                f.write(f"涓婁紶鏃堕棿: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())}\n")
                f.write(f"鐗╁搧鏍囬: {title}\n")
            logger.info(f"宸插湪鍘熸枃浠跺す鍒涘缓涓婁紶鏍囪鏂囦欢: {marker_file_path}")
        except Exception as e:
            logger.error(f"鍒涘缓涓婁紶鏍囪鏂囦欢澶辫触: {e}")
            # 鍗充娇鍒涘缓鏍囪鏂囦欢澶辫触锛屼篃涓嶅奖鍝嶇墿鍝佷笂浼犵殑鎴愬姛杩斿洖
        
        return created_item_id[0]
        
    except Exception as e:
        logger.error(f"鍙戝竷鍒涙剰宸ュ潑鐗╁搧鏃跺嚭閿? {e}")
        raise

@app.post('/api/steam/set-achievement-status/{name}')
async def set_achievement_status(name: str):
    if steamworks is not None:
        try:
            # 鍏堣姹傜粺璁℃暟鎹苟杩愯鍥炶皟锛岀‘淇濇暟鎹凡鍔犺浇
            steamworks.UserStats.RequestCurrentStats()
            # 杩愯鍥炶皟绛夊緟鏁版嵁鍔犺浇锛堝娆¤繍琛屼互纭繚鎺ユ敹鍒板搷搴旓級
            for _ in range(10):
                steamworks.run_callbacks()
                await asyncio.sleep(0.1)
            
            achievement_status = steamworks.UserStats.GetAchievement(name)
            logger.info(f"Achievement status: {achievement_status}")
            if not achievement_status:
                result = steamworks.UserStats.SetAchievement(name)
                if result:
                    logger.info(f"鎴愬姛璁剧疆鎴愬氨: {name}")
                    steamworks.UserStats.StoreStats()
                    steamworks.run_callbacks()
                else:
                    # 绗竴娆″け璐ワ紝绛夊緟鍚庨噸璇曚竴娆?                    logger.warning(f"璁剧疆鎴愬氨棣栨灏濊瘯澶辫触锛屾鍦ㄩ噸璇? {name}")
                    await asyncio.sleep(0.5)
                    steamworks.run_callbacks()
                    result = steamworks.UserStats.SetAchievement(name)
                    if result:
                        logger.info(f"鎴愬姛璁剧疆鎴愬氨锛堥噸璇曞悗锛? {name}")
                        steamworks.UserStats.StoreStats()
                        steamworks.run_callbacks()
                    else:
                        logger.error(f"璁剧疆鎴愬氨澶辫触: {name}锛岃纭鎴愬氨ID鍦⊿team鍚庡彴宸查厤缃?)
            else:
                logger.info(f"鎴愬氨宸茶В閿侊紝鏃犻渶閲嶅璁剧疆: {name}")
        except Exception as e:
            logger.error(f"璁剧疆鎴愬氨澶辫触: {e}")

@app.get('/api/steam/list-achievements')
async def list_achievements():
    """鍒楀嚭Steam鍚庡彴宸查厤缃殑鎵€鏈夋垚灏憋紙璋冭瘯鐢級"""
    if steamworks is not None:
        try:
            steamworks.UserStats.RequestCurrentStats()
            for _ in range(10):
                steamworks.run_callbacks()
                await asyncio.sleep(0.1)
            
            num_achievements = steamworks.UserStats.GetNumAchievements()
            achievements = []
            for i in range(num_achievements):
                name = steamworks.UserStats.GetAchievementName(i)
                if name:
                    # 濡傛灉鏄痓ytes绫诲瀷锛岃В鐮佷负瀛楃涓?                    if isinstance(name, bytes):
                        name = name.decode('utf-8')
                    status = steamworks.UserStats.GetAchievement(name)
                    achievements.append({"name": name, "unlocked": status})
            
            logger.info(f"Steam鍚庡彴宸查厤缃?{num_achievements} 涓垚灏? {achievements}")
            return JSONResponse(content={"count": num_achievements, "achievements": achievements})
        except Exception as e:
            logger.error(f"鑾峰彇鎴愬氨鍒楄〃澶辫触: {e}")
            return JSONResponse(content={"error": str(e)}, status_code=500)
    else:
        return JSONResponse(content={"error": "Steamworks鏈垵濮嬪寲"}, status_code=500)

@app.get('/api/file-exists')
async def check_file_exists(path: str = None):
    try:
        # file_path 宸茬粡閫氳繃鍑芥暟鍙傛暟鑾峰彇
        
        if not path:
            return JSONResponse(content={"exists": False}, status_code=400)
        
        # 鑾峰彇鍩虹鐩綍鍜屽厑璁歌闂殑鐩綍鍒楄〃
        base_dir = _get_app_root()
        allowed_dirs = [
            os.path.realpath(os.path.join(base_dir, 'static')),
            os.path.realpath(os.path.join(base_dir, 'assets'))
        ]
        
        # 瑙ｇ爜URL缂栫爜鐨勮矾寰?        decoded_path = unquote(path)
        
        # Windows璺緞澶勭悊
        if os.name == 'nt':
            decoded_path = decoded_path.replace('/', '\\')
        
        # 瑙勮寖鍖栬矾寰勪互闃叉璺緞閬嶅巻鏀诲嚮
        real_path = os.path.realpath(decoded_path)
        
        # 妫€鏌ヨ矾寰勬槸鍚﹀湪鍏佽鐨勭洰褰曞唴
        if any(real_path.startswith(allowed_dir) for allowed_dir in allowed_dirs):
            # 妫€鏌ユ枃浠舵槸鍚﹀瓨鍦?            exists = os.path.exists(real_path) and os.path.isfile(real_path)
        else:
            # 涓嶅湪鍏佽鐨勭洰褰曞唴锛岃繑鍥炴枃浠朵笉瀛樺湪
            exists = False
        
        return JSONResponse(content={"exists": exists})
        
    except Exception as e:
        logger.error(f"妫€鏌ユ枃浠跺瓨鍦ㄥけ璐? {e}")
        return JSONResponse(content={"exists": False}, status_code=500)

@app.get('/api/find-first-image')
async def find_first_image(folder: str = None):
    """
    鏌ユ壘鎸囧畾鏂囦欢澶逛腑鐨勯瑙堝浘鐗?- 澧炲己鐗堬紝娣诲姞浜嗕弗鏍肩殑瀹夊叏妫€鏌?    
    瀹夊叏娉ㄦ剰浜嬮」锛?    1. 鍙厑璁歌闂」鐩唴鐗瑰畾鐨勫畨鍏ㄧ洰褰?    2. 闃叉璺緞閬嶅巻鏀诲嚮
    3. 闄愬埗杩斿洖淇℃伅锛岄伩鍏嶆硠闇叉枃浠剁郴缁熶俊鎭?    4. 璁板綍鍙枒璁块棶灏濊瘯
    5. 鍙繑鍥炲皬浜?1MB 鐨勫浘鐗囷紙Steam鍒涙剰宸ュ潑棰勮鍥惧ぇ灏忛檺鍒讹級
    """
    MAX_IMAGE_SIZE = 1 * 1024 * 1024  # 1MB
    
    try:
        # 妫€鏌ュ弬鏁版湁鏁堟€?        if not folder:
            logger.warning("鏀跺埌绌虹殑鏂囦欢澶硅矾寰勮姹?)
            return JSONResponse(content={"success": False, "error": "鏃犳晥鐨勬枃浠跺す璺緞"}, status_code=400)
        
        # 瀹夊叏璀﹀憡鏃ュ織璁板綍
        logger.warning(f"棰勮鍥剧墖鏌ユ壘璇锋眰: {folder}")
        
        # 鑾峰彇鍩虹鐩綍鍜屽厑璁歌闂殑鐩綍鍒楄〃
        base_dir = _get_app_root()
        allowed_dirs = [
            os.path.realpath(os.path.join(base_dir, 'static')),
            os.path.realpath(os.path.join(base_dir, 'assets'))
        ]
        
        # 娣诲姞"鎴戠殑鏂囨。/Xiao8"鐩綍鍒板厑璁稿垪琛?        if os.name == 'nt':  # Windows绯荤粺
            documents_path = os.path.join(os.path.expanduser('~'), 'Documents', 'Xiao8')
            if os.path.exists(documents_path):
                real_doc_path = os.path.realpath(documents_path)
                allowed_dirs.append(real_doc_path)
                logger.info(f"find-first-image: 娣诲姞鍏佽鐨勬枃妗ｇ洰褰? {real_doc_path}")
        
        # 瑙ｇ爜URL缂栫爜鐨勮矾寰?        decoded_folder = unquote(folder)
        
        # Windows璺緞澶勭悊
        if os.name == 'nt':
            decoded_folder = decoded_folder.replace('/', '\\')
        
        # 棰濆鐨勫畨鍏ㄦ鏌ワ細鎷掔粷鍖呭惈璺緞閬嶅巻瀛楃鐨勮姹?        if '..' in decoded_folder or '//' in decoded_folder:
            logger.warning(f"妫€娴嬪埌娼滃湪鐨勮矾寰勯亶鍘嗘敾鍑? {decoded_folder}")
            return JSONResponse(content={"success": False, "error": "鏃犳晥鐨勬枃浠跺す璺緞"}, status_code=403)
        
        # 瑙勮寖鍖栬矾寰勪互闃叉璺緞閬嶅巻鏀诲嚮
        try:
            real_folder = os.path.realpath(decoded_folder)
        except Exception as e:
            logger.error(f"璺緞瑙勮寖鍖栧け璐? {e}")
            return JSONResponse(content={"success": False, "error": "鏃犳晥鐨勬枃浠跺す璺緞"}, status_code=400)
        
        # 妫€鏌ヨ矾寰勬槸鍚﹀湪鍏佽鐨勭洰褰曞唴
        is_allowed = False
        for allowed_dir in allowed_dirs:
            if real_folder.startswith(allowed_dir):
                is_allowed = True
                break
        
        if not is_allowed:
            logger.warning(f"璁块棶琚嫆缁濓細璺緞涓嶅湪鍏佽鐨勭洰褰曞唴 - {real_folder}")
            return JSONResponse(content={"success": False, "error": "鏃犳晥鐨勬枃浠跺す璺緞"}, status_code=403)
        
        # 妫€鏌ユ枃浠跺す鏄惁瀛樺湪
        if not os.path.exists(real_folder) or not os.path.isdir(real_folder):
            return JSONResponse(content={"success": False, "error": "鏃犳晥鐨勬枃浠跺す璺緞"}, status_code=400)
        
        # 鍙煡鎵炬寚瀹氱殑8涓瑙堝浘鐗囧悕绉帮紝鎸変紭鍏堢骇椤哄簭
        preview_image_names = [
            'preview.jpg', 'preview.png',
            'thumbnail.jpg', 'thumbnail.png',
            'icon.jpg', 'icon.png',
            'header.jpg', 'header.png'
        ]
        
        for image_name in preview_image_names:
            image_path = os.path.join(real_folder, image_name)
            try:
                # 妫€鏌ユ枃浠舵槸鍚﹀瓨鍦?                if os.path.exists(image_path) and os.path.isfile(image_path):
                    # 妫€鏌ユ枃浠跺ぇ灏忔槸鍚﹀皬浜?1MB
                    file_size = os.path.getsize(image_path)
                    if file_size >= MAX_IMAGE_SIZE:
                        logger.info(f"璺宠繃澶т簬1MB鐨勫浘鐗? {image_name} ({file_size / 1024 / 1024:.2f}MB)")
                        continue
                    
                    # 鍐嶆楠岃瘉鍥剧墖鏂囦欢璺緞鏄惁鍦ㄥ厑璁哥殑鐩綍鍐?                    real_image_path = os.path.realpath(image_path)
                    if any(real_image_path.startswith(allowed_dir) for allowed_dir in allowed_dirs):
                        # 鍙繑鍥炵浉瀵硅矾寰勬垨鏂囦欢鍚嶏紝涓嶈繑鍥炲畬鏁寸殑鏂囦欢绯荤粺璺緞锛岄伩鍏嶄俊鎭硠闇?                        # 璁＄畻鐩稿浜巄ase_dir鐨勭浉瀵硅矾寰?                        try:
                            relative_path = os.path.relpath(real_image_path, base_dir)
                            return JSONResponse(content={"success": True, "imagePath": relative_path})
                        except ValueError:
                            # 濡傛灉鏃犳硶璁＄畻鐩稿璺緞锛堜緥濡傝法椹卞姩鍣級锛屽彧杩斿洖鏂囦欢鍚?                            return JSONResponse(content={"success": True, "imagePath": image_name})
            except Exception as e:
                logger.error(f"妫€鏌ュ浘鐗囨枃浠?{image_name} 澶辫触: {e}")
                continue
        
        return JSONResponse(content={"success": False, "error": "鏈壘鍒板皬浜?MB鐨勯瑙堝浘鐗囨枃浠?})
        
    except Exception as e:
        logger.error(f"鏌ユ壘棰勮鍥剧墖鏂囦欢澶辫触: {e}")
        # 鍙戠敓寮傚父鏃朵笉娉勯湶璇︾粏淇℃伅
        return JSONResponse(content={"success": False, "error": "鏈嶅姟鍣ㄥ唴閮ㄩ敊璇?}, status_code=500)

# 杈呭姪鍑芥暟
def get_folder_size(folder_path):
    """鑾峰彇鏂囦欢澶瑰ぇ灏忥紙瀛楄妭锛?""
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(folder_path):
        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            try:
                total_size += os.path.getsize(filepath)
            except (OSError, FileNotFoundError):
                continue
    return total_size

def find_preview_image_in_folder(folder_path):
    """鍦ㄦ枃浠跺す涓煡鎵鹃瑙堝浘鐗囷紝鍙煡鎵炬寚瀹氱殑8涓浘鐗囧悕绉?""
    # 鎸変紭鍏堢骇椤哄簭鏌ユ壘鎸囧畾鐨勫浘鐗囨枃浠跺垪琛?    preview_image_names = ['preview.jpg', 'preview.png', 'thumbnail.jpg', 'thumbnail.png', 
                         'icon.jpg', 'icon.png', 'header.jpg', 'header.png']
    
    for image_name in preview_image_names:
        image_path = os.path.join(folder_path, image_name)
        if os.path.exists(image_path) and os.path.isfile(image_path):
            return image_path
    
    # 濡傛灉鎵句笉鍒版寚瀹氱殑鍥剧墖鍚嶇О锛岃繑鍥濶one
    return None

@app.get('/live2d_emotion_manager', response_class=HTMLResponse)
async def live2d_emotion_manager(request: Request):
    """Live2D鎯呮劅鏄犲皠绠＄悊鍣ㄩ〉闈?""
    try:
        template_path = os.path.join(_get_app_root(), 'templates', 'live2d_emotion_manager.html')
        with open(template_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return HTMLResponse(content=content)
    except Exception as e:
        logger.error(f"鍔犺浇Live2D鎯呮劅鏄犲皠绠＄悊鍣ㄩ〉闈㈠け璐? {e}")
        return JSONResponse(status_code=500, content={"error": str(e)})

@app.get('/api/live2d/emotion_mapping/{model_name}')
async def get_emotion_mapping(model_name: str):
    """鑾峰彇鎯呯华鏄犲皠閰嶇疆"""
    try:
        # 鏌ユ壘妯″瀷鐩綍锛堝彲鑳藉湪static鎴栫敤鎴锋枃妗ｇ洰褰曪級
        model_dir, url_prefix = find_model_directory(model_name)
        if not os.path.exists(model_dir):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷鐩綍涓嶅瓨鍦?})
        
        # 鏌ユ壘.model3.json鏂囦欢
        model_json_path = None
        for file in os.listdir(model_dir):
            if file.endswith('.model3.json'):
                model_json_path = os.path.join(model_dir, file)
                break
        
        if not model_json_path or not os.path.exists(model_json_path):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷閰嶇疆鏂囦欢涓嶅瓨鍦?})
        
        with open(model_json_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)

        # 浼樺厛浣跨敤 EmotionMapping锛涜嫢涓嶅瓨鍦ㄥ垯浠?FileReferences 鎺ㄥ
        emotion_mapping = config_data.get('EmotionMapping')
        if not emotion_mapping:
            derived_mapping = {"motions": {}, "expressions": {}}
            file_refs = config_data.get('FileReferences', {}) or {}

            # 浠庢爣鍑?Motions 缁撴瀯鎺ㄥ
            motions = file_refs.get('Motions', {}) or {}
            for group_name, items in motions.items():
                files = []
                for item in items or []:
                    try:
                        file_path = item.get('File') if isinstance(item, dict) else None
                        if file_path:
                            files.append(file_path.replace('\\', '/'))
                    except Exception:
                        continue
                derived_mapping["motions"][group_name] = files

            # 浠庢爣鍑?Expressions 缁撴瀯鎺ㄥ锛堟寜 Name 鐨勫墠缂€杩涜鍒嗙粍锛屽 happy_xxx锛?            expressions = file_refs.get('Expressions', []) or []
            for item in expressions:
                if not isinstance(item, dict):
                    continue
                name = item.get('Name') or ''
                file_path = item.get('File') or ''
                if not file_path:
                    continue
                file_path = file_path.replace('\\', '/')
                # 鏍规嵁绗竴涓笅鍒掔嚎鎷嗗垎鍒嗙粍
                if '_' in name:
                    group = name.split('_', 1)[0]
                else:
                    # 鏃犲墠缂€鐨勫綊鍏?neutral 缁勶紝閬垮厤涓㈠け
                    group = 'neutral'
                derived_mapping["expressions"].setdefault(group, []).append(file_path)

            emotion_mapping = derived_mapping
        
        return {"success": True, "config": emotion_mapping}
    except Exception as e:
        logger.error(f"鑾峰彇鎯呯华鏄犲皠閰嶇疆澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.post('/api/live2d/upload_model')
async def upload_live2d_model(files: list[UploadFile] = File(...)):
    """涓婁紶Live2D妯″瀷鍒扮敤鎴锋枃妗ｇ洰褰?""
    import shutil
    import tempfile
    import zipfile
    
    try:
        if not files:
            return JSONResponse(status_code=400, content={"success": False, "error": "娌℃湁涓婁紶鏂囦欢"})
        
        # 鍒涘缓涓存椂鐩綍鏉ュ鐞嗕笂浼犵殑鏂囦欢
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = pathlib.Path(temp_dir)
            
            # 淇濆瓨鎵€鏈変笂浼犵殑鏂囦欢鍒颁复鏃剁洰褰曪紝淇濇寔鐩綍缁撴瀯
            for file in files:
                # 浠庢枃浠剁殑鐩稿璺緞涓彁鍙栫洰褰曠粨鏋?                file_path = file.filename
                # 纭繚璺緞瀹夊叏锛岀Щ闄ゅ彲鑳界殑鍗遍櫓璺緞瀛楃
                file_path = file_path.replace('\\', '/').lstrip('/')
                
                target_file_path = temp_path / file_path
                target_file_path.parent.mkdir(parents=True, exist_ok=True)
                
                # 淇濆瓨鏂囦欢
                with open(target_file_path, 'wb') as f:
                    content = await file.read()
                    f.write(content)
            
            # 鍦ㄤ复鏃剁洰褰曚腑閫掑綊鏌ユ壘.model3.json鏂囦欢
            model_json_files = list(temp_path.rglob('*.model3.json'))
            
            if not model_json_files:
                return JSONResponse(status_code=400, content={"success": False, "error": "鏈壘鍒?model3.json鏂囦欢"})
            
            if len(model_json_files) > 1:
                return JSONResponse(status_code=400, content={"success": False, "error": "涓婁紶鐨勬枃浠朵腑鍖呭惈澶氫釜.model3.json鏂囦欢"})
            
            model_json_file = model_json_files[0]
            
            # 纭畾妯″瀷鏍圭洰褰曪紙.model3.json鏂囦欢鐨勭埗鐩綍锛?            model_root_dir = model_json_file.parent
            model_name = model_root_dir.name
            
            # 鑾峰彇鐢ㄦ埛鏂囨。鐨刲ive2d鐩綍
            config_mgr = get_config_manager()
            config_mgr.ensure_live2d_directory()
            user_live2d_dir = config_mgr.live2d_dir
            
            # 鐩爣鐩綍
            target_model_dir = user_live2d_dir / model_name
            
            # 濡傛灉鐩爣鐩綍宸插瓨鍦紝杩斿洖閿欒鎴栬鐩栵紙杩欓噷閫夋嫨杩斿洖閿欒锛?            if target_model_dir.exists():
                return JSONResponse(status_code=400, content={
                    "success": False, 
                    "error": f"妯″瀷 {model_name} 宸插瓨鍦紝璇峰厛鍒犻櫎鎴栭噸鍛藉悕鐜版湁妯″瀷"
                })
            
            # 澶嶅埗妯″瀷鏍圭洰褰曞埌鐢ㄦ埛鏂囨。鐨刲ive2d鐩綍
            shutil.copytree(model_root_dir, target_model_dir)

            # 涓婁紶鍚庯細閬嶅巻妯″瀷鐩綍涓殑鎵€鏈夊姩浣滄枃浠讹紙*.motion3.json锛夛紝
            # 灏嗗畼鏂圭櫧鍚嶅崟鍙傛暟鍙婃ā鍨嬭嚜韬湪 .model3.json 涓０鏄庝负 LipSync 鐨勫弬鏁扮殑 Segments 娓呯┖涓?[]銆?            # 杩欐牱鍙互鍏奸【瀹樻柟鍙傛暟涓庢ā鍨嬪０鏄庣殑鍙ｅ瀷鍙傛暟锛屽悓鏃跺拷鐣ユ湭澹版槑鐨勪綔鑰呰嚜瀹氫箟鍛藉悕锛堥伩鍏嶈浼わ級銆?            try:
                import json as _json

                # 瀹樻柟鍙ｅ瀷鍙傛暟鐧藉悕鍗曪紙灏介噺鍏ㄩ潰鍒楀嚭甯歌鍜屽畼鏂瑰懡鍚嶇殑鍢撮儴/鍙ｅ瀷鐩稿叧鍙傛暟锛?                # 浠呭寘鍚笌鍢村反褰㈢姸銆佸彂闊冲抚锛圓/I/U/E/O锛夈€佷笅棰?鍞囧姩浣滅洿鎺ョ浉鍏崇殑鍙傛暟锛?                # 鏄庣‘鎺掗櫎澶撮儴/韬綋/琛ㄦ儏绛夊叾瀹冨弬鏁帮紙渚嬪 ParamAngleZ銆丳aramAngleX 绛変笉搴斿湪姝わ級銆?                official_mouth_params = {
                    # 浜斾釜鍩烘湰鍙戦煶甯э紙A/I/U/E/O锛?                    'ParamA', 'ParamI', 'ParamU', 'ParamE', 'ParamO',
                    # 甯歌鍢撮儴涓婁笅/寮€鍚?褰㈢姸鍙傛暟
                    'ParamMouthUp', 'ParamMouthDown', 'ParamMouthOpen', 'ParamMouthOpenY',
                    'ParamMouthForm', 'ParamMouthX', 'ParamMouthY', 'ParamMouthSmile', 'ParamMouthPucker',
                    'ParamMouthStretch', 'ParamMouthShrug', 'ParamMouthLeft', 'ParamMouthRight',
                    'ParamMouthCornerUpLeft', 'ParamMouthCornerUpRight',
                    'ParamMouthCornerDownLeft', 'ParamMouthCornerDownRight',
                    # 鍞囩浉鍏筹紙閮ㄥ垎妯″瀷/瀹樻柟鎵╁睍涓彲鑳藉嚭鐜帮級
                    'ParamLipA', 'ParamLipI', 'ParamLipU', 'ParamLipE', 'ParamLipO', 'ParamLipThickness',
                    # 涓嬮锛堥儴鍒嗘ā鍨嬩互涓嬮鎺у埗鍙ｅ瀷锛?                    'ParamJawOpen', 'ParamJawForward', 'ParamJawLeft', 'ParamJawRight',
                    # 鍏跺畠鍙ｅ瀷鐩稿叧锛堜繚瀹堝垪鍏ワ級
                    'ParamMouthAngry', 'ParamMouthAngryLine'
                }

                # 灏濊瘯璇诲彇妯″瀷鐨?.model3.json锛屾彁鍙?Groups -> Name == "LipSync" && Target == "Parameter" 鐨?Ids
                model_declared_mouth_params = set()
                try:
                    local_model_json = target_model_dir / model_json_file.name
                    if local_model_json.exists():
                        with open(local_model_json, 'r', encoding='utf-8') as mf:
                            try:
                                model_cfg = _json.load(mf)
                                groups = model_cfg.get('Groups') if isinstance(model_cfg, dict) else None
                                if isinstance(groups, list):
                                    for grp in groups:
                                        try:
                                            if not isinstance(grp, dict):
                                                continue
                                            # 浠呰€冭檻瀹樻柟 Group Name 涓?LipSync 涓?Target 涓?Parameter 鐨勬潯鐩?                                            if grp.get('Name') == 'LipSync' and grp.get('Target') == 'Parameter':
                                                ids = grp.get('Ids') or []
                                                for pid in ids:
                                                    if isinstance(pid, str) and pid:
                                                        model_declared_mouth_params.add(pid)
                                        except Exception:
                                            continue
                            except Exception:
                                # 瑙ｆ瀽澶辫触鍒欒涓烘湭鎵惧埌 groups锛岀户缁娇鐢ㄥ畼鏂圭櫧鍚嶅崟
                                pass
                except Exception:
                    pass

                # 鍚堝苟鐧藉悕鍗曪紙瀹樻柟 + 妯″瀷澹版槑锛?                mouth_param_whitelist = set(official_mouth_params)
                mouth_param_whitelist.update(model_declared_mouth_params)

                for motion_path in target_model_dir.rglob('*.motion3.json'):
                    try:
                        with open(motion_path, 'r', encoding='utf-8') as mf:
                            try:
                                motion_data = _json.load(mf)
                            except Exception:
                                # 闈?JSON 鎴栬В鏋愬け璐ュ垯璺宠繃
                                continue

                        modified = False
                        curves = motion_data.get('Curves') if isinstance(motion_data, dict) else None
                        if isinstance(curves, list):
                            for curve in curves:
                                try:
                                    if not isinstance(curve, dict):
                                        continue
                                    cid = curve.get('Id')
                                    if not cid:
                                        continue
                                    # 涓ユ牸鎸夌櫧鍚嶅崟鍖归厤锛堥伩鍏嶆ā绯婂尮閰嶈浼わ級
                                    if cid in mouth_param_whitelist:
                                        # 娓呯┖ Segments锛堣嫢瀛樺湪锛?                                        if 'Segments' in curve and curve['Segments']:
                                            curve['Segments'] = []
                                            modified = True
                                except Exception:
                                    continue

                        if modified:
                            try:
                                with open(motion_path, 'w', encoding='utf-8') as mf:
                                    _json.dump(motion_data, mf, ensure_ascii=False, indent=4)
                                logger.info(f"宸叉竻闄ゅ彛鍨嬪弬鏁帮細{motion_path}")
                            except Exception:
                                # 鍐欏叆澶辫触鍒欒褰曚絾涓嶉樆姝笂浼?                                logger.exception(f"鍐欏叆 motion 鏂囦欢澶辫触: {motion_path}")
                    except Exception:
                        continue
            except Exception:
                logger.exception("澶勭悊 motion 鏂囦欢鏃跺彂鐢熼敊璇?)
            
            logger.info(f"鎴愬姛涓婁紶Live2D妯″瀷: {model_name} -> {target_model_dir}")
            
            return JSONResponse(content={
                "success": True,
                "message": f"妯″瀷 {model_name} 涓婁紶鎴愬姛",
                "model_name": model_name,
                "model_path": str(target_model_dir)
            })
            
    except Exception as e:
        logger.error(f"涓婁紶Live2D妯″瀷澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.post('/api/live2d/emotion_mapping/{model_name}')
async def update_emotion_mapping(model_name: str, request: Request):
    """鏇存柊鎯呯华鏄犲皠閰嶇疆"""
    try:
        data = await request.json()
        
        if not data:
            return JSONResponse(status_code=400, content={"success": False, "error": "鏃犳晥鐨勬暟鎹?})

        # 鏌ユ壘妯″瀷鐩綍锛堝彲鑳藉湪static鎴栫敤鎴锋枃妗ｇ洰褰曪級
        model_dir, url_prefix = find_model_directory(model_name)
        if not os.path.exists(model_dir):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷鐩綍涓嶅瓨鍦?})
        
        # 鏌ユ壘.model3.json鏂囦欢
        model_json_path = None
        for file in os.listdir(model_dir):
            if file.endswith('.model3.json'):
                model_json_path = os.path.join(model_dir, file)
                break
        
        if not model_json_path or not os.path.exists(model_json_path):
            return JSONResponse(status_code=404, content={"success": False, "error": "妯″瀷閰嶇疆鏂囦欢涓嶅瓨鍦?})

        with open(model_json_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)

        # 缁熶竴鍐欏叆鍒版爣鍑?Cubism 缁撴瀯锛團ileReferences.Motions / FileReferences.Expressions锛?        file_refs = config_data.setdefault('FileReferences', {})

        # 澶勭悊 motions: data 缁撴瀯涓?{ motions: { emotion: ["motions/xxx.motion3.json", ...] }, expressions: {...} }
        motions_input = (data.get('motions') if isinstance(data, dict) else None) or {}
        motions_output = {}
        for group_name, files in motions_input.items():
            # 绂佹鍦?甯搁┗"缁勯厤缃换浣昺otion
            if group_name == '甯搁┗':
                logger.info("蹇界暐甯搁┗缁勪腑鐨刴otion閰嶇疆锛堝彧鍏佽expression锛?)
                continue
            items = []
            for file_path in files or []:
                if not isinstance(file_path, str):
                    continue
                normalized = file_path.replace('\\', '/').lstrip('./')
                items.append({"File": normalized})
            motions_output[group_name] = items
        file_refs['Motions'] = motions_output

        # 澶勭悊 expressions: 灏嗘寜 emotion 鍓嶇紑鐢熸垚鎵佸钩鍒楄〃锛孨ame 閲囩敤 "{emotion}_{basename}" 鐨勭害瀹?        expressions_input = (data.get('expressions') if isinstance(data, dict) else None) or {}

        # 鍏堜繚鐣欎笉灞炰簬鎴戜滑鎯呮劅鍓嶇紑鐨勫師濮嬭〃杈撅紙閬垮厤瑕嗙洊鐢ㄦ埛鑷畾涔夛級
        existing_expressions = file_refs.get('Expressions', []) or []
        emotion_prefixes = set(expressions_input.keys())
        preserved_expressions = []
        for item in existing_expressions:
            try:
                name = (item.get('Name') or '') if isinstance(item, dict) else ''
                prefix = name.split('_', 1)[0] if '_' in name else None
                if not prefix or prefix not in emotion_prefixes:
                    preserved_expressions.append(item)
            except Exception:
                preserved_expressions.append(item)

        new_expressions = []
        for emotion, files in expressions_input.items():
            for file_path in files or []:
                if not isinstance(file_path, str):
                    continue
                normalized = file_path.replace('\\', '/').lstrip('./')
                base = os.path.basename(normalized)
                base_no_ext = base.replace('.exp3.json', '')
                name = f"{emotion}_{base_no_ext}"
                new_expressions.append({"Name": name, "File": normalized})

        file_refs['Expressions'] = preserved_expressions + new_expressions

        # 鍚屾椂淇濈暀涓€浠?EmotionMapping锛堜緵绠＄悊鍣ㄨ鍙栦笌鍚戝悗鍏煎锛?        config_data['EmotionMapping'] = data

        # 淇濆瓨閰嶇疆鍒版枃浠?        with open(model_json_path, 'w', encoding='utf-8') as f:
            json.dump(config_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"妯″瀷 {model_name} 鐨勬儏缁槧灏勯厤缃凡鏇存柊锛堝凡鍚屾鍒?FileReferences锛?)
        return {"success": True, "message": "鎯呯华鏄犲皠閰嶇疆宸蹭繚瀛?}
    except Exception as e:
        logger.error(f"鏇存柊鎯呯华鏄犲皠閰嶇疆澶辫触: {e}")
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.post('/api/memory/recent_file/save')
async def save_recent_file(request: Request):
    import os, json
    data = await request.json()
    filename = data.get('filename')
    chat = data.get('chat')
    from utils.config_manager import get_config_manager
    cm = get_config_manager()
    file_path = str(cm.memory_dir / filename)
    if not (filename and filename.startswith('recent') and filename.endswith('.json')):
        return JSONResponse({"success": False, "error": "鏂囦欢鍚嶄笉鍚堟硶"}, status_code=400)
    arr = []
    for msg in chat:
        t = msg.get('role')
        text = msg.get('text', '')
        arr.append({
            "type": t,
            "data": {
                "content": text,
                "additional_kwargs": {},
                "response_metadata": {},
                "type": t,
                "name": None,
                "id": None,
                "example": False,
                **({"tool_calls": [], "invalid_tool_calls": [], "usage_metadata": None} if t == "ai" else {})
            }
        })
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(arr, f, ensure_ascii=False, indent=2)
        return {"success": True}
    except Exception as e:
        return {"success": False, "error": str(e)}

@app.post('/api/memory/update_catgirl_name')
async def update_catgirl_name(request: Request):
    """
    鏇存柊璁板繂鏂囦欢涓殑鐚鍚嶇О
    1. 閲嶅懡鍚嶈蹇嗘枃浠?    2. 鏇存柊鏂囦欢鍐呭涓殑鐚鍚嶇О寮曠敤
    """
    import os, json
    data = await request.json()
    old_name = data.get('old_name')
    new_name = data.get('new_name')
    
    if not old_name or not new_name:
        return JSONResponse({"success": False, "error": "缂哄皯蹇呰鍙傛暟"}, status_code=400)
    
    try:
        from utils.config_manager import get_config_manager
        cm = get_config_manager()
        
        # 1. 閲嶅懡鍚嶈蹇嗘枃浠?        old_filename = f'recent_{old_name}.json'
        new_filename = f'recent_{new_name}.json'
        old_file_path = str(cm.memory_dir / old_filename)
        new_file_path = str(cm.memory_dir / new_filename)
        
        # 妫€鏌ユ棫鏂囦欢鏄惁瀛樺湪
        if not os.path.exists(old_file_path):
            logger.warning(f"璁板繂鏂囦欢涓嶅瓨鍦? {old_file_path}")
            return JSONResponse({"success": False, "error": f"璁板繂鏂囦欢涓嶅瓨鍦? {old_filename}"}, status_code=404)
        
        # 濡傛灉鏂版枃浠跺凡瀛樺湪锛屽厛鍒犻櫎
        if os.path.exists(new_file_path):
            os.remove(new_file_path)
        
        # 閲嶅懡鍚嶆枃浠?        os.rename(old_file_path, new_file_path)
        
        # 2. 鏇存柊鏂囦欢鍐呭涓殑鐚鍚嶇О寮曠敤
        with open(new_file_path, 'r', encoding='utf-8') as f:
            file_content = json.load(f)
        
        # 閬嶅巻鎵€鏈夋秷鎭紝浠呭湪鐗瑰畾瀛楁涓洿鏂扮尗濞樺悕绉?        for item in file_content:
            if isinstance(item, dict):
                # 瀹夊叏鐨勬柟寮忥細鍙湪鐗瑰畾鐨勫瓧娈典腑鏇挎崲鐚鍚嶇О
                # 閬垮厤鍦ㄦ暣涓猚ontent涓繘琛屽瓧绗︿覆鏇挎崲
                
                # 妫€鏌ヨ鑹插悕绉扮浉鍏冲瓧娈?                name_fields = ['speaker', 'author', 'name', 'character', 'role']
                for field in name_fields:
                    if field in item and isinstance(item[field], str) and old_name in item[field]:
                        if item[field] == old_name:  # 瀹屽叏鍖归厤鎵嶆浛鎹?                            item[field] = new_name
                            logger.debug(f"鏇存柊瑙掕壊鍚嶇О瀛楁 {field}: {old_name} -> {new_name}")
                
                # 濡傛灉item鏈塪ata宓屽缁撴瀯锛屼篃妫€鏌ュ叾涓殑name瀛楁
                if 'data' in item and isinstance(item['data'], dict):
                    data = item['data']
                    for field in name_fields:
                        if field in data and isinstance(data[field], str) and old_name in data[field]:
                            if data[field] == old_name:  # 瀹屽叏鍖归厤鎵嶆浛鎹?                                data[field] = new_name
                                logger.debug(f"鏇存柊data涓鑹插悕绉板瓧娈?{field}: {old_name} -> {new_name}")
                    
                    # 瀵逛簬content瀛楁锛屼娇鐢ㄦ洿淇濆畧鐨勬柟娉?- 浠呭湪鏄庣‘鏍囪瘑涓鸿鑹插悕绉扮殑鍦版柟鏇挎崲
                    if 'content' in data and isinstance(data['content'], str):
                        content = data['content']
                        # 妫€鏌ユ槸鍚︽槸鏄庣‘鐨勮鑹插彂瑷€鏍煎紡锛屽"灏忕櫧璇达細"鎴?灏忕櫧: "
                        # 杩欑鏍煎紡閫氬父琛ㄧず鍚庨潰鐨勫唴瀹规槸瑙掕壊鍙戣█
                        patterns = [
                            f"{old_name}璇达細",  # 涓枃鍐掑彿
                            f"{old_name}璇?",   # 鑻辨枃鍐掑彿  
                            f"{old_name}:",     # 绾啋鍙?                            f"{old_name}->",    # 绠ご
                            f"[{old_name}]",    # 鏂规嫭鍙?                        ]
                        
                        for pattern in patterns:
                            if pattern in content:
                                new_pattern = pattern.replace(old_name, new_name)
                                content = content.replace(pattern, new_pattern)
                                logger.debug(f"鍦ㄦ秷鎭唴瀹逛腑鍙戠幇瑙掕壊鏍囪瘑锛屾洿鏂? {pattern} -> {new_pattern}")
                        
                        data['content'] = content
        
        # 淇濆瓨鏇存柊鍚庣殑鍐呭
        with open(new_file_path, 'w', encoding='utf-8') as f:
            json.dump(file_content, f, ensure_ascii=False, indent=2)
        
        logger.info(f"宸叉洿鏂扮尗濞樺悕绉颁粠 '{old_name}' 鍒?'{new_name}' 鐨勮蹇嗘枃浠?)
        return {"success": True}
    except Exception as e:
        logger.exception("鏇存柊鐚鍚嶇О澶辫触")
        return {"success": False, "error": str(e)}

@app.post('/api/emotion/analysis')
async def emotion_analysis(request: Request):
    try:
        data = await request.json()
        if not data or 'text' not in data:
            return {"error": "璇锋眰浣撲腑蹇呴』鍖呭惈text瀛楁"}
        
        text = data['text']
        api_key = data.get('api_key')
        model = data.get('model')
        
        # 浣跨敤鍙傛暟鎴栭粯璁ら厤缃紝浣跨敤 .get() 瀹夊叏鑾峰彇閬垮厤 KeyError
        emotion_config = _config_manager.get_model_api_config('emotion')
        emotion_api_key = emotion_config.get('api_key')
        emotion_model = emotion_config.get('model')
        emotion_base_url = emotion_config.get('base_url')
        
        # 浼樺厛浣跨敤璇锋眰鍙傛暟锛屽叾娆′娇鐢ㄩ厤缃?        api_key = api_key or emotion_api_key
        model = model or emotion_model
        
        if not api_key:
            return {"error": "鎯呯华鍒嗘瀽妯″瀷閰嶇疆缂哄け: API瀵嗛挜鏈彁渚涗笖閰嶇疆涓湭璁剧疆榛樿瀵嗛挜"}
        
        if not model:
            return {"error": "鎯呯华鍒嗘瀽妯″瀷閰嶇疆缂哄け: 妯″瀷鍚嶇О鏈彁渚涗笖閰嶇疆涓湭璁剧疆榛樿妯″瀷"}
        
        # 鍒涘缓寮傛瀹㈡埛绔?        client = AsyncOpenAI(api_key=api_key, base_url=emotion_base_url)
        
        # 鏋勫缓璇锋眰娑堟伅
        messages = [
            {
                "role": "system", 
                "content": emotion_analysis_prompt
            },
            {
                "role": "user", 
                "content": text
            }
        ]
        
        # 寮傛璋冪敤妯″瀷
        request_params = {
            "model": model,
            "messages": messages,
            "temperature": 0.3,
            "max_tokens": 100
        }
        
        # 鍙湁鍦ㄩ渶瑕佹椂鎵嶆坊鍔?extra_body
        if model in MODELS_WITH_EXTRA_BODY:
            request_params["extra_body"] = {"enable_thinking": False}
        
        response = await client.chat.completions.create(**request_params)
        
        # 瑙ｆ瀽鍝嶅簲
        result_text = response.choices[0].message.content.strip()
        
        # 灏濊瘯瑙ｆ瀽JSON鍝嶅簲
        try:
            import json
            result = json.loads(result_text)
            # 鑾峰彇emotion鍜宑onfidence
            emotion = result.get("emotion", "neutral")
            confidence = result.get("confidence", 0.5)
            
            # 褰揷onfidence灏忎簬0.3鏃讹紝鑷姩灏唀motion璁剧疆涓簄eutral
            if confidence < 0.3:
                emotion = "neutral"
            
            # 鑾峰彇 lanlan_name 骞舵帹閫佸埌 monitor
            lanlan_name = data.get('lanlan_name')
            if lanlan_name and lanlan_name in sync_message_queue:
                sync_message_queue[lanlan_name].put({
                    "type": "json",
                    "data": {
                        "type": "emotion",
                        "emotion": emotion,
                        "confidence": confidence
                    }
                })
            
            return {
                "emotion": emotion,
                "confidence": confidence
            }
        except json.JSONDecodeError:
            # 濡傛灉JSON瑙ｆ瀽澶辫触锛岃繑鍥炵畝鍗曠殑鎯呮劅鍒ゆ柇
            return {
                "emotion": "neutral",
                "confidence": 0.5
            }
            
    except Exception as e:
        logger.error(f"鎯呮劅鍒嗘瀽澶辫触: {e}")
        return {
            "error": f"鎯呮劅鍒嗘瀽澶辫触: {str(e)}",
            "emotion": "neutral",
            "confidence": 0.0
        }

@app.get('/memory_browser', response_class=HTMLResponse)
async def memory_browser(request: Request):
    return templates.TemplateResponse('templates/memory_browser.html', {"request": request})


@app.get("/{lanlan_name}", response_class=HTMLResponse)
async def get_index(request: Request, lanlan_name: str):
    # lanlan_name 灏嗕粠 URL 涓彁鍙栵紝鍓嶇浼氶€氳繃 API 鑾峰彇閰嶇疆
    return templates.TemplateResponse("templates/index.html", {
        "request": request
    })

@app.post('/api/agent/flags')
async def update_agent_flags(request: Request):
    """鏉ヨ嚜鍓嶇鐨凙gent寮€鍏虫洿鏂帮紝绾ц仈鍒板悇鑷殑session manager銆?""
    try:
        data = await request.json()
        _, her_name_current, _, _, _, _, _, _, _, _ = _config_manager.get_character_data()
        lanlan = data.get('lanlan_name') or her_name_current
        flags = data.get('flags') or {}
        mgr = session_manager.get(lanlan)
        if not mgr:
            return JSONResponse({"success": False, "error": "lanlan not found"}, status_code=404)
        # Update core flags first
        mgr.update_agent_flags(flags)
        # Forward to tool server for MCP/Computer-Use flags
        try:
            forward_payload = {}
            if 'mcp_enabled' in flags:
                forward_payload['mcp_enabled'] = bool(flags['mcp_enabled'])
            if 'computer_use_enabled' in flags:
                forward_payload['computer_use_enabled'] = bool(flags['computer_use_enabled'])
            # Forward user_plugin_enabled as well so agent_server receives UI toggles
            if 'user_plugin_enabled' in flags:
                forward_payload['user_plugin_enabled'] = bool(flags['user_plugin_enabled'])
            if forward_payload:
                async with httpx.AsyncClient(timeout=0.7) as client:
                    r = await client.post(f"http://localhost:{TOOL_SERVER_PORT}/agent/flags", json=forward_payload)
                    if not r.is_success:
                        raise Exception(f"tool_server responded {r.status_code}")
        except Exception as e:
            # On failure, reset flags in core to safe state (include user_plugin flag)
            mgr.update_agent_flags({'agent_enabled': False, 'computer_use_enabled': False, 'mcp_enabled': False, 'user_plugin_enabled': False})
            return JSONResponse({"success": False, "error": f"tool_server forward failed: {e}"}, status_code=502)
        return {"success": True}
    except Exception as e:
        return JSONResponse({"success": False, "error": str(e)}, status_code=500)


@app.get('/api/agent/flags')
async def get_agent_flags():
    """鑾峰彇褰撳墠 agent flags 鐘舵€侊紙渚涘墠绔悓姝ワ級"""
    try:
        async with httpx.AsyncClient(timeout=0.7) as client:
            r = await client.get(f"http://localhost:{TOOL_SERVER_PORT}/agent/flags")
            if not r.is_success:
                return JSONResponse({"success": False, "error": "tool_server down"}, status_code=502)
            return r.json()
    except Exception as e:
        return JSONResponse({"success": False, "error": str(e)}, status_code=502)


@app.get('/api/agent/health')
async def agent_health():
    """Check tool_server health via main_server proxy."""
    try:
        async with httpx.AsyncClient(timeout=0.7) as client:
            r = await client.get(f"http://localhost:{TOOL_SERVER_PORT}/health")
            if not r.is_success:
                return JSONResponse({"status": "down"}, status_code=502)
            data = {}
            try:
                data = r.json()
            except Exception:
                pass
            return {"status": "ok", **({"tool": data} if isinstance(data, dict) else {})}
    except Exception:
        return JSONResponse({"status": "down"}, status_code=502)


@app.get('/api/agent/computer_use/availability')
async def proxy_cu_availability():
    try:
        async with httpx.AsyncClient(timeout=1.5) as client:
            r = await client.get(f"http://localhost:{TOOL_SERVER_PORT}/computer_use/availability")
            if not r.is_success:
                return JSONResponse({"ready": False, "reasons": [f"tool_server responded {r.status_code}"]}, status_code=502)
            return r.json()
    except Exception as e:
        return JSONResponse({"ready": False, "reasons": [f"proxy error: {e}"]}, status_code=502)


@app.get('/api/agent/mcp/availability')
async def proxy_mcp_availability():
    try:
        async with httpx.AsyncClient(timeout=1.5) as client:
            r = await client.get(f"http://localhost:{TOOL_SERVER_PORT}/mcp/availability")
            if not r.is_success:
                return JSONResponse({"ready": False, "reasons": [f"tool_server responded {r.status_code}"]}, status_code=502)
            return r.json()
    except Exception as e:
        return JSONResponse({"ready": False, "reasons": [f"proxy error: {e}"]}, status_code=502)

@app.get('/api/agent/user_plugin/availability')
async def proxy_up_availability():
    try:
        async with httpx.AsyncClient(timeout=1.5) as client:
            r = await client.get(f"http://localhost:{USER_PLUGIN_SERVER_PORT}/available")
            if r.is_success:
                return JSONResponse({"ready": True, "reasons": ["user_plugin server reachable"]}, status_code=200)
            else:
                return JSONResponse({"ready": False, "reasons": [f"user_plugin server responded {r.status_code}"]}, status_code=502)
    except Exception as e:
        return JSONResponse({"ready": False, "reasons": [f"proxy error: {e}"]}, status_code=502)


@app.get('/api/agent/tasks')
async def proxy_tasks():
    """Get all tasks from tool server via main_server proxy."""
    try:
        async with httpx.AsyncClient(timeout=2.5) as client:
            r = await client.get(f"http://localhost:{TOOL_SERVER_PORT}/tasks")
            if not r.is_success:
                return JSONResponse({"tasks": [], "error": f"tool_server responded {r.status_code}"}, status_code=502)
            return r.json()
    except Exception as e:
        return JSONResponse({"tasks": [], "error": f"proxy error: {e}"}, status_code=502)


@app.get('/api/agent/tasks/{task_id}')
async def proxy_task_detail(task_id: str):
    """Get specific task details from tool server via main_server proxy."""
    try:
        async with httpx.AsyncClient(timeout=1.5) as client:
            r = await client.get(f"http://localhost:{TOOL_SERVER_PORT}/tasks/{task_id}")
            if not r.is_success:
                return JSONResponse({"error": f"tool_server responded {r.status_code}"}, status_code=502)
            return r.json()
    except Exception as e:
        return JSONResponse({"error": f"proxy error: {e}"}, status_code=502)


# Task status polling endpoint for frontend
@app.get('/api/agent/task_status')
async def get_task_status():
    """Get current task status for frontend polling - returns all tasks with their current status."""
    try:
        # Get tasks from tool server using async client with increased timeout
        async with httpx.AsyncClient(timeout=2.5) as client:
            r = await client.get(f"http://localhost:{TOOL_SERVER_PORT}/tasks")
            if not r.is_success:
                return JSONResponse({"tasks": [], "error": f"tool_server responded {r.status_code}"}, status_code=502)
            
            tasks_data = r.json()
            tasks = tasks_data.get("tasks", [])
            debug_info = tasks_data.get("debug", {})
            
            # Enhance task data with additional information if needed
            enhanced_tasks = []
            for task in tasks:
                enhanced_task = {
                    "id": task.get("id"),
                    "status": task.get("status", "unknown"),
                    "type": task.get("type", "unknown"),
                    "lanlan_name": task.get("lanlan_name"),
                    "start_time": task.get("start_time"),
                    "end_time": task.get("end_time"),
                    "params": task.get("params", {}),
                    "result": task.get("result"),
                    "error": task.get("error"),
                    "source": task.get("source", "unknown")  # 娣诲姞鏉ユ簮淇℃伅
                }
                enhanced_tasks.append(enhanced_task)
            
            return {
                "success": True,
                "tasks": enhanced_tasks,
                "total_count": len(enhanced_tasks),
                "running_count": len([t for t in enhanced_tasks if t.get("status") == "running"]),
                "queued_count": len([t for t in enhanced_tasks if t.get("status") == "queued"]),
                "completed_count": len([t for t in enhanced_tasks if t.get("status") == "completed"]),
                "failed_count": len([t for t in enhanced_tasks if t.get("status") == "failed"]),
                "timestamp": datetime.now().isoformat(),
                "debug": debug_info  # 浼犻€掕皟璇曚俊鎭埌鍓嶇
            }
        
    except Exception as e:
        return JSONResponse({
            "success": False,
            "tasks": [],
            "error": f"Failed to fetch task status: {str(e)}",
            "timestamp": datetime.now().isoformat()
        }, status_code=500)


@app.post('/api/agent/admin/control')
async def proxy_admin_control(payload: dict = Body(...)):
    """Proxy admin control commands to tool server."""
    try:
        import httpx
        async with httpx.AsyncClient(timeout=5.0) as client:
            r = await client.post(f"http://localhost:{TOOL_SERVER_PORT}/admin/control", json=payload)
            if not r.is_success:
                return JSONResponse({"success": False, "error": f"tool_server responded {r.status_code}"}, status_code=502)
            
            result = r.json()
            logger.info(f"Admin control result: {result}")
            return result
        
    except Exception as e:
        return JSONResponse({
            "success": False,
            "error": f"Failed to execute admin control: {str(e)}"
        }, status_code=500)


# --- Run the Server ---
if __name__ == "__main__":
    import uvicorn
    import argparse
    import os
    import signal
    
    parser = argparse.ArgumentParser()
    parser.add_argument("--open-browser",   action="store_true",
                        help="鍚姩鍚庢槸鍚︽墦寮€娴忚鍣ㄥ苟鐩戞帶瀹?)
    parser.add_argument("--page",           type=str, default="",
                        choices=["index", "chara_manager", "api_key", ""],
                        help="瑕佹墦寮€鐨勯〉闈㈣矾鐢憋紙涓嶅惈鍩熷悕鍜岀鍙ｏ級")
    args = parser.parse_args()

    logger.info("--- Starting FastAPI Server ---")
    # Use os.path.abspath to show full path clearly
    logger.info(f"Serving static files from: {os.path.abspath('static')}")
    logger.info(f"Serving index.html from: {os.path.abspath('templates/index.html')}")
    logger.info(f"Access UI at: http://127.0.0.1:{MAIN_SERVER_PORT} (or your network IP:{MAIN_SERVER_PORT})")
    logger.info("-----------------------------")

    # 浣跨敤缁熶竴鐨勯€熺巼闄愬埗鏃ュ織杩囨护鍣?    from utils.logger_config import create_main_server_filter, create_httpx_filter
    
    # Add filter to uvicorn access logger
    logging.getLogger("uvicorn.access").addFilter(create_main_server_filter())
    
    # Add filter to httpx logger for availability check requests
    logging.getLogger("httpx").addFilter(create_httpx_filter())

    # 1) 閰嶇疆 UVicorn
    config = uvicorn.Config(
        app=app,
        host="127.0.0.1",
        port=MAIN_SERVER_PORT,
        log_level="info",
        loop="asyncio",
        reload=False,
    )
    server = uvicorn.Server(config)
    
    # Set browser mode flag if --open-browser is used
    if args.open_browser:
        # 浣跨敤 FastAPI 鐨?app.state 鏉ョ鐞嗛厤缃?        start_config = {
            "browser_mode_enabled": True,
            "browser_page": args.page if args.page!='index' else '',
            'server': server
        }
        set_start_config(start_config)
    else:
        # 璁剧疆榛樿閰嶇疆
        start_config = {
            "browser_mode_enabled": False,
            "browser_page": "",
            'server': server
        }
        set_start_config(start_config)

    print(f"鍚姩閰嶇疆: {get_start_config()}")

    # 2) 瀹氫箟鏈嶅姟鍣ㄥ叧闂洖璋?    def shutdown_server():
        logger.info("鏀跺埌娴忚鍣ㄥ叧闂俊鍙凤紝姝ｅ湪鍏抽棴鏈嶅姟鍣?..")
        os.kill(os.getpid(), signal.SIGTERM)

    # 4) 鍚姩鏈嶅姟鍣紙闃诲锛岀洿鍒?server.should_exit=True锛?    logger.info("--- Starting FastAPI Server ---")
    logger.info(f"Access UI at: http://127.0.0.1:{MAIN_SERVER_PORT}/{args.page}")
    
    try:
        server.run()
    finally:
        logger.info("鏈嶅姟鍣ㄥ凡鍏抽棴")
